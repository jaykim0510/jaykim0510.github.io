---
layout: post
title:  'Coding Test Series [Part10]: 힙(Heap)'
description: 
date:   2022-07-03 15:01:35 +0300
image:  '/images/algorithm_logo.webp'
logo_image:  '/images/algorithm_logo.webp'
categories: CS
tags: Coding_Test
---
---

**Table of Contents**
{: #toc }
*  TOC
{:toc}

---

# Heap

> In many CS applications, we only need to access the largest or smallest element in the dataset. how do we efficiently access the largest or smallest element in the current dataset? The answer would be heap!

## 우선순위 큐

- 힙과 우선순위 큐는 다른 의미
- 힙은 데이터 구조(low-level), 우선순위 큐는 추상 자료형(high-level)
- 힙은 우선순위 큐를 구현하는 한 가지 방법
- 힙 말고도 배열, 링크드 리스트로 우선순위 큐를 구현할 수 있음(물론 시간 복잡도 차이 있음)

## 힙

- 힙은 **완전 이진 트리**의 특별한 케이스
  - 완전 이진 트리: 이진 트리 + 리프 노드가 왼쪽부터 채워짐
- 각 노드들은 자식 노드보다 크다 (최대힙) (최소힙은 반대)

# Heap 관련 연산

- 삽입 연산: O(logN)
- 삭제 연산: O(logN)
- 최대값/최소값 얻기: O(1)
- element가 힙에서 삽입/삭제되어도 계속 힙 성질이 유지되어야함
    - heapify 연산으로 힙 성질을 유지함
    - 한 번 삽입/삭제 연산이 일어날 때마다 heapify 실행
    - heapify: 부모 노드와 자식 노드의 값을 계속 비교하며 스왑

## 힙에 삽입이 발생한 경우

- 삽입된 노드는 리프 노드에 추가 -> 추가된 리프 노드에서 부터 heapify

## 힙에 삭제가 발생한 경우

- 삭제는 항상 루트 노드에서 발생 -> 루트 노드의 빈자리는 리프 노드가 채움 -> 루트 노드에서 부터 heapify

# Heap 구현

## 파이썬의 heapq 모듈

- 힙을 파이썬에서 사용할 때는 간단히 heapq 모듈을 이용해 사용 가능
  ```python
  import heapq

  heap_list = []

  # Insert
  heapq.heappush(heap_list, 5)
  assert heap_list == [5]

  heapq.heappush(heap_list, 1)
  assert heap_list == [1, 5]

  # Get
  heap_list[0]

  # Delete
  heapq.heappop(heap_list)

  # List를 힙으로 만들 떄
  tmp_list = [5, 4, 6, 1, 0, 10]
  heapq.heapify(tmp_list)
  assert tmp_list == [0, 1, 6, 5, 4, 10]
  ```

## 파이썬 리스트를 이용해 직접 구현

- 힙을 직접 구현할 때는 리스트를 사용함
  - 완전 이진 트리의 성질을 가지도록 하기 위해 부모 노드와 자식 노드의 관계를 정의해야함
    ```
    root node: 1
    parent node: n
    left child node: 2*n
    right child node: 2*n + 1
    ```
- heapify
  ```python
    class MinHeap:
        def __init__(self, heapSize):

            self.heapSize = heapSize

            self.minheap = [0] * (heapSize + 1)

            self.realSize = 0


        def add(self, element):
            self.realSize += 1
            if self.realSize > self.heapSize:
                print("Added too many elements!")
                self.realSize -= 1
                return
            self.minheap[self.realSize] = element
            index = self.realSize

            parent = index // 2

            while (self.minheap[index] < self.minheap[parent] and index > 1):
                self.minheap[parent], self.minheap[index] = self.minheap[index], self.minheap[parent]
                index = parent
                parent = index // 2
        

        def peek(self):
            return self.minheap[1]
        

        def pop(self):

            if self.realSize < 1:
                print("Don't have any element!")
                return sys.maxsize
            else:

                removeElement = self.minheap[1]

                self.minheap[1] = self.minheap[self.realSize]
                self.realSize -= 1
                index = 1

                while (index <= self.realSize // 2):

                    left = index * 2

                    right = (index * 2) + 1

                    if (self.minheap[index] > self.minheap[left] or self.minheap[index] > self.minheap[right]):
                        if self.minheap[left] < self.minheap[right]:
                            self.minheap[left], self.minheap[index] = self.minheap[index], self.minheap[left]
                            index = left
                        else:
                            self.minheap[right], self.minheap[index] = self.minheap[index], self.minheap[right]
                            index = right
                    else:
                        break
                return removeElement
        
        # return the number of elements in the Heap
        def size(self):
            return self.realSize
        
        def __str__(self):
            return str(self.minheap[1 : self.realSize + 1])
            

    if __name__ == "__main__":
            # Test cases
            minHeap = MinHeap(5)
            minHeap.add(3)
            minHeap.add(1)
            minHeap.add(2)
            # [1,3,2]
            print(minHeap)
            # 1
            print(minHeap.peek())
            # 1
            print(minHeap.pop())
            # 2
            print(minHeap.pop())
            # 3
            print(minHeap.pop())
            minHeap.add(4)
            minHeap.add(5)
            # [4,5]
            print(minHeap)
  ```

# Heap 활용

- 힙 정렬

- Top-K 문제

- K-th 요소