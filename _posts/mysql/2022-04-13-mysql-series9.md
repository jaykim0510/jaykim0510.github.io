---
layout: post
title:  'MySQL Series [Part9] 인덱스'
description: 
date:   2022-04-13 15:01:35 +0300
image:  '/images/mysql_logo.webp'
logo_image: '/images/mysql_logo.webp'
categories: DE
tags: MySQL
---

---
**Table of Contents**
{: #toc }
*  TOC
{:toc}

---  

**인덱스는 데이터베이스 쿼리의 성능과 관련**해서 빼놓을 수 없는 중요한 부분입니다. 인덱스에 대한 지식은 개발자나 관리자 모두에게 중요한 부분이며, 쿼리 튜닝의 기본이 됩니다.  

# 디스크 읽기 방식
보통 컴퓨터에서 가장 큰 성능 저하는 디스크 I/O에서 발생합니다. 따라서 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O을 줄이느냐가 관건일 때가 상당히 많습니다.  

## HDD와 SSD
데이터베이스 서버에서 순차 I/O 작업보다는 랜덤 I/O이 차지하는 비중이 훨씬 큽니다. 그리고 이러한 랜덤 I/O의 속도를 훨씬 높여준 장치가 바로 SSD입니다. 이러한 이유로 DBMS용 스토리지에 SSD는 최적의 장치라고 할 수 있습니다.  

## 랜덤 I/O와 순차 I/O
랜덤 I/O은 데이터의 개수만큼 데이터의 위치를 찾아야 하고, 순차 I/O은 한 번만 데이터의 위치를 찾으면 되기 때문에 랜덤 I/O으로 인한 작업 부하가 훨씬 더 크게 발생합니다. HDD는 매번 데이터의 위치를 찾기 위해 디스크 헤드를 움직여야 하기 때문에 랜덤 I/O의 작업 부하는 훨씬 더 커지게 됩니다. SSD는 디스크 원판이 아닌 플래시 메모리를 사용하기 때문에 차이가 없을 것 같지만 마찬가지로 랜덤 I/O에서 성능이 저하됩니다.  

그래서 일반적으로 **쿼리를 튜닝의 목적은 랜덤 I/O의 회수를 줄이는 것**입니다. 여기서 랜덤 I/O을 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미합니다. 그리고 **랜덤 I/O을 줄이기 위해 저희는 인덱스라는 것을 활용할 것**입니다.  

```
DBMS에서는 랜덤 I/O이 자주 발생하고, 쿼리의 성능을 높이기 위해서는 랜덤 I/O을 줄여야 한다.  
그리고 이렇게 랜덤 I/O을 줄이기 위해 인덱스를 사용한다.
```

# 인덱스란?
보통 인덱스를 설명할 때 **책 맨 끝에 있는 색인**을 예시로 많이 사용합니다. 예를 들어 책에서 '무궁화'라는 단어를 찾고 싶다면 저희는 책 페이지에서 내용을 하나씩 찾아보기 보다는 색인에서 '무궁화'라는 단어가 포함된 페이지의 쪽수를 찾게 될 겁니다.  

DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 레코드(Row)를 가져오려면 시간이 오래 걸릴 것입니다. 그래서 **컬럼의 값과 그 값을 가지는 레코드가 저장된 주소를 매핑한 인덱스**를 만들어 두는 것입니다.  

```
책의 색인: 단어 - 책 페이지 매핑
DBMS의 인덱스: 컬럼 값 - 값을 가지는 레코드(Row)의 주소 매핑
```

그리고 인덱스의 중요한 특성 중 하나는 키(컬럼 값)가 정렬되어 있다는 것입니다. 예를 들어 테이블의 사람 이름을 나타내는 name이라는 컬럼으로 인덱스를 만들었다고 했을 때, name 값을 정렬하여 각각의 주소를 매핑해 인덱스를 만들게 됩니다.  

아래는 인덱스 페이지의 예시로 다음과 같이 name이 알파벳 순으로 정렬되어 있습니다.  

|**name**|**레코드 주소**|
|Alice|14345342|
|Bob|61345549|
|Carl|24641345|
|Doson|41127651|

이렇게 인덱스 페이지를 정렬했을 때 장단점이 있습니다.  

- 장점: 정렬되어 있기 때문에 인덱스(컬럼 값)를 빠르게 찾고 결과적으로 데이터를 **빠르게 읽어온다**  
- 단점: 컬럼 값에 INSERT, UPDATE, DELETE가 발생할 때마다 인덱스 파일 정렬하기 때문에 **저장 속도가 느리다**  

결론적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 데이터의 읽기 속도를 높여주게 됩니다. 그래서 인덱스 파일을 하나 더 추가할지 말지는 데이터의 저장 속도를 얼마만큼 희생하여, 그 결과로 읽기 성능을 얼마나 더 빠르게 만들지에 따라 결정되게 됩니다.  

위에서 인덱스 페이지가 정렬되어 있어 인덱스 값을 빨리 찾을 수 있다고 했습니다. 정렬되어 있다는 것의 이점은 탐색 알고리즘에서 선형 탐색이 아닌 이진 탐색과 비슷하지만 이보다 더 빠른 탐색 알고리즘을 사용할 수 있다는 것입니다.  

인덱스 파일은 이진 탐색을 지원하는 이진 트리 자료 구조와 비슷하지만 더 빠른 탐색을 가능하게 하는 **Balanced Tree(B-Tree)**라는 자료구조로 구현되어 있습니다.  

이외에도 대표적으로 Hash Table 자료구조를 이용한 방법도 있으며 최근에는 Fractal-Tree, Merge-Tree와 같은 알고리즘을 사용하는 DBMS도 개발되고 있습니다.  

**B-Tree 인덱스**  
- 가장 일반적으로 사용되는 인덱스 형태
- 컬럼 값을 변형하지 않고 원래의 값을 이용해 인덱싱
- B-Tree을 응용한 많은 자료구조가 등장

**Hash Table 인덱스**  
- 컬럼 값을 해시한 결과를 인덱스로 사용
- 매우 빠른 검색 지원
- 해시값을 인덱스로 사용해 컬럼 값의 일부만 검색하거나 범위를 검색할 때는 사용 불가
- 주로 메모리 기반의 데이터베이스에서 많이 사용

# B-Tree 인덱스

## MyISAM 스토리지 엔진의 B-Tree 인덱스 구조 및 특성

## InnoDB 스토리지 엔진의 B-Tree 인덱스 구조 및 특성

## 데이터의 Insert, Update, Delete시 인덱스에서의 동작

## B-Tree 인덱스 사용에 영향을 미치는 요소

## 데이터의 Select시 인덱스에서의 동작

### 인덱스 레인지 스캔

### 인덱스 풀 스캔

### 테이블 풀 스캔

### 루스 인덱스 스캔

### 인덱스 스킵 스캔

# 멀티 컬럼 인덱스

# 참고

