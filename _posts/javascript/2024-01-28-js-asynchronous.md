---
layout: post
title:  '[Javascript]: 비동기 프로그래밍'
description: 이웅모님의 모던 자바스크립트 Deep Dive 책을 읽고 정리한 내용이다
date:   2024-01-28 15:01:35 +0300
image:  '/images/js_logo.png'
logo_image: '/images/js_logo.png'
category: language
tag: javascript
---

---
**Table of Contents**
{: #toc }
*  TOC
{:toc}

---

# 비동기 함수

- 함수의 실행 순서는 실행 컨텍스트 스택(콜 스택)으로 관리한다
- 자바스크립트 엔진은 하나의 실행 컨텍스트 스택만을 갖는다
- 이는 함수를 실행할 수 있는 창구가 단 하나이며, 동시에 2개 이상의 함수를 동시에 실행할 수 없다는 것을 의미한다
- 이처럼 자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 싱글 스레드 방식으로 동작한다
- 싱글 스레드 방식은 한 번에 하나의 태스크만 실행할 수 있기 때문에 처리에 시간이 걸리는 태스크를 실행할 경우 블로킹이 발생한다
- 이처럼 현재 실행 중인 태스크가 종료할 때까지 다음 실행될 태스크가 대기하는 방식을 동기(synchronous) 처리라고 한다
- 동기 처리 방식은 실행 순서가 보장된다는 장점이 있지만, 앞선 태스크가 종료될 때까지 이후 태스크들이 블로킹되는 단점이 있다
- 반면에 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기(asynchronous) 처리라고 한다
- 비동기 처리를 수행하는 비동기 함수는 전통적으로 콜백 패턴을 사용한다. 하지만 콜백 패턴은 콜백 헬을 발생시켜 가독성을 나쁘게 하고, 비동기 처리 중 발생한 에러의 예외 처리가 곤란하며, 여러 개의 비동기 처리를 한 번에 처리하는 데도 한계가 있다
- setTimeout, setInterval, HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작한다
- 자바스크립트는 이벤트 루프를 통해 동시성을 지원한다
- 비동기 함수의 콜백 함수 또는 이벤트 핸들러는 태스크 큐에 일시적으로 보관된다
- 이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인한다
- 만약 콜 스택이 비어있고, 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다
- 이때 콜 스택으로 이동한 함수는 실행된다. 즉, 태스크 큐에 일시 보관된 함수들은 비동기 처리 방식으로 동작한다

- 자바스크립트 엔진은 싱글 스레드로 동작하지만, 브라우저는 멀티 스레드로 동작한다
- 브라우저에 있는 태스크 큐와 이벤트 루프가 비동기 처리를 돕는 것이다


# 프로미스

- ES6에서 비동기 처리를 위한 또 다른 패턴으로 프로미스(Promise)를 도입했다
- 프로미스는 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다
- 비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않았다 해도 기다리지 않고 즉시 종료된다
- 즉, 비동기 함수 내부의 비동기로 동작하는 코드는 비동기 함수가 종료된 후, 나중에 완료된다
- 따라서 비동기 함수 내부의 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작하지 않는다
- 예를 들어, 비동기 함수인 `setTimeout` 함수의 콜백 함수는 `setTimeout` 함수가 종료된 이후에 호출된다
- 비동기 함수는 비동기 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에 할당할 수도 없다
- 따라서 비동기 함수의 처리 결과(ex. 서버의 응답)에 대한 후속 처리는 비동기 함수 내부에서 수행해야 한다
- 이때 비동기 처리 결과에 대한 후속 처리를 수행하는 콜백 함수를 전달하는 것이 일반적이다
- 하지만 콜백 함수는 콜백 헬 문제와 에러 처리를 못한다는 문제가 있다
- 이를 극복하기 위해 ES6에서 프로미스가 도입되었다

## 프로미스의 생성

- Promise 생성자 함수는 비동기 처리를 수행할 콜백 함수를 인수로 전달 받는데 이 콜백 함수는 `resolve`와 `reject` 함수를 인수로 전달받는다
- 비동기 처리는 Promise 생성자 함수가 인수로 전달받는 콜백 함수 내부에서 수행한다. 만약 비동기 처리가 성공하면 비동기 처리 결과를 `resolve` 함수에 인수로 전달하면서 호출하고, 실패하면 에러를 `reject` 함수에 인수로 전달하면서 호출한다

|**프로미스의 상태 정보**|**의미**|**상태 변경 조건**|
|`pending`|비동기 처리가 아직 수행되지 않은 상태|프로미스가 생성된 직후 기본 상태|
|`fulfilled`|비동기 처리가 수행된 상태 (성공)|resolve 함수 호출|
|`rejected`|비동기 처리가 수행된 상태 (실패)|reject 함수 호출|

- 생성된 직후의 프로미스는 기본적으로 `pending` 상태다
- 이후 비동기 처리가 수행되면 처리 결과에 따라 다음과 같이 프로미스의 상태가 변경된다
  - 성공: `resolve` 함수를 호출해 프로미스를 `fulfilled` 상태로 변경한다
  - 실패: `reject` 함수를 호출해 프로미스를 `rejected` 상태로 변경한다
- 이처럼 프로미스의 상태는 `resolve` 또는 `reject` 함수를 호출하는 것으로 결정된다
- 프로미스는 `pending` 상태에서 `fulfilled` 또는 `rejected` 상태가 되면 더는 다른 상태로 변화할 수 없다
- 프로미스는 비동기 처리 상태와 더불어 비동기 처리 결과도 갖는다
- 성공하면, resolve() 함수의 첫 번째 인자로 넘겨준 값을 처리 결과 값으로 한다
- 실패하면, reject() 함수의 첫 번째 인자로 넘겨준 에러 객체를 결과 값으로 한다
- 즉, 프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체다

## 프로미스의 후속 처리 메서드

### Promise.prototype.then

### Promise.prototype.catch

### Promise.prototype.finally

## 프로미스의 에러 처리

## 프로미스 체이닝

## fetch

# async/await

## async

## await

## 에러 처리