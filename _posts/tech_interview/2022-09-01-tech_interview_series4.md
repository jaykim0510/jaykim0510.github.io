---
layout: post
title:  'Tech Interview Series [Part4]: Network'
description: 
date:   2022-09-01 15:01:35 +0300
image:  '/images/tech_interview_logo.png'
logo_image:  '/images/tech_interview_logo.png'
categories: computer_science
tags: tech_interview
---
---

**Table of Contents**
{: #toc }
*  TOC
{:toc}

---

# TCP/IP 4계층

- 인터넷에서 컴퓨터들이 서로 정보를 주고 받는데 쓰이는 프로토콜의 모음을 프로토콜의 네트워킹 범위에 따라 4개로 계층화한 것
- 각 계층은 하위 계층의 기능만을 이용하고, 상위 계층에게 기능을 제공
- 일반적으로 하위 계층들은 하드웨어로, 상위 계층들은 소프트웨어로 구현

![](/images/tcp_ip.png)

## 응용 계층 (L7)

- 웹 브라우저와 같은 사용자들이 사용하는 응용 프로그램에서 사용되는 계층
- 일반적인 응용 서비스는 관련된 응용 프로세스들 사이의 전환을 제공한다.
- 대표적인 프로토콜: FTP, HTTP, SSH, SMTP, DNS

## 전송 계층 (L4)

- 전송 계층은 송신자와 수신자를 서로 연결(connection)하는 계층
- 양 끝단(End to end)의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해준다
- 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다
- 데이터 전송 단위는 Segment(TCP), Datagram(UDP)
- 대표적인 프로토콜: TCP, UDP

## 인터넷 계층 (L3)

- IP주소를 이용해 목적지로 전송하기 위해 사용되는 계층
- 네트워크 계층은 라우팅, 흐름 제어 등을 수행
- 상대방이 데이터를 제대로 수신했는지에 대해 보장하지 않는 비연결형적인 특징을 가짐
- 데이터 전송 단위는 Packet (또는 Datagram)
- 대표적인 프토로콜: IP, ARP

# HTTP

- 응용 프로그램은 수도 없이 다양. 응용 계층간의 통신할 수 있는 규약이 필요. 그중 대표적인 것이 HTTP
- 요즘에는 모든 데이터를 HTTP 메세지에 담아서 전송
- 응용 계층에서 데이터를 요청/응답 하는 규약

## HTTP의 특징

- 클라이언트/서버 구조: request를 보내면 response 돌려주는 단방향 통신
- 무상태 프로토콜: 서버가 클라이언트의 상태를 보존하지 않음
- 비연결성: connect (3-way handshake) -> request -> response -> disconnect (4-way handshake)
- (HTTP/2, HTTP/3 오면서 Persistent connection을 사용)

## URL과 HTTP 메서드

- request를 보내기 위해서는 요청하는 자원의 식별자 URL과 요청 방식인 HTTP 메서드를 이용해야 한다
- GET
  - 정보를 조회하기 위한 메서드. 서버에서 정보를 가져오는 것이 목적
  - URL에 요청 정보를 붙여서 전송 -> POST보다 빠르다, POST 방식보다 보안에 취약하다
- POST
  - 서버의 값을 바꾸기 위한 메서드 -> Not Idempotent
  - 요청정보를 HTTP 메세지 바디에 숨겨서 전송 -> 클라이언트가 인코딩, 서버에서 디코딩 -> GET보다 보안상 안전
- 위의 정보는 HTTP 메세지의 시작 라인에 적는다 (ex. GET /search?q=hello HTTP1.1)

## HTTP 헤더

- 이제 HTTP 메세지를 전송한다. 그전에 여러 부가 기능과 규약을 위해 HTTP 헤더를 잘 작성해야 한다
- HTTP 헤더 종류에는 크게 표현 헤더, 요청 헤더, 응답 헤더가 있다
- 표현 헤더 (요청/응답 공통 항목)
  - Content-Type: 표현 데이터의 형식 (GET 메서드는 안씀) (ex. text/html, application/json, image/png)
  - Content-Encoding: 표현 데이터의 압축방식
  - Content-Language, Content-Length
  - Last-Modified: 리소스를 마지막으로 갱신한 일시
  - Location: 페이지 리다이렉션 (리다이렉트된 새로운 주소)
- 요청 헤더
  - Host: 호스트명 + 포트 번호
  - User-Agent: 클라이언트의 정보 (어떤 운영체제, 브라우저 등)
  - Referer: 내가 페이지를 요청한 URL (유입경로)
  - Authorization: 클라이언트 인증 정보
  - Cookie: 쿠키에서 사용할 데이터
  - If-Modified-Since: 캐시 데이터의 유효성을 검사하기 위한 목적
  - If-None-Match: 캐시 데이터를 쓸지 서버에서 데이터를 가져올지
- 응답 헤더
  - Server: 캐시, 프록시 아닌 Origin 서버의 정보
  - Set-Cookie: 쿠키에 저장할 데이터 (max-age, expires로 쿠키 생명주기 설정)
  - Age: 캐시가 생성되고 시간이 얼마나 지났는지
  - ETag: 리소스의 고유한 태그 -> 캐시 데이터의 유효성을 검사할 수 있음

# TCP

- 전송 계층은 송신자와 수신자를 서로 연결(connection)하는 계층
- 양 끝단(End to end)의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해준다
- 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다

## TCP

- 연결지향 프로토콜 (논리적 연결)
- 가상 회선 패킷 교환 방식 -> 경로가 이미 정해져 있음 -> 순서 보장
- 패킷에 시퀀스 번호가 있음 -> 순서 보장
- 전이중(Full-Duplex), 점대점(Point to Point) 방식
- 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다
- UDP보다 속도가 느리다
- 연속성보다 신뢰성있는 전송이 중요할 때에 사용된다

## UDP

- 비연결형 프로토콜
- 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독립적인 관계를 지니게 된다
- 연결여부, 순서여부, 손실여부 확인 안함. 오직 데이터 손상 여부만 CheckSum 필드를 통해 검출
- 신뢰성은 낮지만 속도가 빠르다
- 실시간 서비스(streaming)에 사용

![](/images/network_31.png)

# IP

- IP주소를 이용해 목적지로 전송하기 위해 사용되는 계층
- 네트워크 계층은 라우팅, 흐름 제어 등을 수행
- 상대방이 데이터를 제대로 수신했는지에 대해 보장하지 않는 비연결형적인 특징을 가짐

## IP 주소

- IP 주소 중 네트워크 부분: 하나의 브로드캐스트 영역
  - 라우터를 거치지 않고 통신이 가능한 영역
  - 라우터가 라우팅할 때 참고하는 부분
  - 라우터는 다른 네트워크로 갈 때만 필요
- IP 주소 중 호스트 부분: 각각의 PC 또는 장비
- IP 주소의 Class에 따라 어디까지가 네트워크 부분이고, 어디까지가 호스트 부분인지가 나뉨 (네트워크의 크기가 달라짐)
  - 클래스 A는 이진수 중에서 맨 앞쪽 숫자가 항상 0으로 시작되는 것들
    - 호스트 수가 가장 많은 클래스
    - 앞의 8비트가 네트워크 부분, 나머지 24비트가 호스트 부분
    - `1.0.0.0` ~ `126.0.0.0` 까지로 규정 (0 시작과 127 시작은 제외) -> 126개의 네트워크, 각각의 네트워크는 라우터 없이 통신
    - 호스트는 2의 24승 - 2개(모두 0인 경우, 모두 1인 경우) = 16,777,214개 -> 16,777,214개의 호스트가 하나의 네트워크에 연결
  - 클래스 B는 맨 앞이 10으로 시작
    - 앞의 16비트가 네트워크 부분
    - `128.0.0.0` ~ `191.255.0.0` 까지로 규정
  - 클래스 C는 맨 앞이 110으로 시작
    - 앞의 24비트가 네트워크 부분
    - `192.0.0.0` ~ `223.255.255.0` 까지로 규정

- 기본 게이트웨이(Default Gateway)
  - 내부 네트워크에서는 라우터 없이도 통신이 가능
  - 내부 네트워크에 없는 IP 주소로 갈 때는 이 기본 게이트웨이를 통해 나감
  - 즉 라우터의 이더넷 인터페이스를 의미
- 라우터는 인터페이스별로 IP 주소 부여. 스위치나 허브는 장비별로 IP 주소 부여
  
## 서브넷 마스크(Subnet Mask)

- 주어진 네트워크를 가공할 때 사용
- 우리가 일단 어떤 IP 주소를 배정받게 되면 보통 이 주소를 그대로 사용하지 않고 서브넷 마스크를 조합하여 사용
- 우리가 부여받은 net을 여러개의 subnet으로 나눈다는 의미
- 서브넷마스크를 통해 나누어진 서브넷간의 통신은 라우터를 거쳐야함
- 모든 IP 주소에는 서브넷 마스크가 따라다님. 쓰지 않더라도. 그래야 지금 IP 주소가 마스킹 된건지 아닌지 알 수 있음
- 클래스 A의 기본 서브넷 마스크는 `255.0.0.0`, B는 `255.255.0.0`, C는 `255.255.255.0`
- 서브넷 마스크는 IP주소의 어디까지가 네트워크 부분이고, 어디까지가 호스트 부분인지를 나타내는 역할을 함
- 서브넷 마스크의 이진수 1은 네트워크 부분, 이진수 0은 호스트 부분을 의미함
- 즉, 서브넷 마스킹은 기존 IP 주소의 호스트 부분의 일부를 네트워크 부분으로 바꾸는 작업

```
기존 네트워크: 150.150.100.1 => 1001 0110 1001 0110 0110 0100 0000 0001 => 클래스 B => 150.150.0.0이 네트워크를 의미
서브넷 마스크: 255.255.255.0 => 1111 1111 1111 1111 1111 1111 0000 0000 => 네트워크 자리가 16자리에서 24자리 까지로 늘림 (호스트를 8자리로 줄임)
------------------------------------------------------------------------------------------------------------------------------
서브넷: 150.150.100.0 => 1001 01110 1001 01110 01110 0100 0000 0000 => 최종적으로 서브넷 네트워크가 150.150.100.0가 됨
```

- 참고로 호스트 부분이 0인 주소는 호스트 주로로 사용하지 못함. PC에서 사용하는 주소가 아니라 네트워크 자체를 의미
- 또 호스트 부분이 255인 주소 역시 호스트 주소로 사용할 수 없음. 브로드캐스트 주소 (모든 호스트에게 메시지 보낼 때 사용하는 주소)

# 네트워크 장비

- 허브
  - 멀티포트 리피터
  - 특정 포트에서 들어온 데이터를 나머지 포트로 데이터를 뿌려주는 역할
  - 같은 콜리전 도메인
  - 100대가 허브에 연결되어 있다면 1대의 컴퓨터가 통신하는 동안 나머지 99대의 컴퓨터들은 모두 대기
- 스위치
  - 콜리전 도메인 분할
  - 서로 다른 콜리전 도메인에서는 독립적으로 통신 가능
  - 하나의 컴퓨터가 브로드 캐스팅한다면, 이 때는 모든 콜리전 도메인에서 통신 불가
  - 만약 세상의 모든 네트워크가 스위치로 이루어져 있다면, 한 명이 브로드 캐스팅 하는 순간 모든 다른 통신이 불가능해짐
- 라우터
  - 브로드캐스팅은 하나의 네트워크내에서 이루어짐 -> LAN = 하나의 브로드캐스트 도메인
  - 라우터는 네트워크를 분할해줌
  - 네트워크는 라우터로 분할, 네트워크 내에서 콜리전 도메인은 스위치로 분할, 콜리전 도메인은 허브로 구성

# 응용편

## 쿠키와 세션
- 쿠키
  - HTTP는 무상태 프로토콜
  - 매 요청마다 필요한 정보를 누적 전송해야 한다면 비효율적
  - 사용자의 선택에 따라 데이터를 브라우저에 저장 (클라이언트 로컬)
  - (ex. 비밀번호를 저장하시겠습니까?, 오늘 하루 보지 않기, 특정 버튼 클릭 횟수, 접속 횟수 등)
  - 쿠키는 딱히 유효성 검사 x -> 그냥 Set-Cookie 에서 설정한 쿠키 생명 주기 동안 살아있으면 사용
- 캐시
  - 프록시 서버
  - 웹 페이지의 HTML, CSS, 이미지 파일 등을 저장 -> 빠른 렌더링
  - 캐시는 유효성 검사를 한다
  - Last-Modified & If-Modified-Since 조합: 데이터가 A -> B -> A 로의 변환도 modified로 간주 -> 한계
  - Etag & If-None-Match 조합
  - 유효하면 캐시 데이터, 아니면 Origin 서버
- 세션
  - 쿠키와 비슷
  - 다만 데이터를 서버에 저장
  - 클라이언트 쿠키에는 세션 ID 저장 (브라우저 닫기 전까지 유효)
  - 세션 ID 포함해서 요청

## DNS
## REST
## 소켓
## 로드 밸런싱

# 용어

## NAT
## 라우터
## 게이트웨이
## DHCP
## IPC, RPC, gRPC

# 참고
- [JaeYeopHan/Interview_Question_for_Beginner](https://github.com/JaeYeopHan/Interview_Question_for_Beginner){:target="_blank"}
- [WeareSoft/tech-interview](https://github.com/WeareSoft/tech-interview){:target="_blank"}
- [gyoogle, Tech Interview 준비](https://gyoogle.dev/blog/guide/%EB%A9%B4%EC%A0%91%20%EC%A4%80%EB%B9%84.html){:target="_blank"}
- [배진오, 신입 개발자 기술면접 준비하기](https://blex.me/@baealex/%EC%B7%A8%EC%A4%80%EC%83%9D%EC%9D%B4-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84){:target="_blank"}
- [[PYTHON] Python 면접 예제 2편](https://dingrr.com/blog/post/python-python-%EB%A9%B4%EC%A0%91-%EC%98%88%EC%A0%9C-2%ED%8E%B8){:target="_blank"}
- [exp_blog, 데이터베이스 직무 면접 질문](https://syujisu.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%A7%81%EB%AC%B4-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8?category=871132){:target="_blank"}
- [망나니 개발자 CS 준비](https://mangkyu.tistory.com/88){:target="_blank"}
