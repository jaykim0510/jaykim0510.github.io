---
layout: post
title: 'Flink Series [Part2]: 스트림 처리의 핵심(1) 시간'
description: 
date: 2022-02-04 15:01:35 +0300
logo_image: '/images/flink_logo.png'
image: '/images/flink_logo.png'
categories: data_engineering
tags: Flink
---
---

**Table of Contents**
{: #toc }
*  TOC
{:toc}

---

이 문서는 스트림 처리에 관한 애니메이션을 포함하고 있습니다. 애니메이션이 모바일에서는 제대로 재생되지 않는 문제가 있기 때문에 애니메이션이 궁금하시다면 컴퓨터를 이용한 접속을 권장드리며 또는 아래의 참고 문서를 확인하시면 되겠습니다.  

- [Streaming Systems 시각 자료 참고](http://streamingbook.net/fig){:target="_blank"}

# 시간의 중요성  

스트림 처리에서 핵심적인 개념은 **'시간'**과 **'상태 관리'**입니다. 이번 포스트에서는 그 중 첫 번째인 **'시간'**에 대해 알아보도록 하겠습니다. 네트워크와 통신 채널 같은 현실 세계 시스템은 완벽하지 않기 때문에 데이터는 지연되거나 그로 인해 순서가 바뀌어 도착할 수도 있습니다. 이런 상황에서 스트림 처리가 정확하고 일관된 결과를 생성하는 것은 매우 중요한 문제입니다.  

# 처리 시간과 이벤트 시간

![](/images/flink_8.png)

- **이벤트 시간**: 이벤트가 발생한 시간
- **처리 시간**: 이벤트가 스트림 처리 연산을 실행 중인 장비에서 처리된 시간  

만약 이벤트가 발생한 즉시 처리 될 수 있다면 두 시간을 굳이 구분할 필요가 없을 것입니다. 하지만 이러한 두 가지 시간은 일치하지 않을 뿐 아니라, 두 시간의 차이 또한 일정하지 않습니다. 현실 상황에서 일어날 수 있는 예시를 통해 각각의 방법으로 시간을 정의했을 때 어떤 차이가 생기는지 알아보겠습니다.  

베를린에 살고 있는 앨리스는 출근마다 지하철 안에서 모바일 게임을 합니다. 게임에서는 500개의 풍선을 1분 안에 터트리면 보상을 받는 식입니다. 그런데 베를린 지하철의 네트워크는 자주 끊긴다는 문제가 있습니다. 앨리스가 게임을 하게 되면 발생된 이벤트를 스트림 처리 어플리케이션으로 보내진다고 할 때, 만약 게임 도중 네트워크가 끊기면 어떻게 될까요?

![](/images/flink_7.png)

위의 그림을 보면, 앨리스의 핸드폰에서는 1분 동안 총 6개의 데이터가 발생했습니다. 하지만 뒤에 2개의 데이터는 지하철이 터널을 지나고 있던 시점이라 아직 스트림 처리 어플리케이션으로 전송이 지연되었습니다. 이러한 상황에서 처리 시간을 기준으로 데이터를 처리한다면 4개의 데이터만을 고려해 결과를 낼 것입니다.  

하지만 이벤트 시간은 이벤트 내용 안에 포함된 타임스탬프를 기반으로 하기 때문에, 지연되어 도착한 2개의 데이터도 1분 안에 보내진 데이터로 간주됩니다. 그렇기 때문에 스트림 분석 어플리케이션은 지연된 2개의 데이터를 기다릴 것이고 모두 도착한 이후 결과를 계산할 겁니다. 따라서 이벤트 시간은 이벤트의 일부가 **지연되더라도 발생했던 일을 제대로 반영**할 수 있습니다.  

위의 예를 통해 알 수 있듯이, 이벤트 시간을 기반으로 하는 연산들은 예측할 수 있고 결과는 항상 결정적(deterministic)입니다. 지연된 이벤트의 처리 뿐만 아니라 **데이터의 순서가 바뀌는 문제 또한 이벤트 시간을 사용함으로써 결과의 정확성을 보장**할 수 있습니다.  

만약 시간이나 순서가 중요한 데이터가 아니라면 처리 시간을 기준으로 연산을 해도 됩니다. 하지만 시간에 따른 사용자 행동 분석, 결제 관련 서비스, 이상 탐지 등 대부분의 스트림 처리 어플리케이션은 지연 고려, 순서와 같은 요소들이 중요하기 때문에 이벤트 시간을 기준으로 연산을 제공할 수 있어야 합니다.  

이벤트 시간을 기준으로 사용하기 위해서는 **워터마크**라는 추가적인 설정을 해주어야 합니다.  

# Timely Stream Processing

실시간 스트림 처리가 어려운 이유 중 하나는 **데이터가 Unbounded(무한) Unordered(비정렬)** 할 수 있다는 점입니다. **Unordered한 특성은 이벤트 시간을 기준으로 타임스탬프를 적용해 해결**할 수 있습니다. 그러면 Unbounded는 어떻게 해결할 수 있을까요? **Unbounded한 특성은 윈도우를 이용해 해결**할 수 있습니다. 

아래 애니메이션은 Bounded(유한)한 데이터인 경우입니다. 이 경우에는 일정 시간이 지난 후에는 데이터가 더 들어오지 않기 때문에 데이터가 들어온 시간 범위 내에서 전체 데이터를 배치로 처리할 수 있습니다.  

![](/images/flink_9.mov)

하지만 Unbounded한 경우에는 데이터가 끝이 없습니다. 일정 시간이 지난 후에 데이터가 들어올지 안들어올지 모르는 상황이기 때문에, 이러한 경우에는 윈도우를 사용해 데이터를 처리해야 합니다.  

![](/images/flink_10.mov)  

여기까지 오면 이제 실시간 스트림 처리에 조금 더 자신감이 생긴 것 같습니다. 이벤트 시간을 기준으로 타임스탬프를 정의하고, 윈도우를 사용해 무한한 데이터를 유한한 데이터로 나누어 봄으로써 Unbounded Unordered한 데이터가 발생하더라도 스트림 처리가 가능해졌습니다.  

하지만 한가지 문제점이 남아있습니다. 현실 시스템에서 데이터 지연은 필연적으로 발생하게 되는데, 각 윈도우들에서 지연된 데이터를 포함한 모든 데이터를 받았다는 사실을 어떻게 알며 언제쯤 윈도우에서 결과를 출력할 수 있을까요? 여기서 등장하는 중요한 개념이 바로 **'트리거'**와 **'워터마크'**입니다.  

## 트리거

- 윈도우가 출력되는 시점을 선언하는 방법
- 결과가 생성되는 시기 제어
- 윈도우별로 생성되는 각 출력을 윈도우의 패널이라고 함

### 반복 업데이트 트리거

- 주기적으로 결과를 출력 (새로운 데이터를 만날 때마다, 1분 마다 등)
- 간단하고 쉽게 구현
- 언제 결과의 정확성이 신뢰할만한 수준에 다다랐는지 모른다는 한계점


![](/images/flink_11.mov)   
**(데이터 만날 때마다 결과를 출력하는 반복 업데이트 트리거)**  


### 완료 트리거

- 윈도우 내 입력이 일정 기준 완료됐다고 믿는 시점에 결과를 출력
- 워터마크가 각 윈도우의 입력 완료 시점을 나타냄
- 각 윈도우의 입력이 완료되었다고 판단하는 순간 워터마크가 윈도우의 끝으로 이동하고 패널 출력
- 지연된 데이터 고려해 시점을 결정
- 패널이 업데이트 되지 않음

![](/images/flink_12.mov)  
**(지연된 데이터를 알고있는 '완벽한 워터마크'와 지연된 데이터의 유무를 모르는 현실적인 '휴리스틱 워터마크')**  

노란색 숫자는 윈도우의 출력인 패널의 값을 나타냅니다. **트리거 설정이 중요한 이유**는 어떻게 설정하는가에 따라 **정확성과 지연 시간간의 트레이드-오프**가 생긴다는 점입니다. 이 부분에 대해서는 뒤에서 다시 자세히 얘기하도록 하겠습니다. 

**완료 트리거가 윈도우 내 입력이 일정 기준 완료되었다고 판단하는 기준이 워터마크**입니다. 그렇기 때문에 워터마크에 대해 조금 더 알아보고 완료 트리거에 관한 내용을 정리한 뒤, 트리거 설정에 따른 정확성과 지연 시간 사이의 트레이드-오프 얘기를 마무리 하겠습니다.  

## 워터마크

- 어떤 이벤트 시간을 기준으로 입력이 완료됐음을 표시하는 방법
- 완료 트리거에서의 핵심
- 종류별로 이상적인 워터마크, 완벽한 워터마크, 휴리스틱 워터마크가 있음
  - **이상적인 워터마크**: 이벤트 시간과 처리 시간이 같다고 가정(이벤트 발생과 동시에 처리), *비현실적*
  - **완벽한 워터마크**: 시스템이 지연되는 데이터 유무를 알 수 있는 경우, *비현실적*
  - **휴리스틱 워터마크**: CPU, 분산 시스템, 네트워크 상황을 통해 지연된 데이터를 예측, *현실적*

이제 다시 위 애니메이션을 보면 왼쪽 초록색 점선의 완벽한 워터마크는 지연 데이터 9를 알고 워터마크가 X축(이벤트 시간)으로 더 증가하지 않고 있습니다. 오른쪽 초록색 실선의 휴리스틱 워터마크는 지연 데이터 9를 놓쳐서 누락되었습니다.  

휴리스틱 워터마크에서 지연 데이터 9가 누락된 이유에는 2가지 가능성이 있습니다. 첫 번째는 알고 있었지만 지연 데이터 9를 기다렸다가 패널을 출력하기에는 지연율이 높아져서 데이터를 포기한 것일 수도 있고, 두 번째는 휴리스틱 워터마크의 불완전성으로 인해 놓친 경우일 수도 있습니다.  

첫 번째 이유를 보면 **휴리스틱 워터마크를 사용한 완료 트리거**가 **지연율을 낮추기 위해 정확성을 조금 포기**했습니다. 이를 통해 트리거에 지연율과 정확성의 트레이드-오프가 있음을 알 수 있습니다.  

이러한 트레이드-오프를 조절하는 것도 가능합니다. 이를 위해 조기/정시/지연 트리거들이 있습니다.  

**조기(early) 트리거**  

- 지연 데이터로 휴리스틱 워터마크가 찍히는 시점이 너무 늦어지는 경우에 사용하면 좋음
- 업데이트 트리거 - 완료 트리거 순으로 조합

**정시(on-time) 트리거**  

- 완료 트리거
- 정시 트리거는 항상 워터마크가 윈도우 끝에 도달한 순간에만 패널 출력

**지연(late) 트리거**  

- 휴리스틱 워터마크의 불완전성으로 계속 지연 데이터를 놓치는 경우에 사용하면 좋음
- 완료 트리거 - 업데이트 트리거 순으로 조합

![](/images/flink_14.mov)  

위 애니메이션에서 이벤트 시간 12:03 부분을 보게 되면 워터마크는 아직 12:03부분에 머물러있는데 3과 4 데이터를 가진 윈도우가 패널을 출력했습니다. 이렇게 워터마크 이전에 패널을 출력하는 경우가 조기 트리거를 사용한 경우입니다.  

![](/images/flink_14.png)  

### 워터마크 전파  

지금까지 위에서 워터마크의 용도에 대해 알아보았습니다. 워터마크가 윈도우내 입력 완료 시점을 알려주고 완료 트리거를 보조한다는 점에서 굉장히 유용하다는 것을 깨달았습니다. 여기서는 조금 더 **실제적인 측면**에 대해 보려고 합니다.  

- 워터마크는 **어디서** 만들어지는 것인가?
- 파이프라인 내 여러 컴포넌트들로 **어떻게 전파**되는가?



# 참고
- [Flink 공식문서: Timely Stream Processing](https://nightlies.apache.org/flink/flink-docs-master/docs/concepts/time/){:target="_blank"}
- [Flink and Kafka Streams: a Comparison and Guideline for Users](https://www.confluent.io/blog/apache-flink-apache-kafka-streams-comparison-guideline-users/){:target="_blank"}
- [Flink 공식문서: Windows](https://nightlies.apache.org/flink/flink-docs-master/docs/dev/datastream/operators/windows/){:target="_blank"}
- [Streaming Systems 시각 자료 참고](http://streamingbook.net/fig){:target="_blank"}


