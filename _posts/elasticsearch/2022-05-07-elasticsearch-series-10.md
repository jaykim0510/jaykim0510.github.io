---
layout: post
title:  'ElasticSearch Series [Part4]: ElasticSearch'
description: 
date:   2022-01-07 15:01:35 +0300
image:  '/images/elasticsearch_logo.png'
logo_image:  '/images/elastic_logo.png'
categories: DE
tags: Elastic
---
---

**Table of Contents**
{: #toc }
*  TOC
{:toc}

---  

# ELK 소개

- 엘라스틱서치가 처음 등장했을 때 누구도 빅데이터 파이프라인을 구성하는 플랫폼 형태로 성장하리라 예상하지 못했을 것이다
- 엘라스틱이 등장했을 무렵 사용자의 요구 사항은 너무나 명확했다. 빠른 전문 검색(Full text search) 기능
- 1999년 하둡으로 유명해진 더그 커팅은 자신의 부인의 이름을 딴 루씬(Lucene)라는 검색엔진 라이브러리를 만들었다
- 데이터와 관련한 작업의 중요성이 커짐에 따라 검색 엔진만 제공하는 서비스는 쉽게 주목받기 힘들었다
- 엘라스틱은 검색엔진을 뛰어넘는 하나의 플랫폼으로 성장하는 길을 택했다
- 데이터를 수집, 가공, 저장, 분석, 시각화하는 일련의 파이프라인을 제공해줄 수 있는 플랫폼을 만들기로 했다
- 그렇게 등장한 것이 Elasticsearch, Logstash, Kibana 그리고 Beats이다
- 초창기에는 스택간의 버전을 따로 관리해 버전간의 충돌이 잦았지만, 이제는 스택간의 버전을 모두 통일시켜서 이런 문제를 해결했다

## 엘라스틱서치

- 엘라스틱서치는 텍스트나 도큐먼트의 경우 인덱싱 시점에 분석을 거쳐 용어(term) 단위로 분해되고 역인덱스 사전을 구축한다.
- 엘락스틱서치의 중요한 특징 중 하나는 스코어링, 즉 연관도에 따른 정렬이다
- 분산 시스템으로서 엘라스틱서치는 복수의 루씬 인스턴스를 병렬로 배치하고 분산 처리해 검색 속도를 무한히 확장할 수 있게 한다
- 인덱스가 불변의 자료구조이기 때문에 도큐먼트를 수정하거나 삭제할 경우에 비용이 저렴하지 않다
- 하지만 이런 단점은 검색 성능을 끌어올리기 위한 트레이드 오프로 일반적으로 용인되는 제약이다
- 엘라스틱서치는 검색 엔진에 초점을 맞추고 설계되었기 때문에 다른 범용 DBMS와 비교해 더 많은 리소스를 사용

## 로그스태시

- 배치 처리와 병렬 처리가 가능하며, 영속적인 큐를 사용해 현재 처리중인 이벤트의 최소 1회 전송을 보장
- 데이터량이 급증하는 부하 상황에서도 안정성을 보장해준다

## 비츠

- 실제 서비스에 로그스태시와 같은 무거운 툴은 활용도가 떨어질 수 있다
- 비츠는 파일비트, 메트릭비트 등 비츠라고 부르는 경량 수집기가 포함되어 있다
- 각 비트는 로그 수집, 시스템 메트릭 수집 등 특정 목적에 최적화된 에이전트
- 가볍기로 유명한 고(Go) 언어로 작성

## ELK 용도

- 전문 검색 엔진
- 로그 통합 분석
- 애플리케이션 성능 분석


# 엘라스틱서치

- 인덱스와 도큐먼트
- 도큐먼트의 CRUD
- 매핑
- Query DSL

- 엘라스틱서치는 모든 요청과 응답을 REST API 형태로 제공한다
- 키바나 콘솔은 엘라스틱서치 API 자동완성, 문법 체크, 구문 검사 기능 제공
- 클러스터 내부는 데이터 성격에 따라 여러 개의 인덱스를 생성한다
- 인덱스 내부에는 JSON 형태로 된 다수의 도큐먼트가 존재하고,  도큐먼트는 복수의 필드들을 갖는다
- 엘라스틱서치 매핑으로 필드들의 데이터 타입을 지정할 수 있다
- 인덱스는 도큐먼트를 저장하는 논리적 단위
- 엘라스틱서치에서 도큐먼트를 인덱스에 포함시키는 것을 인덱싱이라고 한다
- 엘라스틱서치는 우리가 데이터 타입을 지정하지 않아도 도큐먼트의 필드와 값을 보고 자동으로 매핑해주는데 이를 다이내믹 매핑
- 다이내믹 매핑은 데이터 타입이 잘못된 도큐먼트가 들어올 때, 어느 정도 변환 가능한 경우는 자동으로 변환 ("20" -> 20)
- 도큐먼트의 R 은 도큐먼트의 id 값으로 가져올 수 있지만 실무에서 이렇게 가져오는 경우는 잘 없다. 대부분 검색 API 이용
- 도큐먼트 수정은 전체를 덮어쓰기할 수도 있고, 특정 필드의 값만 수정할 수도 있다
- 엘라스틱서치는 도큐먼트 수정 작업은 비용이 많이 들어간다. 그래서 더더욱 로그 수집 용도로 많이 사용되는 것
- 도큐먼트를 삭제할 때는 인덱스명과 도큐먼트 아이디를 알면 된다
- bulk API를 통해 생성/수정/삭제를 한 번에 요청할 수도 있다 (HTTP 요청을 한 번만 보내면 된다) (읽기는 불가)
- 현업에서는 벌크 데이터를 파일 형태로 만들어서 적용하는 방법을 많이 사용한다
- bulk API의 요청 데이터 포맷은 JSON 문법이 아닌 NDJSON 문법이다
  ```json
  {"index": {"_index": "index2", "_id": "6"}}
  {"name": "hong", "age": 10, "gender": "female"}
  {"index": {"_index": "index2", "_id": "7"}}
  {"name": "choi", "age": 20, "gender": "male"}  
  ```

## 인덱스

## 도큐먼트

## 매핑

- 엘라스틱서치가 검색 엔진으로 전문 검색과 대용량 데이터를 빠르게 실시간 검색할 수 있는 이유는 매핑이 있기 때문
- 자동으로 하면 다이내믹 매핑, 직접 설정하면 명시적 매핑
- 어떤 데이터가 들어올지 명시할 수 없다면 다이내믹 매핑을 써도 되지만,
- 성능 최적화와 데이터의 정확성을 위해서는 명시적으로 매핑을 하는 것이 좋다
- 인덱스 매핑이 정해지면 새로운 필드를 추가할 수 있으나, 이미 정의된 필드를 수정하거나 삭제할 수는 없다
- 필드 이름을 변경하거나 데이터 타입을 변경하기 위해서는 새로운 인덱스를 만들거나 reindex API를 이용해야 한다
- 매핑에는 properties, analyzer, format 과 같은 파라미터가 있다
- 매핑 파라미터, 데이터 타입
- 멀티필드: 하나의 필드를 여러 용도로 사용할 수 있게 해준다
- (ex. match query를 하고 싶을 때는 text타입, 집계나 정렬, term query를 하고 싶을 때는 keyword 타입)

## 인덱스 템플릿

- 동일한 복수의 인덱스를 만들 때 사용한다
- 관리 편의성, 성능 등을 위해 인덱스를 파티셔닝하는 일이 많은데 이 때 파티셔닝되는 인덱스들은 설정이 같아야 한다
- 템플릿에서 사용하는 파라미터는 index_patterns, priority, template 이 대표적. 
- template 안에는 settings, mappings 파라미터가 대표적
- 템플릿을 만들기 전에 이미 존재하던 인덱스는 템플릿 패턴과 일치하더라도 템플릿이 적용되지 않는다
- 7.8버전 이후로는 우선순위가 높은 템플릿만 적용된다

## 분석기(Analyzer)

- 전문 검색에서 양질의 결과를 얻기 위해서는 문자열을 나누는 기준이 중요
- 엘라스틱서치는 text 타입의 문자열을 분석기를 이용해 용어(term) 형태로 인덱스에 저장한다
- (검색에 사용되는 단위가 바로 용어(term)이다)
- 분석기는 캐릭터 필터, 토크나이저, 토큰 필터로 구성 (토크나이저만 필수 요소, 나머지는 선택 요소)
- 캐릭터 필터: 입력받은 문자열을 변경하거나 불필요한 문자들 제거 (html 태그 등)
- 토크나이저: 문자열을 토큰으로 분리. 분리할 때 토큰의 순서나 시작, 끝 위치도 기록
- 토큰 필터: 분리된 토큰에 대해 필터링 작업. 대소문자 구분, 형태소 분석 등의 작업. 토큰 필터를 거친 후의 토큰이 인덱스에 저장되면 이를 용어(term)라고 한다
- 분석기 종류에는 대표적으로 standard, simple, whitespace, stop 등이 있다
- 분석기 대신 토크나이저만 적용해도 되고, 토크나이저에 각종 필터를 추가할 수도 있다