I"<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#시간의-중요성" id="markdown-toc-시간의-중요성">시간의 중요성</a></li>
  <li><a href="#처리-시간과-이벤트-시간" id="markdown-toc-처리-시간과-이벤트-시간">처리 시간과 이벤트 시간</a></li>
  <li><a href="#timely-stream-processing" id="markdown-toc-timely-stream-processing">Timely Stream Processing</a>    <ul>
      <li><a href="#트리거" id="markdown-toc-트리거">트리거</a></li>
      <li><a href="#워터마크" id="markdown-toc-워터마크">워터마크</a></li>
    </ul>
  </li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<h1 id="시간의-중요성">시간의 중요성</h1>

<p>스트림 처리에서 핵심적인 개념은 <strong>‘시간’</strong>과 <strong>‘상태 관리’</strong>입니다. 이번 포스트에서는 그 중 첫 번째인 <strong>‘시간’</strong>에 대해 알아보도록 하겠습니다. 네트워크와 통신 채널 같은 현실 세계 시스템은 완벽하지 않기 때문에 데이터는 지연되거나 그로 인해 순서가 바뀌어 도착할 수도 있습니다. 이런 상황에서 스트림 처리가 정확하고 일관된 결과를 생성하는 것은 매우 중요한 문제입니다.</p>

<h1 id="처리-시간과-이벤트-시간">처리 시간과 이벤트 시간</h1>

<p><img src="/images/flink_8.png" alt="" /></p>

<ul>
  <li><strong>이벤트 시간</strong>: 이벤트가 발생한 시간</li>
  <li><strong>처리 시간</strong>: 이벤트가 스트림 처리 연산을 실행 중인 장비에서 처리된 시간</li>
</ul>

<p>만약 이벤트가 발생한 즉시 처리 될 수 있다면 두 시간을 굳이 구분할 필요가 없을 것입니다. 하지만 이러한 두 가지 시간은 일치하지 않을 뿐 아니라, 두 시간의 차이 또한 일정하지 않습니다. 현실 상황에서 일어날 수 있는 예시를 통해 각각의 방법으로 시간을 정의했을 때 어떤 차이가 생기는지 알아보겠습니다.</p>

<p>베를린에 살고 있는 앨리스는 출근마다 지하철 안에서 모바일 게임을 합니다. 게임에서는 500개의 풍선을 1분 안에 터트리면 보상을 받는 식입니다. 그런데 베를린 지하철의 네트워크는 자주 끊긴다는 문제가 있습니다. 앨리스가 게임을 하게 되면 발생된 이벤트를 스트림 처리 어플리케이션으로 보내진다고 할 때, 만약 게임 도중 네트워크가 끊기면 어떻게 될까요?</p>

<p><img src="/images/flink_7.png" alt="" /></p>

<p>위의 그림을 보면, 앨리스의 핸드폰에서는 1분 동안 총 6개의 데이터가 발생했습니다. 하지만 뒤에 2개의 데이터는 지하철이 터널을 지나고 있던 시점이라 아직 스트림 처리 어플리케이션으로 전송이 지연되었습니다. 이러한 상황에서 처리 시간을 기준으로 데이터를 처리한다면 4개의 데이터만을 고려해 결과를 낼 것입니다.</p>

<p>하지만 이벤트 시간은 이벤트 내용 안에 포함된 타임스탬프를 기반으로 하기 때문에, 지연되어 도착한 2개의 데이터도 1분 안에 보내진 데이터로 간주됩니다. 그렇기 때문에 스트림 분석 어플리케이션은 지연된 2개의 데이터를 기다릴 것이고 모두 도착한 이후 결과를 계산할 겁니다. 따라서 이벤트 시간은 이벤트의 일부가 <strong>지연되더라도 발생했던 일을 제대로 반영</strong>할 수 있습니다.</p>

<p>위의 예를 통해 알 수 있듯이, 이벤트 시간을 기반으로 하는 연산들은 예측할 수 있고 결과는 항상 결정적(deterministic)입니다. 지연된 이벤트의 처리 뿐만 아니라 <strong>데이터의 순서가 바뀌는 문제 또한 이벤트 시간을 사용함으로써 결과의 정확성을 보장</strong>할 수 있습니다.</p>

<p>만약 시간이나 순서가 중요한 데이터가 아니라면 처리 시간을 기준으로 연산을 해도 됩니다. 하지만 시간에 따른 사용자 행동 분석, 결제 관련 서비스, 이상 탐지 등 대부분의 스트림 처리 어플리케이션은 지연 고려, 순서와 같은 요소들이 중요하기 때문에 이벤트 시간을 기준으로 연산을 제공할 수 있어야 합니다.</p>

<p>이벤트 시간을 기준으로 사용하기 위해서는 <strong>워터마크</strong>라는 추가적인 설정을 해주어야 합니다.</p>

<h1 id="timely-stream-processing">Timely Stream Processing</h1>

<p>실시간 스트림 처리가 어려운 이유 중 하나는 <strong>데이터가 Unbounded(무한) Unordered(비정렬)</strong> 할 수 있다는 점입니다. <strong>Unordered한 특성은 이벤트 시간을 기준으로 타임스탬프를 적용해 해결</strong>할 수 있습니다. 그러면 Unbounded는 어떻게 해결할 수 있을까요? <strong>Unbounded한 특성은 윈도우를 이용해 해결</strong>할 수 있습니다.</p>

<p>아래 애니메이션은 Bounded(유한)한 데이터인 경우입니다. 이 경우에는 일정 시간이 지난 후에는 데이터가 더 들어오지 않기 때문에 데이터가 들어온 시간 범위 내에서 전체 데이터를 배치로 처리할 수 있습니다.</p>

<p><img src="/images/flink_9.mov" alt="" /></p>

<p>하지만 Unbounded한 경우에는 데이터가 끝이 없습니다. 일정 시간이 지난 후에 데이터가 들어올지 안들어올지 모르는 상황이기 때문에, 이러한 경우에는 윈도우를 사용해 데이터를 처리해야 합니다.</p>

<p><img src="/images/flink_10.mov" alt="" /></p>

<p>여기까지 오면 이제 실시간 스트림 처리에 조금 더 자신감이 생긴 것 같습니다. 이벤트 시간을 기준으로 타임스탬프를 정의하고, 윈도우를 사용해 무한한 데이터를 유한한 데이터로 나누어 봄으로써 Unbounded Unordered한 데이터가 발생하더라도 스트림 처리가 가능해졌습니다.</p>

<p>하지만 한가지 문제점이 남아있습니다. 현실 시스템에서 데이터 지연은 필연적으로 발생하게 되는데, 각 윈도우들에서 지연된 데이터를 포함한 모든 데이터를 받았다는 사실을 어떻게 알며 언제쯤 윈도우에서 결과를 출력할 수 있을까요? 여기서 등장하는 중요한 개념이 바로 <strong>‘트리거’</strong>와 <strong>‘워터마크’</strong>입니다.</p>

<h2 id="트리거">트리거</h2>

<ul>
  <li>윈도우가 출력되는 시점을 선언하는 방법</li>
  <li>결과가 생성되는 시기 제어</li>
</ul>

<h2 id="워터마크">워터마크</h2>

<h1 id="참고">참고</h1>
<ul>
  <li><a href="https://nightlies.apache.org/flink/flink-docs-master/docs/concepts/time/" target="_blank">Flink 공식문서: Timely Stream Processing</a></li>
  <li><a href="https://www.confluent.io/blog/apache-flink-apache-kafka-streams-comparison-guideline-users/" target="_blank">Flink and Kafka Streams: a Comparison and Guideline for Users</a></li>
  <li><a href="https://nightlies.apache.org/flink/flink-docs-master/docs/dev/datastream/operators/windows/" target="_blank">Flink 공식문서: Windows</a></li>
  <li><a href="http://streamingbook.net/fig" target="_blank">Streaming Systems 시각 자료 참고</a></li>
</ul>

:ET