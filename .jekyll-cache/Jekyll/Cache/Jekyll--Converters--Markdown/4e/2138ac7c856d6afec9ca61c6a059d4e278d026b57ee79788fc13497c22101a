I"àN<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#pytestê°€-ì¢‹ì€-ì´ìœ " id="markdown-toc-pytestê°€-ì¢‹ì€-ì´ìœ ">pytestê°€ ì¢‹ì€ ì´ìœ </a>    <ul>
      <li><a href="#less-boilerplate" id="markdown-toc-less-boilerplate">Less Boilerplate</a></li>
      <li><a href="#nicer-output" id="markdown-toc-nicer-output">Nicer Output</a></li>
      <li><a href="#easier-to-manage-state-and-dependencies" id="markdown-toc-easier-to-manage-state-and-dependencies">Easier to Manage State and Dependencies</a></li>
      <li><a href="#easy-to-filter-tests" id="markdown-toc-easy-to-filter-tests">Easy to Filter Tests</a></li>
      <li><a href="#allows-test-parametrization" id="markdown-toc-allows-test-parametrization">Allows Test Parametrization</a></li>
      <li><a href="#has-a-plugin-based-architecture" id="markdown-toc-has-a-plugin-based-architecture">Has a Plugin-Based Architecture</a></li>
    </ul>
  </li>
  <li><a href="#fixtures-managing-state-and-dependencies" id="markdown-toc-fixtures-managing-state-and-dependencies">Fixtures: Managing State and Dependencies</a>    <ul>
      <li><a href="#when-to-create-fixtures" id="markdown-toc-when-to-create-fixtures">When to Create Fixtures</a></li>
    </ul>
  </li>
  <li><a href="#marks-categorizing-tests" id="markdown-toc-marks-categorizing-tests">Marks: Categorizing Tests</a></li>
  <li><a href="#parametrization-combining-tests" id="markdown-toc-parametrization-combining-tests">Parametrization: Combining Tests</a></li>
</ul>

<hr />

<p>Testing your code brings a wide variety of benefits. It increases your confidence that the code behaves as you expect and ensures that changes to your code wonâ€™t cause regressions. Writing and maintaining tests is hard work, so you should leverage all the tools at your disposal to make it as painless as possible. <code class="language-plaintext highlighter-rouge">pytest</code> is one of the best tools that you can use to boost your testing productivity.</p>

<p>If youâ€™ve written unit tests for your Python code before, then you may have used Pythonâ€™s built-in <code class="language-plaintext highlighter-rouge">unittest</code> module. <code class="language-plaintext highlighter-rouge">unittest</code> provides a solid base on which to build your test suite, but it has a few shortcomings.</p>

<p>A number of third-party testing frameworks attempt to address some of the issues with <code class="language-plaintext highlighter-rouge">unittest</code>, and <code class="language-plaintext highlighter-rouge">pytest</code> has proven to be one of the most popular. <code class="language-plaintext highlighter-rouge">pytest</code> is a feature-rich, plugin-based ecosystem for testing your Python code.</p>

<h1 id="pytestê°€-ì¢‹ì€-ì´ìœ ">pytestê°€ ì¢‹ì€ ì´ìœ </h1>

<h2 id="less-boilerplate">Less Boilerplate</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">unittest</code>ëŠ” ìƒì†ë°›ê³ , unittestì—ì„œ ì œê³µí•˜ëŠ” assertë¬¸ì„ ì‚¬ìš©í•´ì•¼í•¨
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_with_unittest.py
</span>
<span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">TestCase</span>

<span class="k">class</span> <span class="nc">TryTesting</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_always_passes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_always_fails</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">pytest</code>ëŠ” ë³´í†µ í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ë“¯ ì‘ì„±í•˜ê³ , íŒŒì´ì¬ì—ì„œ ì œê³µí•˜ëŠ” assertë¬¸ ì‚¬ìš©í•˜ë©´ ë¨
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_with_pytest.py
</span>
<span class="k">def</span> <span class="nf">test_always_passes</span><span class="p">():</span>
    <span class="k">assert</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">test_always_fails</span><span class="p">():</span>
    <span class="k">assert</span> <span class="bp">False</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Most functional tests follow the Arrange-Act-Assert model:</p>

<ul>
  <li><strong>Arrange</strong>, or set up, the conditions for the test</li>
  <li><strong>Act</strong> by calling some function or method</li>
  <li><strong>Assert</strong> that some end condition is true</li>
</ul>

<h2 id="nicer-output">Nicer Output</h2>

<ul>
  <li>ë¨¼ì € ì‹œìŠ¤í…œ ìƒíƒœ, íŒŒì´ì¬ ë²„ì „, ë£¨íŠ¸ ë””ë ‰í† ë¦¬, ë°œê²¬ëœ í…ŒìŠ¤íŠ¸ì˜ ìˆ˜ì™€ ê°™ì€ ì •ë³´ë¥¼ ì œê³µ</li>
  <li>í…ŒìŠ¤íŠ¸ ê²°ê³¼ì˜ ì•„ì›ƒí’‹ì€ ë‹¤ìŒê³¼ ê°™ìŒ
    <ul>
      <li>A dot (.) means that the test passed.</li>
      <li>An F means that the test has failed.</li>
      <li>An E means that the test raised an unexpected exception.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test_with_pytest.py .F                                                   [ 50%]
test_with_unittest.py F.                                                 [100%]
</code></pre></div></div>

<p>ìœ„ì˜ ê²°ê³¼ë¥¼ í•´ì„í•´ë³´ë©´, test_with_pytest.py íŒŒì¼ ì•ˆì—ëŠ” ë‘ ê°œì˜ í…ŒìŠ¤íŠ¸ ì½”ë“œê°€ ìˆê³ , í•˜ë‚˜ëŠ” ì„±ê³µ, í•˜ë‚˜ëŠ” ì‹¤íŒ¨í–ˆìŒì„ ë‚˜íƒ€ë‚¸ë‹¤. test_with_unittest.py íŒŒì¼ ì•ˆì—ì„œëŠ” í•˜ë‚˜ëŠ” ì‹¤íŒ¨, í•˜ë‚˜ëŠ” ì„±ê³µí–ˆì„ìŒ ë‚˜íƒ€ë‚¸ë‹¤. pytestë¡œ ì‹¤í–‰í•˜ë©´ ìœ„ì™€ê°™ì´ unittestë¡œ ì‘ì„±í•œ í…ŒìŠ¤íŠ¸ ì½”ë“œë„ ì¸ì‹í•  ìˆ˜ ìˆë‹¤.</p>

<h2 id="easier-to-manage-state-and-dependencies">Easier to Manage State and Dependencies</h2>

<ul>
  <li>í…ŒìŠ¤íŠ¸ì— ì‚¬ìš©ë˜ëŠ” ë°ì´í„° íƒ€ì…ì´ dict, jsonê³¼ ê°™ì´ ë‹¤ë¥´ë‹¤</li>
  <li>pytest takes a different approach. It leads you toward explicit dependency declarations that are still reusable thanks to the availability of fixtures. pytest fixtures are functions that can create data, test doubles, or initialize system state for the test suite. Any test that wants to use a fixture must explicitly use this fixture function as an argument to the test function, so dependencies are always stated up front:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># fixture_demo.py
</span>
<span class="kn">import</span> <span class="nn">pytest</span>

<span class="o">@</span><span class="n">pytest</span><span class="p">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">example_fixture</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">test_with_fixture</span><span class="p">(</span><span class="n">example_fixture</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">example_fixture</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Looking at the test function, you can immediately tell that it depends on a fixture, without needing to check the whole file for fixture definitions.</p>

<h2 id="easy-to-filter-tests">Easy to Filter Tests</h2>

<ul>
  <li>í”„ë¡œì íŠ¸ ê·œëª¨ê°€ ì»¤ì§€ê³ , í…ŒìŠ¤íŠ¸ ì½”ë“œ ê·œëª¨ë„ í•¨ê»˜ ì»¤ì§€ë©´ ë‚˜ì¤‘ì—ëŠ” ì›í•˜ëŠ” ëª‡ ê°œì˜ í…ŒìŠ¤íŠ¸ë§Œ í•„í„°ë§í•˜ê³  ì‹¶ì„ ë•Œê°€ ìˆìŒ</li>
  <li>pytest ì—ì„œëŠ” í…ŒìŠ¤íŠ¸ë¥¼ í•„í„°ë§ í•˜ëŠ” ëª‡ê°€ì§€ ë°©ë²•ì„ ì œê³µ
    <ul>
      <li><strong>Name-based filtering</strong>: You can limit pytest to running only those tests whose fully qualified names match a particular expression. You can do this with the -k parameter.</li>
      <li><strong>Directory scoping</strong>: By default, pytest will run only those tests that are in or under the current directory.</li>
      <li><strong>Test categorization</strong>: pytest can include or exclude tests from particular categories that you define. You can do this with the -m parameter.</li>
    </ul>
  </li>
</ul>

<p>Test categorization in particular is a subtly powerful tool. pytest enables you to create marks, or custom labels, for any test you like. A test may have multiple labels, and you can use them for granular control over which tests to run. Later in this tutorial, youâ€™ll see an example of how pytest marks work and learn how to make use of them in a large test suite.</p>

<h2 id="allows-test-parametrization">Allows Test Parametrization</h2>

<ul>
  <li>ì–´ë–¤ í•˜ë‚˜ì˜ í…ŒìŠ¤íŠ¸ ì½”ë“œì— ëŒ€í•´ì„œ ë‹¤ì–‘í•œ ì¸í’‹ì„ ë„£ì–´ì„œ ì‹¤í—˜í•˜ëŠ” ê²½ìš°ê°€ ìˆìŒ</li>
  <li>unittestëŠ” ì´ ë•Œì˜ ê²°ê³¼ë¥¼ í•˜ë‚˜ë¡œ ì¶œë ¥ -&gt; ì¸í’‹ì¤‘ í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨í•˜ë©´ ê·¸ëƒ¥ ê·¸ í…ŒìŠ¤íŠ¸ ì „ì²´ê°€ ì‹¤íŒ¨í•œ ê²ƒìœ¼ë¡œ ê°„ì£¼</li>
  <li>pytestëŠ” ê°ê°ì˜ ì¸í’‹ì— ëŒ€í•´ì„œ ì–´ë–¤ ì¸í’‹ì´ ì‹¤íŒ¨í•˜ëŠ”ì§€ë¥¼ ì•Œë ¤ì¤Œ</li>
</ul>

<h2 id="has-a-plugin-based-architecture">Has a Plugin-Based Architecture</h2>

<ul>
  <li>pytestëŠ” ëª¨ë“ˆí™”ë˜ì–´ í™•ì¥ì„±ì´ ë›°ì–´ë‚˜ë„ë¡ ì„¤ê³„ë¨</li>
  <li>ë§ì€ ê°œë°œìë“¤ì´ ì»¤ìŠ¤í„°ë§ˆì´ì§•í•´ì„œ ì‚¬ìš©ì¤‘</li>
</ul>

<h1 id="fixtures-managing-state-and-dependencies">Fixtures: Managing State and Dependencies</h1>

<p>pytest fixtures are a way of providing data, test doubles, or state setup to your tests. Fixtures are functions that can return a wide range of values. Each test that depends on a fixture must explicitly accept that fixture as an argument.</p>

<ul>
  <li>ì–´ë–¤ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ í•„ìš”í•œ ì´ˆê¸° ì¡°ê±´ì„ ì„¸íŒ…í•˜ì—¬ ê°ì²´(fixture)ë¡œ ë¦¬í„´í•˜ëŠ” í•¨ìˆ˜</li>
  <li>í…ŒìŠ¤íŠ¸ë¥¼ ì‰½ê²Œ ë°˜ë³µì ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆë„ë¡ ë„ì™€ì£¼ëŠ” ê²ƒ</li>
  <li>ì´ ê°ì²´(fixture)ëŠ” ë°˜ë“œì‹œ í…ŒìŠ¤íŠ¸ ì½”ë“œì˜ ì¸ìë¡œ ëª…ì‹œë˜ì–´ì•¼í•¨</li>
  <li>(ì‰½ê²Œ ë§í•´, í…ŒìŠ¤íŠ¸ì˜ ëŒ€ìƒì´ ë˜ëŠ” ê°ì²´ë¥¼ ë¦¬í„´í•˜ëŠ” í•¨ìˆ˜ë¥¼ <code class="language-plaintext highlighter-rouge">@pytest.fixture</code>ë¡œ ë°ì½”ë ˆì´íŒ…)</li>
  <li>(ê·¸ëŸ¬ë©´ í…ŒìŠ¤íŠ¸ ì½”ë“œì—ì„œ ì´ ê°ì²´ë¥¼ ë”°ë¡œ ë°˜ë³µ ìƒì„±í•˜ì§€ ì•Šì•„ë„ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ)</li>
</ul>

<h2 id="when-to-create-fixtures">When to Create Fixtures</h2>
<p>In this section, youâ€™ll simulate a typical test-driven development (TDD) workflow.</p>

<p>Imagine youâ€™re writing a function, format_data_for_display(), to process the data returned by an API endpoint. The data represents a list of people, each with a given name, family name, and job title. The function should output a list of strings that include each personâ€™s full name (their given_name followed by their family_name), a colon, and their title:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># format_data.py
</span>
<span class="k">def</span> <span class="nf">format_data_for_display</span><span class="p">(</span><span class="n">people</span><span class="p">):</span>
    <span class="p">...</span>  <span class="c1"># Implement this!
</span></code></pre></div></div>

<p>In good TDD fashion, youâ€™ll want to first write a test for it. You might write the following code for that:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_format_data.py
</span>
<span class="k">def</span> <span class="nf">test_format_data_for_display</span><span class="p">():</span>
    <span class="n">people</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s">"given_name"</span><span class="p">:</span> <span class="s">"Alfonsa"</span><span class="p">,</span>
            <span class="s">"family_name"</span><span class="p">:</span> <span class="s">"Ruiz"</span><span class="p">,</span>
            <span class="s">"title"</span><span class="p">:</span> <span class="s">"Senior Software Engineer"</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s">"given_name"</span><span class="p">:</span> <span class="s">"Sayid"</span><span class="p">,</span>
            <span class="s">"family_name"</span><span class="p">:</span> <span class="s">"Khan"</span><span class="p">,</span>
            <span class="s">"title"</span><span class="p">:</span> <span class="s">"Project Manager"</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">]</span>

    <span class="k">assert</span> <span class="n">format_data_for_display</span><span class="p">(</span><span class="n">people</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span>
        <span class="s">"Alfonsa Ruiz: Senior Software Engineer"</span><span class="p">,</span>
        <span class="s">"Sayid Khan: Project Manager"</span><span class="p">,</span>
    <span class="p">]</span>
</code></pre></div></div>

<p>While writing this test, it occurs to you that you may need to write another function to transform the data into comma-separated values for use in Excel:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># format_data.py
</span>
<span class="k">def</span> <span class="nf">format_data_for_display</span><span class="p">(</span><span class="n">people</span><span class="p">):</span>
    <span class="p">...</span>  <span class="c1"># Implement this!
</span>
<span class="k">def</span> <span class="nf">format_data_for_excel</span><span class="p">(</span><span class="n">people</span><span class="p">):</span>
    <span class="p">...</span> <span class="c1"># Implement this!
</span></code></pre></div></div>

<p>Your to-do list grows! Thatâ€™s good! One of the advantages of TDD is that it helps you plan out the work ahead. The test for the format_data_for_excel() function would look awfully similar to the format_data_for_display() function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_format_data.py
</span>
<span class="k">def</span> <span class="nf">test_format_data_for_display</span><span class="p">():</span>
    <span class="c1"># ...
</span>
<span class="k">def</span> <span class="nf">test_format_data_for_excel</span><span class="p">():</span>
    <span class="n">people</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s">"given_name"</span><span class="p">:</span> <span class="s">"Alfonsa"</span><span class="p">,</span>
            <span class="s">"family_name"</span><span class="p">:</span> <span class="s">"Ruiz"</span><span class="p">,</span>
            <span class="s">"title"</span><span class="p">:</span> <span class="s">"Senior Software Engineer"</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s">"given_name"</span><span class="p">:</span> <span class="s">"Sayid"</span><span class="p">,</span>
            <span class="s">"family_name"</span><span class="p">:</span> <span class="s">"Khan"</span><span class="p">,</span>
            <span class="s">"title"</span><span class="p">:</span> <span class="s">"Project Manager"</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">]</span>

    <span class="k">assert</span> <span class="n">format_data_for_excel</span><span class="p">(</span><span class="n">people</span><span class="p">)</span> <span class="o">==</span> <span class="s">"""given,family,title
Alfonsa,Ruiz,Senior Software Engineer
Sayid,Khan,Project Manager
"""</span>
</code></pre></div></div>

<p>Notably, both the tests have to repeat the definition of the people variable, which is quite a few lines of code.</p>

<p>If you find yourself writing several tests that all make use of the same underlying test data, then a fixture may be in your future. You can pull the repeated data into a single function decorated with @pytest.fixture to indicate that the function is a pytest fixture:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_format_data.py
</span>
<span class="kn">import</span> <span class="nn">pytest</span>

<span class="o">@</span><span class="n">pytest</span><span class="p">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">example_people_data</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s">"given_name"</span><span class="p">:</span> <span class="s">"Alfonsa"</span><span class="p">,</span>
            <span class="s">"family_name"</span><span class="p">:</span> <span class="s">"Ruiz"</span><span class="p">,</span>
            <span class="s">"title"</span><span class="p">:</span> <span class="s">"Senior Software Engineer"</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s">"given_name"</span><span class="p">:</span> <span class="s">"Sayid"</span><span class="p">,</span>
            <span class="s">"family_name"</span><span class="p">:</span> <span class="s">"Khan"</span><span class="p">,</span>
            <span class="s">"title"</span><span class="p">:</span> <span class="s">"Project Manager"</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">]</span>

<span class="c1"># ...
</span></code></pre></div></div>

<p>You can use the fixture by adding the function reference as an argument to your tests. Note that you donâ€™t call the fixture function. pytest takes care of that. Youâ€™ll be able to use the return value of the fixture function as the name of the fixture function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_format_data.py
</span>
<span class="c1"># ...
</span>
<span class="k">def</span> <span class="nf">test_format_data_for_display</span><span class="p">(</span><span class="n">example_people_data</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">format_data_for_display</span><span class="p">(</span><span class="n">example_people_data</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span>
        <span class="s">"Alfonsa Ruiz: Senior Software Engineer"</span><span class="p">,</span>
        <span class="s">"Sayid Khan: Project Manager"</span><span class="p">,</span>
    <span class="p">]</span>

<span class="k">def</span> <span class="nf">test_format_data_for_excel</span><span class="p">(</span><span class="n">example_people_data</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">format_data_for_excel</span><span class="p">(</span><span class="n">example_people_data</span><span class="p">)</span> <span class="o">==</span> <span class="s">"""given,family,title
Alfonsa,Ruiz,Senior Software Engineer
Sayid,Khan,Project Manager
"""</span>
</code></pre></div></div>

<p>Each test is now notably shorter but still has a clear path back to the data it depends on. Be sure to name your fixture something specific. That way, you can quickly determine if you want to use it when writing new tests in the future!</p>

<p>When you first discover the power of fixtures, it can be tempting to use them all the time, but as with all things, thereâ€™s a balance to be maintained.</p>

<h1 id="marks-categorizing-tests">Marks: Categorizing Tests</h1>

<h1 id="parametrization-combining-tests">Parametrization: Combining Tests</h1>
:ET