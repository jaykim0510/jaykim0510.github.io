I"<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#order-by-처리" id="markdown-toc-order-by-처리">ORDER BY 처리</a></li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<p>옵티마이저: 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하여 최적의 실행 계획을 수립</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>실행 계획 출력
EXPLAIN
SELECT문
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>쿼리의 실행 계획과 단계별 소요된 시간 정보 출력
EXPLAIN ANALYZE
SELECT문
</code></pre></div></div>

<p>실행 계획을 이해하고 실행 계획의 불합리한 부분을 찾아내고, 더 최적화된 방법으로 실행 계획을 수립하도록 유도하는 법을 배우자</p>

<p><strong>쿼리 실행 절차</strong></p>

<ol>
  <li>MySQL 엔진의 SQL파서에서 SQL을 트리 형태로 파싱한다</li>
  <li>MySQL 엔진의 옵티마이저에서 파싱 정보를 확인하면서 통계 정보를 활용해 어떤 인덱스를 이용해 테이블을 읽을지 선택한다</li>
  <li>2 단계가 완료되면 실행 계획이 만들어진다</li>
  <li>스토리지 엔진에 실행 계획대로 레코드를 읽어오도록 요청한다</li>
  <li>MySQL 엔진의 SQL 실행기가 스토리지 엔진으로부터 받아온 레코드를 조인하거나 정렬하는 작업을 수행한다</li>
</ol>

<h1 id="order-by-처리">ORDER BY 처리</h1>

<ul>
  <li>대부분의 SELECT 쿼리에서 정렬은 필수적</li>
  <li>정렬을 처리하는 방법은 인덱스를 이용하는 방법과 Filesort라는 별도의 처리를 이용하는 방법</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>방법</td>
      <td>장점</td>
      <td>단점</td>
    </tr>
    <tr>
      <td>인덱스 이용</td>
      <td>SELECT 문을 실행할 때 이미 인덱스가 정렬돼 있어 순서대로 읽기만 하면 되므로 매우 빠르다</td>
      <td>INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다</td>
    </tr>
    <tr>
      <td>Filesort 이용</td>
      <td>인덱스 이용과 반대로 INSERT, UPDATE, DELETE 작업이 빠르다</td>
      <td>정렬 작업이 쿼리 실행 시 처리되어 쿼리의 응답 속도가 느려진다</td>
    </tr>
  </tbody>
</table>

<p><strong>Filesort를 사용해야 하는 경우</strong></p>

<ul>
  <li>정렬 기준이 너무 많아서 모든 인덱스를 생성하는 것이 불가능한 경우</li>
  <li>어떤 처리의 결과를 정렬해야 하는 경우</li>
  <li>랜덤하게 결과 레코드를 가져와야 하는 경우</li>
</ul>

<p><strong>소트 버퍼</strong></p>

<ul>
  <li>MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데 이 메모리 공간을 소트 버퍼라고 한다</li>
  <li>정렬해야 할 레코드의 건수가 소트 버퍼의 크기보다 크다면 어떻게 해야 할까?
    <ul>
      <li>정렬해야 할 레코드를 여러 조각으로 나눠서 처리하게 됨. 이 과정에서 임시 저장을 위해 디스크를 사용</li>
      <li>일부를 처리하고 디스크에 저장하기를 반복 수행함</li>
    </ul>
  </li>
</ul>

<p><strong>정렬 알고리즘</strong></p>

<ul>
  <li>정렬 대상 컬럼과 프라이머리 키만 가져와서 정렬하는 방식
    <ul>
      <li>정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아 정렬을 수행</li>
      <li>그리고 다시 정렬 순서대로 프라이머리 키로 테이블을 읽어서 SELECT할 컬럼을 가져옴</li>
      <li>가져오는 컬럼이 두 개 뿐이라 소트 버퍼에 많은 레코드를 한 번에 읽어올 수 있음</li>
      <li>단점은 테이블을 두 번 읽어야 함</li>
    </ul>
  </li>
  <li>정렬 대상 컬럼과 SELECT문으로 요청한 컬럼을 모두 가져와서 정렬하는 방식
    <ul>
      <li>최신 버전의 MySQL에서 일반적으로 사용하는 방식</li>
      <li>SELECT 문에서 요청한 컬럼의 개수가 많아지면 계속 분할해서 소트 버퍼에 읽어와야함</li>
      <li>레코드의 크기나 건수가 작은 경우 성능이 좋음</li>
    </ul>
  </li>
</ul>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791158392703&amp;orderClick=LAG&amp;Kc=" target="_blank">Real MySQL 8.0 (1권) 책</a></li>
</ul>
:ET