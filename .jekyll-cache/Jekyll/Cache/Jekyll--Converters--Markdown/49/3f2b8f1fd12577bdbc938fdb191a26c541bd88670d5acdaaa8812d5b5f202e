I"v<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#dfs" id="markdown-toc-dfs">DFS</a>    <ul>
      <li><a href="#traversing-all-vertices" id="markdown-toc-traversing-all-vertices">Traversing all Vertices</a></li>
      <li><a href="#traversing-all-paths-between-two-vertices" id="markdown-toc-traversing-all-paths-between-two-vertices">Traversing all paths between two vertices</a></li>
    </ul>
  </li>
  <li><a href="#bfs" id="markdown-toc-bfs">BFS</a>    <ul>
      <li><a href="#traversing-all-vertices-1" id="markdown-toc-traversing-all-vertices-1">Traversing all Vertices</a></li>
      <li><a href="#shortest-path-between-two-vertices" id="markdown-toc-shortest-path-between-two-vertices">Shortest Path Between Two Vertices</a></li>
    </ul>
  </li>
  <li><a href="#backtracking" id="markdown-toc-backtracking">Backtracking</a></li>
</ul>

<hr />

<h1 id="dfs">DFS</h1>

<ul>
  <li>DFS는 그래프를 탐색하는 대표적인 알고리즘이다</li>
  <li>대표적으로 두 가지 경우에 DFS가 사용된다
    <ul>
      <li>모든 노드를 방문해야할 때 -&gt; Brute-Force의 그래프 버전 -&gt; 더 이상 깊이 탐색할 필요가 없는 곳은 멈추는 것이 좋다(백트래킹)</li>
      <li>두 노드간의 모든 가능한 경로를 확인해야할 때 -&gt; 방법의 수, 최소/최대값에 많이 사용</li>
    </ul>
  </li>
  <li>DFS는 재귀함수로 구현할 수도 있고, <code class="language-plaintext highlighter-rouge">while + stack</code>을 사용해 구현할 수도 있다</li>
</ul>

<h2 id="traversing-all-vertices">Traversing all Vertices</h2>

<ul>
  <li>모든 노드를 방문하는 경우의 경로 출력하기</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">def</span> <span class="nf">all_node_visit</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">n1</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">n2</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dic</span><span class="p">):</span>
            <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">tmp_visited</span> <span class="o">=</span> <span class="n">visited</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">tmp_visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">paths</span><span class="o">+</span><span class="p">[</span><span class="n">neighbor</span><span class="p">],</span> <span class="n">tmp_visited</span><span class="p">)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dfs</span><span class="p">(</span><span class="s">"A"</span><span class="p">,</span> <span class="p">[</span><span class="s">"A"</span><span class="p">],</span> <span class="nb">set</span><span class="p">(</span><span class="s">"A"</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">answer</span>

<span class="n">vertices</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">),</span> <span class="p">(</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">),</span> <span class="p">(</span><span class="s">'C'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">),</span> <span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">),</span> <span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">),</span> <span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">),</span> <span class="p">(</span><span class="s">'D'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">)]</span>
<span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">all_node_visit</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
<span class="o">-----------------------------------------------------------------------------------------------------</span>
<span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="traversing-all-paths-between-two-vertices">Traversing all paths between two vertices</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">src</code>에서 <code class="language-plaintext highlighter-rouge">tgt</code>로 가는 모든 경로 출력하기</li>
  <li>모든 노드를 방문하는 알고리즘과 거의 똑같다. dfs함수를 종료하는 시점을 <code class="language-plaintext highlighter-rouge">node == tgt</code> 로 했을 뿐이다</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">def</span> <span class="nf">all_paths_between_two_nodes</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">tgt</span><span class="p">):</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">n1</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">n2</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">tgt</span><span class="p">:</span>
            <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">tmp_visited</span> <span class="o">=</span> <span class="n">visited</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">tmp_visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">paths</span><span class="o">+</span><span class="p">[</span><span class="n">neighbor</span><span class="p">],</span> <span class="n">tmp_visited</span><span class="p">)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="n">src</span><span class="p">],</span> <span class="nb">set</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">answer</span>



<span class="n">vertices</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">),</span> <span class="p">(</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">),</span> <span class="p">(</span><span class="s">'C'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">),</span> <span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">),</span> <span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">),</span> <span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">),</span> <span class="p">(</span><span class="s">'D'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">)]</span>
<span class="n">src</span> <span class="o">=</span> <span class="s">"E"</span>
<span class="n">tgt</span> <span class="o">=</span> <span class="s">"B"</span>
<span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">all_paths_between_two_nodes</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">tgt</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
<span class="o">------------------------------------------------------------------------------------------------------</span>
<span class="p">[</span><span class="s">'E'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'E'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'A'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'E'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'E'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>
</code></pre></div></div>

<h1 id="bfs">BFS</h1>

<ul>
  <li>BFS도 DFS와 마찬가지로 그래프에서 모든 노드를 탐색하는 대표적인 알고리즘이다</li>
  <li>BFS는 너비순으로 노드를 탐색하기 때문에, 가장 짧은 경로를 찾아야 할 때 이점이 있다
    <ul>
      <li>DFS는 모든 경로를 찾아서 가장 짧은 경로를 선택해야 하지만, BFS는 제일 처음으로 찾는 경로가 가장 짧은 경로가 되므로 바로 정답으로 선택할 수 있다</li>
    </ul>
  </li>
  <li>BFS는 다음과 같은 경우에 많이 사용된다
    <ul>
      <li>모든 노드를 방문해야할 때</li>
      <li>두 노드간 가장 짧은 경로를 찾아야 할 때(경로의 가중치는 1로 모두 같다고 가정, 가중치가 다르면 Dijkstra, 음의 가중치를 가지면 Bellman-For)</li>
    </ul>
  </li>
  <li>BFS는 <code class="language-plaintext highlighter-rouge">while + queue</code>로 구현할 수 있다</li>
</ul>

<h2 id="traversing-all-vertices-1">Traversing all Vertices</h2>

<ul>
  <li>BFS로 모든 노드를 방문할 때의 경로 출력하기</li>
  <li>(결과가 신기하게도 DFS랑 순서가 똑같다)</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">all_node_visit</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">n1</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">n2</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">start</span><span class="p">,</span> <span class="p">{</span><span class="n">start</span><span class="p">},</span> <span class="p">[</span><span class="n">start</span><span class="p">])])</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">cur_node</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">tmp_visited</span> <span class="o">=</span> <span class="n">visited</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">tmp_visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                <span class="n">tmp_paths</span> <span class="o">=</span> <span class="n">paths</span> <span class="o">+</span> <span class="p">[</span><span class="n">neighbor</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_paths</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dic</span><span class="p">):</span>
                    <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_paths</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">tmp_visited</span><span class="p">,</span> <span class="n">tmp_paths</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">answer</span>


<span class="n">vertices</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">),</span> <span class="p">(</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">),</span> <span class="p">(</span><span class="s">'C'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">),</span> <span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">),</span> <span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">),</span> <span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">),</span> <span class="p">(</span><span class="s">'D'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">)]</span>
<span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">all_node_visit</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="s">"E"</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
<span class="o">-------------------------------------------------------------------------------------</span>
<span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="shortest-path-between-two-vertices">Shortest Path Between Two Vertices</h2>

<ul>
  <li>두 노드간의 최단 경로 구하기</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">all_node_visit</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">n1</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">n2</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">start</span><span class="p">,</span> <span class="p">{</span><span class="n">start</span><span class="p">},</span> <span class="p">[</span><span class="n">start</span><span class="p">])])</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">cur_node</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">tmp_visited</span> <span class="o">=</span> <span class="n">visited</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">tmp_visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                <span class="n">tmp_paths</span> <span class="o">=</span> <span class="n">paths</span> <span class="o">+</span> <span class="p">[</span><span class="n">neighbor</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                    <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_paths</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">tmp_visited</span><span class="p">,</span> <span class="n">tmp_paths</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">answer</span>


<span class="n">vertices</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">),</span> <span class="p">(</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">),</span> <span class="p">(</span><span class="s">'C'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">),</span> <span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">),</span> <span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">),</span> <span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">),</span> <span class="p">(</span><span class="s">'D'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">)]</span>
<span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">all_node_visit</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="s">"E"</span><span class="p">,</span> <span class="s">"B"</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
<span class="o">--------------------------------------------------------------------------------</span>
<span class="c1"># 확실히 거리가 짧은 순서대로 나온다
</span><span class="p">[</span><span class="s">'E'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'E'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'E'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'E'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'A'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>

<span class="c1"># 참고로 DFS의 결과는 다음과 같았다
</span><span class="p">[</span><span class="s">'E'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'E'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'A'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'E'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'E'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">]</span>
</code></pre></div></div>

<h1 id="backtracking">Backtracking</h1>

<ul>
  <li>노드를 탐색할 때 더 이상 탐색할 필요가 없는 경로는 종료시키는 것</li>
</ul>
:ET