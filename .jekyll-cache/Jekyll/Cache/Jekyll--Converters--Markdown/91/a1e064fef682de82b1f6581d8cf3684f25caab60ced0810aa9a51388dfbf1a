I"1<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#데이터베이스-주요-특성" id="markdown-toc-데이터베이스-주요-특성">데이터베이스 주요 특성</a>    <ul>
      <li><a href="#데이터베이스-모델" id="markdown-toc-데이터베이스-모델">데이터베이스 모델</a>        <ul>
          <li><a href="#rdbms" id="markdown-toc-rdbms">RDBMS</a></li>
          <li><a href="#document-store" id="markdown-toc-document-store">Document Store</a></li>
          <li><a href="#wide-column-store" id="markdown-toc-wide-column-store">Wide Column Store</a></li>
          <li><a href="#key-value-store" id="markdown-toc-key-value-store">Key-Value Store</a></li>
        </ul>
      </li>
      <li><a href="#쿼리-지원" id="markdown-toc-쿼리-지원">쿼리 지원</a></li>
      <li><a href="#in-memory-지원" id="markdown-toc-in-memory-지원">In-memory 지원</a></li>
      <li><a href="#검색엔진-지원" id="markdown-toc-검색엔진-지원">검색엔진 지원</a></li>
      <li><a href="#scale-up-scale-out" id="markdown-toc-scale-up-scale-out">Scale-Up, Scale-Out</a></li>
    </ul>
  </li>
  <li><a href="#주요-데이터베이스간-비교" id="markdown-toc-주요-데이터베이스간-비교">주요 데이터베이스간 비교</a>    <ul>
      <li><a href="#mysql-vs-hive-vs-redshift" id="markdown-toc-mysql-vs-hive-vs-redshift">MySQL vs Hive vs Redshift</a></li>
      <li><a href="#mongodb-vs-cassandra-vs-elasticsearch" id="markdown-toc-mongodb-vs-cassandra-vs-elasticsearch">MongoDB vs Cassandra vs ElasticSearch</a></li>
      <li><a href="#dynamodb-vs-hbase-vs-redis" id="markdown-toc-dynamodb-vs-hbase-vs-redis">DynamoDB vs HBase vs Redis</a></li>
    </ul>
  </li>
  <li><a href="#youtube" id="markdown-toc-youtube">Youtube</a></li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<h1 id="데이터베이스-주요-특성">데이터베이스 주요 특성</h1>

<h2 id="데이터베이스-모델">데이터베이스 모델</h2>

<h3 id="rdbms">RDBMS</h3>

<ul>
  <li>MySql</li>
  <li>PostreSQL</li>
  <li>Apache Hive</li>
  <li>AWS Redshift</li>
</ul>

<h3 id="document-store">Document Store</h3>

<ul>
  <li>Schema free한 DBMS와 비슷한 느낌 (NoSQL 중에서 가장 RDBMS와 비슷한 데이터베이스)</li>
  <li>데이터가 완전히 Structured 되어 있지 않지만, 최대한 DBMS와 비슷하게 사용하고 싶은 경우</li>
  <li>데이터 하나는 JSON과 같은 객체</li>
  <li>SQL과 같은 언어로 데이터를 필터링하는 느낌으로 데이터를 읽음 =&gt; 읽어오는게 key-value만큼 빠르지는 않음</li>
  <li>쿼리의 성능을 조금 포기하는 대신 범용적인 데이터 수집을 가능하게 함</li>
  <li>ex. MongoDB, Elasticsearch 등</li>
</ul>

<h3 id="wide-column-store">Wide Column Store</h3>
<ul>
  <li>Wide column databases store data in large column-based tables instead of rows. Queries can be run quickly on large amounts of data, making these databases common for retail and IoT data.</li>
  <li>A wide-column database is a NoSQL database that organizes data storage into flexible columns that can be spread across multiple servers or database nodes, using multi-dimensional mapping to reference data by column, row, and timestamp.</li>
  <li>A wide-column database is a type of NoSQL database in which the names and format of the columns can vary across rows, even within the same table. Wide-column databases are also known as column family databases. Because data is stored in columns, queries for a particular value in a column are very fast, as the entire column can be loaded and searched quickly. Related columns can be modeled as part of the same column family.</li>
  <li>Benefits of a wide-column NoSQL database include speed of querying, scalability, and a flexible data model.</li>
  <li>
    <p>A relational database management system (RDBMS) stores data in a table with rows that all span a number of columns. If one row needs an additional column, that column must be added to the entire table, with null or default values provided for all the other rows. If you need to query that RDBMS table for a value that isn’t indexed, the table scan to locate those values will be very slow.</p>
  </li>
  <li>Wide-column NoSQL databases still have the concept of rows, but reading or writing a row of data consists of reading or writing the individual columns. A column is only written if there’s a data element for it. Each data element can be referenced by the row key, but querying for a value is optimized like querying an index in a RDBMS, rather than a slow table scan.</li>
  <li>A Columnar data store will store each column separately on disk. A Wide-column database is a type of columnar database that supports a column family stored together on disk, not just a single column.</li>
  <li>Key-value와 비슷한데 차이점은 Key-value는 key로 무조건 Value 전체를 읽어야 함</li>
  <li>Wide-column은 key로 읽은 결과에서 Column을 통해 더 specific한 value를 얻을 수 있음</li>
  <li>ex. Apache Cassandra, Apache HBase
<img src="/images/wide_column_1.png" alt="" /></li>
</ul>

<h3 id="key-value-store">Key-Value Store</h3>

<ul>
  <li>해시테이블과 같은 자료구조를 데이터베이스화 한 것</li>
  <li>Key를 통해 value를 가져올 수 있다</li>
  <li>Key는 유니크해야 한다</li>
  <li>Value는 어떤것이든 될 수 있다(숫자, 텍스트, JSON, URI, 이미지 등)</li>
  <li>Value의 일부만 읽는 것은 불가능 (이 점이 wide-column과의 차이)</li>
  <li>Value를 SQL과 같은 언어가 아니라 key값으로 가져옴 -&gt; 굉장히 빠르다</li>
  <li>Key에 해당하는 value 한개</li>
  <li>Key-value store + In-memory =&gt; Redis =&gt; Redis가 캐싱 DB 서버로 많이 사용되는 이유</li>
  <li>ex. Redis, AWS DynamoDB, Apache HBase</li>
</ul>

<h2 id="쿼리-지원">쿼리 지원</h2>

<h2 id="in-memory-지원">In-memory 지원</h2>

<p>In-memory databases are purpose-built databases that rely <strong>primarily on memory</strong> for data storage, in contrast to databases that store data on disk or SSDs. In-memory data stores are designed to enable minimal response times by eliminating the need to access disks. Because all data is stored and managed exclusively in main memory, in-memory databases risk losing data upon a process or server failure. In-memory databases can persist data on disks by storing each operation in a log or by taking snapshots.</p>

<p>In-memory databases are ideal for applications that require microsecond response times or have large spikes in traffic such as gaming leaderboards, session stores, and real-time analytics.</p>

<ul>
  <li>Redis</li>
  <li>AWS ElastiCache</li>
  <li>Microsoft SQL Server</li>
  <li>(MySQL, MongoDB와 같은 DB도 메모리 캐시를 지원하지만 주요 저장장치는 디스크이기 때문에 In-memory가 아님)</li>
</ul>

<h2 id="검색엔진-지원">검색엔진 지원</h2>

<ul>
  <li>Elasticsearch</li>
</ul>

<h2 id="scale-up-scale-out">Scale-Up, Scale-Out</h2>

<ul>
  <li>RDBMS가 Scale-Out이 가능한지에 관한 답은 CAP 이론을 공부해야함</li>
  <li>Relational databases are designed to run on a single server in order to maintain the integrity of the table mappings and avoid the problems of distributed computing.</li>
  <li>RDBMS가 Scale-out이 힘들다면 Redshift는 뭐지?</li>
</ul>

<p>Today, the evolution of relational databases allows them to use more complex architectures, relying on a “master-slave” model in which the “slaves” are additional servers that can handle parallel processing and replicated data, or data that is “sharded” (divided and distributed among multiple servers, or hosts) to ease the workload on the master server.</p>

<p>Other enhancements to relational databases such as using shared storage, in-memory processing, better use of replicas, distributed caching, and other new and ‘innovative’ architectures have certainly made relational databases more scalable. Under the covers, however, it is not hard to find a single system and a single point-of-failure (For example, Oracle RAC is a “clustered” relational database that uses a cluster-aware file system, but there is still a shared disk subsystem underneath). Often, the high costs of these systems is prohibitive as well, as setting up a single data warehouse can easily go over a million dollars.</p>

<p>The enhancements to relational databases also come with other big trade-offs as well. For example, when data is distributed across a relational database it is typically based on pre-defined queries in order to maintain performance. In other words, flexibility is sacrificed for performance.</p>

<p>Additionally, relational databases are not designed to scale back down—they are highly inelastic. Once data has been distributed and additional space allocated, it is almost impossible to “undistribute” that data.</p>

<p>NoSQL databases are designed for massive scale on distributed systems (usually hundreds of Terabytes rather than tens of Gigabytes). They can scale-out “horizontally,” meaning that they run on multiple servers that work together, each sharing part of the load.</p>

<p>Using this approach, a NoSQL database can operate across hundreds of servers, petabytes of data, and billions of documents—and still manage to process tens of thousands of transactions per second. And it can do all of this on inexpensive commodity (i.e. cheaper) hardware operating in any environment (i.e. cloud optimized!). Another benefit is that if one node fails, the others can pick up the workload, thus eliminating a single point of failure.</p>

<p>Massive scale is impressive, but what is perhaps even more important is elasticity. Not all NoSQL databases are elastic. MarkLogic has a unique architecture that make it possible to quickly and easily add or remove nodes in a cluster so that the database stays in line with performance needs. There is not any complex sharding of data or architectural workarounds—data is automatically rebalanced across a cluster when nodes are added or removed. This also makes administration much easier, making it possible for one DBA to manage for data and with fewer headaches.</p>

<h1 id="주요-데이터베이스간-비교">주요 데이터베이스간 비교</h1>

<h2 id="mysql-vs-hive-vs-redshift">MySQL vs Hive vs Redshift</h2>

<h2 id="mongodb-vs-cassandra-vs-elasticsearch">MongoDB vs Cassandra vs ElasticSearch</h2>

<h2 id="dynamodb-vs-hbase-vs-redis">DynamoDB vs HBase vs Redis</h2>

<ul>
  <li><a href="https://docs.aws.amazon.com/whitepapers/latest/comparing-dynamodb-and-hbase-for-nosql/amazon-dynamodb-overview.html" target="_blank">AWS whitepapaer: Comparing the Use of Amazon DynamoDB and Apache HBase for NoSQL</a></li>
</ul>

<h1 id="youtube">Youtube</h1>

<iframe width="560" height="315" src="https://www.youtube.com/embed/FX5iWHFn1v0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p><img src="/images/data_engineering_5.png" alt="" /></p>

<p><img src="/images/data_engineering_6.png" alt="" /></p>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="https://db-engines.com/en/systems" target="_blank">DB Engine 비교</a></li>
  <li><a href="https://aws.amazon.com/ko/nosql/in-memory/" target="_blank">AWS, What Is an In-Memory Database?</a></li>
  <li><a href="https://www.scylladb.com/glossary/wide-column-database/" target="_blank">SCYLLA, Wide-column Database</a></li>
  <li><a href="https://stackoverflow.com/questions/62010368/what-exactly-is-a-wide-column-store" target="_blank">stackoverflow, What exactly is a wide column store?</a></li>
  <li><a href="https://stackoverflow.com/questions/27157227/can-relational-database-scale-horizontally" target="_blank">stackoverflow, Can relational database scale horizontally</a></li>
  <li><a href="https://stackoverflow.com/questions/48825977/what-keeps-relational-databases-from-horizontal-scaling" target="_blank">What Keeps Relational Databases From Horizontal Scaling?</a></li>
  <li><a href="https://www.marklogic.com/blog/relational-databases-scale/" target="_blank">MATT ALLEN, Relational Databases Are Not Designed For Scale</a></li>
  <li><a href="https://asfirstalways.tistory.com/66">JBee, Scale Up, Scale Out, Sharding</a></li>
</ul>
:ET