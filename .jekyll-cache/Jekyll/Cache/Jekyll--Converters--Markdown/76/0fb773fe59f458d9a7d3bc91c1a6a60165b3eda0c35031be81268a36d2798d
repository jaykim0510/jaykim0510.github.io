I"/<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#document" id="markdown-toc-document">Document</a></li>
  <li><a href="#index" id="markdown-toc-index">Index</a></li>
  <li><a href="#inverted-index" id="markdown-toc-inverted-index">Inverted Index</a></li>
  <li><a href="#mapping" id="markdown-toc-mapping">Mapping</a></li>
  <li><a href="#template" id="markdown-toc-template">Template</a></li>
  <li><a href="#analyzer" id="markdown-toc-analyzer">Analyzer</a></li>
  <li><a href="#query-dsl" id="markdown-toc-query-dsl">Query DSL</a></li>
  <li><a href="#shard" id="markdown-toc-shard">Shard</a></li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<p><img src="/images/es_elem.png" alt="" /></p>

<h1 id="document">Document</h1>

<ul>
  <li>여러 개의 필드로 구성된 하나의 데이터</li>
  <li>Index에 JSON 형태로 저장</li>
  <li>RDBMS의 Row 또는 Record와 유사한 개념</li>
</ul>

<h1 id="index">Index</h1>

<ul>
  <li>인덱스는 도큐먼트를 저장하는 논리적 단위</li>
  <li>실제로 존재하지 않으며, 역색인 자료구조와도 관련 없음</li>
  <li>도큐먼트를 논리적으로 구분하는 것이 목적</li>
  <li>엘라스틱 서치에서 Index는 여러 곳에서 혼용되고 있음
    <ul>
      <li>Index: 도큐먼트의 논리적인 집합</li>
      <li>인덱싱: 도큐먼트를 인덱스에 저장</li>
      <li>색인: 도큐먼트가 분석기에 의해 토큰들로 변환되어 Inverted Index에 저장되는 과정</li>
    </ul>
  </li>
</ul>

<h1 id="inverted-index">Inverted Index</h1>

<ul>
  <li>도큐먼트를 인덱싱(삽입) 했을 때 분석기(Analyzer)에 의해 만들어진 용어(term)들이 색인되는 자료구조</li>
  <li>엘라스틱서치의 검색 속도를 빠르게 해주는 자료구조</li>
  <li>Inverted Index를 구현하는 자료구조에는 B-Tree, Hash 인덱스 등이 있음</li>
</ul>

<h1 id="mapping">Mapping</h1>

<ul>
  <li>데이터 모델링</li>
  <li>RDBMS의 스키마와 비슷한 개념</li>
  <li>NoSQL의 유연한 스키마 특성을 위해 자동으로 매핑해주는 것을 다이나믹 매핑이라고함</li>
  <li>데이터 타입, 분석기 종류 등을 명시하여 성능 최적화와 데이터의 정확성을 지키는 방법을 명시적인 매핑이라고함</li>
  <li>인덱스 매핑이 정해지면 새로운 필드를 추가할 수 있으나, 이미 정의된 필드를 수정하거나 삭제할 수는 없다</li>
  <li>필드 이름을 변경하거나 데이터 타입을 변경하기 위해서는 새로운 인덱스를 만들거나 reindex API를 이용해야 한다</li>
  <li>매핑에는 properties, analyzer, format 과 같은 파라미터가 있다</li>
  <li>매핑 파라미터, 데이터 타입</li>
  <li>멀티필드: 하나의 필드를 여러 용도로 사용할 수 있게 해준다</li>
  <li>(ex. match query를 하고 싶을 때는 text타입, 집계나 정렬, term query를 하고 싶을 때는 keyword 타입)</li>
</ul>

<h1 id="template">Template</h1>

<ul>
  <li>동일한 복수의 인덱스를 만들 때 사용</li>
  <li>관리 편의성, 성능 등을 위해 인덱스를 파티셔닝하는 일이 많은데 이 때 파티셔닝되는 인덱스들은 설정이 같아야함</li>
  <li>템플릿에서 사용하는 파라미터는 index_patterns, priority, template 이 대표적</li>
  <li>template 안에는 settings, mappings 파라미터가 대표적</li>
  <li>템플릿을 만들기 전에 이미 존재하던 인덱스는 템플릿 패턴과 일치하더라도 템플릿이 적용되지 않음</li>
  <li>7.8버전 이후로는 우선순위가 높은 템플릿만 적용됨</li>
</ul>

<h1 id="analyzer">Analyzer</h1>

<ul>
  <li>전문 검색에서 양질의 결과를 얻기 위해서는 문자열을 나누는 기준이 중요</li>
  <li>엘라스틱서치는 text 타입의 문자열을 분석기를 이용해 용어(term) 형태로 인덱스에 저장한다</li>
  <li>(검색에 사용되는 단위가 바로 용어(term)이다)</li>
  <li>분석기는 캐릭터 필터, 토크나이저, 토큰 필터로 구성 (토크나이저만 필수 요소, 나머지는 선택 요소)</li>
  <li>캐릭터 필터: 입력받은 문자열을 변경하거나 불필요한 문자들 제거 (html 태그 등)</li>
  <li>토크나이저: 문자열을 토큰으로 분리. 분리할 때 토큰의 순서나 시작, 끝 위치도 기록</li>
  <li>토큰 필터: 분리된 토큰에 대해 필터링 작업. 대소문자 구분, 형태소 분석 등의 작업. 토큰 필터를 거친 후의 토큰이 인덱스에 저장되면 이를 용어(term)라고 한다</li>
  <li>분석기 종류에는 대표적으로 standard, simple, whitespace, stop 등이 있다</li>
  <li>분석기 대신 토크나이저만 적용해도 되고, 토크나이저에 각종 필터를 추가할 수도 있다</li>
</ul>

<p><img src="/images/es_analyzer.png" alt="" /></p>

<h1 id="query-dsl">Query DSL</h1>

<ul>
  <li>엘라스틱서치의 가장 큰 특징은 검색 엔진</li>
  <li>검색을 위한 SQL Like 언어 (RDBMS의 SELECT 쿼리문과 같은 역할)</li>
</ul>

<h1 id="shard">Shard</h1>

<ul>
  <li>분산 처리/복제를 위한 단위</li>
  <li>Primary 샤드와 Replica 샤드가 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 샤딩은 Document와 Inverted Index를 함께 샤딩하는 것 같다
- 어디서는 Inverted Index라고 얘기하고, 어디서는 Document라고 한다
- 정확히 둘 다 샤딩한다고 얘기하는 곳은 못봤다
</code></pre></div></div>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/documents-indices.html" target="_blank">elastic 공식문서, Data in: documents and indices</a></li>
  <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/scalability.html" target="_blank">elastic 공식문서, Scalability and resilience</a></li>
  <li><a href="https://www.instaclustr.com/blog/opensearch-and-elasticsearch-architecture/" target="_blank">instaclustr, A Comprehensive Guide to OpenSearch and Elasticsearch™ Architecture</a></li>
  <li><a href="https://medium.com/geekculture/elasticsearch-internals-4c4c9ec077fa" target="_blank">Shivanshu Goyal, Elasticsearch and its internals working</a></li>
  <li><a href="https://stackoverflow.com/questions/15426441/understanding-segments-in-elasticsearch" target="_blank">stackoverflow, Understanding Segments in Elasticsearch</a></li>
  <li><a href="https://stackoverflow.com/questions/59064364/elasticsearch-when-document-is-stored-does-it-get-split-up-into-different-shard" target="_blank">stackoverflow, Elasticsearch, when document is stored does it get split up into different shards?</a></li>
  <li><a href="https://trackit.io/trackit-whitepapers/accelerate-your-metadata-search-from-60-seconds-to-4-seconds-by-adding-elasticsearch-to-your-architecture/" target="_blank">trackit, Accelerate your metadata search from 60 seconds to 4 seconds by adding Elasticsearch to your architecture</a></li>
</ul>
:ET