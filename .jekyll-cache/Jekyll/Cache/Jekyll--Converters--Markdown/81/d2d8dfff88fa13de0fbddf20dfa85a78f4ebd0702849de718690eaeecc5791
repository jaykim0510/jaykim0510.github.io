I"	<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#링크드-리스트" id="markdown-toc-링크드-리스트">링크드 리스트</a></li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<h1 id="링크드-리스트">링크드 리스트</h1>

<ul>
  <li>포인터를 기반으로 원소들이 서로 연결되어 있다</li>
  <li>메모리 공간에서 원소들이 서로 흩어져 있다</li>
  <li>정적 배열과 같이 가용용량을 미리 정의할 필요가 없다</li>
  <li>동적 배열과 같이 가용용량이 꽉 찼을 때 다른 메모리 공간으로 옮기고 더블링할 필요도 없다</li>
  <li>하지만 일반적으로 접근/삽입/삭제 연산의 시간복잡도가 모두 O(n)이다</li>
</ul>

<p>하지만 특정 상황에서 유용한 경우가 있다. 시간 복잡도를 조금 더 세분화 해서 살펴보자.</p>

<table>
  <tbody>
    <tr>
      <td><strong>연산</strong></td>
      <td><strong>배열</strong></td>
      <td><strong>싱글 링크드 리스트</strong></td>
      <td><strong>더블리 링크드 리스트</strong></td>
    </tr>
    <tr>
      <td>맨 앞 삽입</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>맨 앞 삭제</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>맨 뒤 삽입</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>맨 뒤 삭제</td>
      <td>O(1)</td>
      <td>O(n)</td>
      <td>O(1)</td>
    </tr>
  </tbody>
</table>

<p>스택(Stack)과 큐(Queue)는 맨 앞/뒤 삽입/삭제 연산이 활발하다.</p>

<ul>
  <li>스택은 맨 뒤 삽입/삭제가 중요한데, 이는 배열로도 O(1)의 시간 복잡도를 얻을 수 있다</li>
  <li>큐는 맨 뒤 삽입, 맨 앞 삭제가 중요한데 이 때는 링크드 리스트가 필요하다</li>
</ul>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="https://stackoverflow.com/questions/30516897/what-is-the-best-data-structure-to-implement-a-queue" target="_blank">What is the best data structure to implement a queue?</a></li>
  <li><a href="https://www.naukri.com/learning/articles/queue-data-structure-types-implementation-applications/" target="_blank">Queue Data Structure: Types, Implementation, Applications</a></li>
  <li><a href="https://realpython.com/python-deque/" target="_blank">Python’s deque: Implement Efficient Queues and Stacks</a></li>
</ul>
:ET