I"Ø<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#consistent-hashing" id="markdown-toc-consistent-hashing">Consistent Hashing</a>    <ul>
      <li><a href="#why-hashing" id="markdown-toc-why-hashing">Why hashing?</a></li>
    </ul>
  </li>
</ul>

<hr />
<h1 id="consistent-hashing">Consistent Hashing</h1>

<p>Hash is basically a function that takes a value and converts it into another value of a specific format. Hash functions that are commonly used are MD5, SHA1, SHA256, etc.</p>

<h2 id="why-hashing">Why hashing?</h2>
<p>Suppose you build a distributed cache, where the data is distributed over various nodes, sometimes spanning multiple data centers. When we want to store the data for a user, we need to decide which node will cache this data. And when we want to retrieve this cached value, we must query the same node. So let us use a simple hash function for this again.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hash(user) = Sum(ASCII value of all characters in name) % 5
</code></pre></div></div>

<p>Where 5 is the number of nodes. This way, the hashes generated for users will be as follows:</p>

<p><img src="/images/system_design_8.png" alt="" /></p>

<p>Since hash(Alice) is 0, Aliceâ€™s data will be stored in node 0. Similarly, Bobâ€™s data will be stored in node 1 and Eveâ€™s in 4. Now when you need to look up the information for Alice, you will use the same hash function to determine which node to query. Since hash(Alice) equals 0, you will query node 0 and fetch the information.</p>

<p>But there is a problem with this solution. This model is not scalable. If the traffic increases and you want to add a new node, the formula to calculate the hash will get updated to</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hash(user) = Sum(ASCII value of all characters in name) % 6
</code></pre></div></div>

<p>And similarly hash(Alice) will get updated to 2. So now you will search for Aliceâ€™s information in node 2, but the information is actually stored in node 0 so you wonâ€™t find it.</p>

<p>To fix this, you will need to rehash all the data every time a node is added or removed, and once rehashed, you need to move the data to their respective new nodes, which could be across different data centers. This is not a very good solution as it uses up a lot of CPU resources and bandwidth.</p>

<p>This is where Consistent Hashing comes in. Consistent Hashing tries to optimize the system in such a way that:</p>

<ul>
  <li>You donâ€™t need to move around all the data while adding or removing nodes.</li>
  <li>There will be minimal movement of data as if a node is removed, the data from that node will be supported by another node. Similarly, when a node is added, some data will be mapped to it as you donâ€™t want it to sit idle.</li>
  <li>You can have a nearly even distribution of data across all machines.</li>
</ul>
:ET