I"7#<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#binary-tree-이진-트리" id="markdown-toc-binary-tree-이진-트리">Binary Tree (이진 트리)</a></li>
  <li><a href="#perfect-binary-tree-포화-이진-트리-complete-binary-tree-완전-이진-트리-full-binary-tree-정-이진-트리" id="markdown-toc-perfect-binary-tree-포화-이진-트리-complete-binary-tree-완전-이진-트리-full-binary-tree-정-이진-트리">Perfect Binary Tree (포화 이진 트리), Complete Binary Tree (완전 이진 트리), Full Binary Tree (정 이진 트리)</a></li>
  <li><a href="#bst-binary-search-tree" id="markdown-toc-bst-binary-search-tree">BST (Binary Search Tree)</a></li>
  <li><a href="#red-black-tree" id="markdown-toc-red-black-tree">Red Black Tree</a>    <ul>
      <li><a href="#red-black-tree-의-정의" id="markdown-toc-red-black-tree-의-정의">Red-Black Tree 의 정의</a></li>
      <li><a href="#red-black-tree-의-특징" id="markdown-toc-red-black-tree-의-특징">Red-Black Tree 의 특징</a></li>
      <li><a href="#삽입" id="markdown-toc-삽입">삽입</a></li>
      <li><a href="#삭제" id="markdown-toc-삭제">삭제</a></li>
    </ul>
  </li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<p>트리는 스택이나 큐와 같은 선형 구조가 아닌 비선형 자료구조이다. 트리는 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다. 이 트리라는 자료구조는 표현에 집중한다. 무엇인가를 저장하고 꺼내야 한다는 사고에서 벗어나 트리라는 자료구조를 바라보자.</p>

<h1 id="binary-tree-이진-트리">Binary Tree (이진 트리)</h1>
<p>루트 노드를 중심으로 두 개의 서브 트리(큰 트리에 속하는 작은 트리)로 나뉘어 진다. 또한 나뉘어진 두 서브 트리도 모두 이진 트리어야 한다. 재귀적인 정의라 맞는듯 하면서도 이해가 쉽지 않을 듯하다. 한 가지 덧붙이자면 공집합도 이진 트리로 포함시켜야 한다. 그래야 재귀적으로 조건을 확인해갔을 때, leaf node 에 다다랐을 때, 정의가 만족되기 때문이다. 자연스럽게 노드가 하나 뿐인 것도 이진 트리 정의에 만족하게 된다.</p>

<p>트리에서는 각 층별로 숫자를 매겨서 이를 트리의 Level(레벨)이라고 한다. 레벨의 값은 0 부터 시작하고 따라서 루트 노드의 레벨은 0 이다. 그리고 트리의 최고 레벨을 가리켜 해당 트리의 height(높이)라고 한다.</p>

<h1 id="perfect-binary-tree-포화-이진-트리-complete-binary-tree-완전-이진-트리-full-binary-tree-정-이진-트리">Perfect Binary Tree (포화 이진 트리), Complete Binary Tree (완전 이진 트리), Full Binary Tree (정 이진 트리)</h1>
<ul>
  <li>모든 레벨이 꽉 찬 이진 트리를 가리켜 <strong>포화 이진 트리</strong>라고 한다.</li>
  <li>위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리를 가리켜 <strong>완전 이진 트리</strong>라고 한다.</li>
  <li>모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진 트리를 가리켜 <strong>정 이진 트리</strong>라고 한다.</li>
  <li>배열로 구성된 Binary Tree는 root 인덱스를 1이라 할 때, 노드 i의 부모 노드 인덱스는 i/2, 자식 노드의 인덱스는 각각 2i 와 2i + 1 로 나타낼 수 있다</li>
</ul>

<h1 id="bst-binary-search-tree">BST (Binary Search Tree)</h1>
<p>효율적인 탐색을 위해서는 어떻게 찾을까만 고민해서는 안된다. 그보다는 효율적인 탐색을 위한 저장방법이 무엇일까를 고민해야 한다. 이진 탐색 트리는 이진 트리의 일종이다. 단 이진 탐색 트리에는 데이터를 저장하는 규칙이 있다. 그리고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.</p>

<ul>
  <li>규칙 1. 이진 탐색 트리의 노드에 저장된 키는 유일하다.</li>
  <li>규칙 2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.</li>
  <li>규칙 3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.</li>
  <li>규칙 4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.</li>
</ul>

<p>이진 탐색 트리의 탐색 연산은 O(log n)의 시간 복잡도를 갖는다. 사실 정확히 말하면 O(h)라고 표현하는 것이 맞다. 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두 배씩 증가하기 때문이다. 하지만 이러한 이진 탐색 트리는 Skewed Tree(편향 트리)가 될 수 있다. 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생하기 때문이다. 이럴 경우 성능에 영향을 미치게 되며, 탐색의 Worst Case 가 되고 시간 복잡도는 O(n)이 된다.</p>

<p>배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생한다. 이를 해결하기 위해 Rebalancing 기법이 등장하였다. 균형을 잡기 위한 트리 구조의 재조정을 Rebalancing이라 한다. 이 기법을 구현한 트리에는 여러 종류가 존재하는데 그 중에서 하나가 뒤에서 살펴볼 <strong>Red-Black Tree</strong>이다.</p>

<h1 id="red-black-tree">Red Black Tree</h1>
<p>RBT(Red-Black Tree)는 <strong>BST를 기반</strong>으로 하는 트리 형식의 자료구조이다. 결론부터 말하자면 Red-Black Tree에 데이터를 저장하게 되면 Search, Insert, Delete 에 O(log n)의 시간 복잡도가 소요된다. 동일한 노드의 개수일 때, <strong>depth를 최소화</strong>하여 시간 복잡도를 줄이는 것이 핵심 아이디어이다. 동일한 노드의 개수일 때, depth가 최소가 되는 경우는 tree가 <strong>완전 이진트리(complete binary tree)</strong> 인 경우이다.</p>

<p>각 노드에 색깔을 저장하는 공간을 추가하여 색깔을 기준으로 균형을 맞추는 트리입니다.</p>

<h2 id="red-black-tree-의-정의">Red-Black Tree 의 정의</h2>
<p>Red-Black Tree 는 다음의 성질들을 만족하는 BST 이다.</p>

<p><img src="/images/red_black_tree_1.png" alt="" /></p>

<ul>
  <li>각 노드는 빨간색(Red) 또는 검정색(Black)이라는 색깔을 갖는다.</li>
  <li>루트 노드는 검정색(Black)이다. 모든 리프(NIL, null leaf)도 Black이다.</li>
  <li>어떤 노드의 색깔이 Red라면 두 개의 children 의 색깔은 모두 Black 이다.</li>
  <li>각 노드로부터 그 노드의 후손 리프로 가는 경로들은 모두 같은 수의 Black 노드를 포함한다 (해당 노드에서 갈 수 있는 모든 리프 노드까지의 Black-height가 같다)</li>
</ul>

<h2 id="red-black-tree-의-특징">Red-Black Tree 의 특징</h2>

<ul>
  <li>Binary Search Tree 이므로 BST 의 특징을 모두 갖는다.</li>
  <li>Root node 부터 leaf node 까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2 보다 크지 않다. 이러한 상태를 balanced 상태라고 한다.</li>
  <li>노드의 child 가 없을 경우 child 를 가리키는 포인터는 NIL 값을 저장한다. 이러한 NIL 들을 leaf node 로 간주한다.</li>
</ul>

<p>RBT 는 BST 의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어진 자료구조이다. 이를 어떻게 해결한 것인가?</p>

<h2 id="삽입">삽입</h2>
<p>우선 BST 의 특성을 유지하면서 노드를 삽입을 한다. 그리고 삽입된 노드의 색깔을 RED 로 지정한다. Red 로 지정하는 이유는 Black-Height 변경을 최소화하기 위함이다. 삽입 결과 RBT 의 특성 위배(violation)시 노드의 색깔을 조정하고, Black-Height 가 위배되었다면 rotation 을 통해 height 를 조정한다. 이러한 과정을 통해 RBT 의 동일한 height 에 존재하는 internal node 들의 Black-height 가 같아지게 되고 최소 경로와 최대 경로의 크기 비율이 2 미만으로 유지된다.</p>

<h2 id="삭제">삭제</h2>
<p>삭제도 삽입과 마찬가지로 BST 의 특성을 유지하면서 해당 노드를 삭제한다. 삭제될 노드의 child 의 개수에 따라 rotation 방법이 달라지게 된다. 그리고 만약 지워진 노드의 색깔이 Black 이라면 Black-Height 가 1 감소한 경로에 black node 가 1 개 추가되도록 rotation 하고 노드의 색깔을 조정한다. 지워진 노드의 색깔이 red 라면 Violation 이 발생하지 않으므로 RBT 가 그대로 유지된다</p>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner" target="_blank">JaeYeopHan/Interview_Question_for_Beginner</a></li>
  <li><a href="https://nesoy.github.io/articles/2018-08/Algorithm-RedblackTree" target="_blank">nesoy, RedBlack Tree에 대해</a></li>
</ul>
:ET