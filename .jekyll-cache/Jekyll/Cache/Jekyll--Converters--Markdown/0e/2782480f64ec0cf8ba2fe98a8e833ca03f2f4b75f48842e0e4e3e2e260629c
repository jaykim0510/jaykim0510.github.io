I"ˆ<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#optimization-overview" id="markdown-toc-optimization-overview">Optimization Overview</a></li>
  <li><a href="#things-to-consider-for-optimization" id="markdown-toc-things-to-consider-for-optimization">Things to Consider for Optimization</a></li>
  <li><a href="#optimizing-select-statements" id="markdown-toc-optimizing-select-statements">Optimizing SELECT Statements</a>    <ul>
      <li><a href="#where-clause-optimization" id="markdown-toc-where-clause-optimization">WHERE Clause Optimization</a></li>
      <li><a href="#group-by-optimization" id="markdown-toc-group-by-optimization">GROUP BY Optimization</a></li>
    </ul>
  </li>
  <li><a href="#ì°¸ê³ " id="markdown-toc-ì°¸ê³ ">ì°¸ê³ </a></li>
</ul>

<hr />
<h1 id="optimization-overview">Optimization Overview</h1>

<p>Database performance depends on several factors at the database level, such as tables, queries, and configuration settings. These software constructs result in CPU and I/O operations at the hardware level, which you must minimize and make as efficient as possible.</p>

<h1 id="things-to-consider-for-optimization">Things to Consider for Optimization</h1>

<ul>
  <li>
    <p>Are the tables structured properly? In particular, do the columns have the right data types, and does each table have the appropriate columns for the type of work? For example, applications that perform frequent updates often have many tables with few columns, while applications that analyze large amounts of data often have few tables with many columns.</p>
  </li>
  <li>
    <p>Are the right indexes in place to make queries efficient?</p>
  </li>
  <li>
    <p>Are you using the appropriate storage engine for each table, and taking advantage of the strengths and features of each storage engine you use? In particular, the choice of a transactional storage engine such as InnoDB or a nontransactional one such as MyISAM can be very important for performance and scalability.</p>
  </li>
  <li>
    <p>Does each table use an appropriate row format? This choice also depends on the storage engine used for the table. In particular, compressed tables use less disk space and so require less disk I/O to read and write the data. Compression is available for all kinds of workloads with InnoDB tables, and for read-only MyISAM tables.</p>
  </li>
  <li>
    <p>Does the application use an appropriate locking strategy? For example, by allowing shared access when possible so that database operations can run concurrently, and requesting exclusive access when appropriate so that critical operations get top priority. Again, the choice of storage engine is significant. The InnoDB storage engine handles most locking issues without involvement from you, allowing for better concurrency in the database and reducing the amount of experimentation and tuning for your code.</p>
  </li>
  <li>
    <p>Are all memory areas used for caching sized correctly? That is, large enough to hold frequently accessed data, but not so large that they overload physical memory and cause paging. The main memory areas to configure are the InnoDB buffer pool and the MyISAM key cache.</p>
  </li>
</ul>

<h1 id="optimizing-select-statements">Optimizing SELECT Statements</h1>

<h2 id="where-clause-optimization">WHERE Clause Optimization</h2>

<ul>
  <li>Use Indexes Where Appropriate</li>
  <li>Avoid % Wildcard in a Predicate</li>
  <li>Avoid using a function in the predicate of a query</li>
</ul>

<h2 id="group-by-optimization">GROUP BY Optimization</h2>

<p>GROUP BY ì ˆì„ ë§Œì¡±ì‹œí‚¤ëŠ” ê°€ì¥ ì¼ë°˜ì ì¸ ë°©ë²•ì€ ì „ì²´ í…Œì´ë¸”ì„ ìŠ¤ìº”í•˜ì—¬ ê° ê·¸ë£¹ì˜ ëª¨ë“  í–‰ì´ ì—°ì†ë˜ëŠ” ìƒˆ ì„ì‹œ í…Œì´ë¸”ì„ ë§Œë“  ë‹¤ìŒ ì´ ì„ì‹œ í…Œì´ë¸”ì„ ì‚¬ìš©í•˜ì—¬ ê·¸ë£¹ì„ ê²€ìƒ‰í•˜ê³  ì§‘ê³„ í•¨ìˆ˜ë¥¼ ì ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤</p>

<p>In some cases, MySQL is able to do much better than that and avoid creation of temporary tables by <strong>using index access</strong>.</p>

<p>GROUP BYì— ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ê°€ì¥ ì¤‘ìš”í•œ ì „ì œ ì¡°ê±´ì€ ëª¨ë“  GROUP BY ì—´ì´ ë™ì¼í•œ ì¸ë±ìŠ¤ì˜ ì†ì„±ì„ ì°¸ì¡°í•˜ê³  ì¸ë±ìŠ¤ê°€ í•´ë‹¹ í‚¤ë¥¼ ìˆœì„œëŒ€ë¡œ ì €ì¥í•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤(ì˜ˆ: BTREE ì¸ë±ìŠ¤ì˜ ê²½ìš° í•´ë‹¹ë˜ì§€ë§Œ í•´ì‹œ ì¸ë±ìŠ¤ì˜ ê²½ìš° í•´ë‹¹ë˜ì§€ ì•ŠìŒ). ì„ì‹œ í…Œì´ë¸”ì˜ ì‚¬ìš©ì´ ì¸ë±ìŠ¤ ì•¡ì„¸ìŠ¤ë¡œ ëŒ€ì²´ë  ìˆ˜ ìˆëŠ”ì§€ ì—¬ë¶€ë„ ì¿¼ë¦¬ì— ì‚¬ìš©ë˜ëŠ” ì¸ë±ìŠ¤ì˜ ë¶€ë¶„, ì´ëŸ¬í•œ ë¶€ë¶„ì— ëŒ€í•´ ì§€ì •ëœ ì¡°ê±´ ë° ì„ íƒí•œ ì§‘ê³„ í•¨ìˆ˜ì— ë”°ë¼ ë‹¬ë¼ì§‘ë‹ˆë‹¤.</p>

<p>There are two ways to execute a GROUP BY query through index access, as detailed in the following sections.</p>

<ul>
  <li>The first method applies the grouping operation together with all range predicates (if any)</li>
  <li>The second method first performs a range scan, and then groups the resulting tuples.</li>
</ul>

<h1 id="ì°¸ê³ ">ì°¸ê³ </h1>

<ul>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/select-optimization.html" target="_blank">MySQL ê³µì‹ë¬¸ì„œ: Optimizing SELECT Statements</a></li>
  <li><a href="https://phoenixnap.com/kb/improve-mysql-performance-tuning-optimization" target="_blank">MySQL Performance Tuning and Optimization Tips</a></li>
</ul>
:ET