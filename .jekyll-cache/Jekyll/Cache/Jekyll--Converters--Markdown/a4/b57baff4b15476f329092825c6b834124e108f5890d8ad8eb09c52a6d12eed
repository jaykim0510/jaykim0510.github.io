I"­/<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#kubernetes-basics" id="markdown-toc-kubernetes-basics">Kubernetes Basics</a></li>
  <li><a href="#localhost-ip-address-127001" id="markdown-toc-localhost-ip-address-127001">Localhost (IP address 127.0.0.1)</a></li>
  <li><a href="#pod-network" id="markdown-toc-pod-network">Pod network</a></li>
  <li><a href="#service-network" id="markdown-toc-service-network">Service network</a></li>
  <li><a href="#inside-and-outside-traffic" id="markdown-toc-inside-and-outside-traffic">Inside and outside traffic</a>    <ul>
      <li><a href="#nodeport-type" id="markdown-toc-nodeport-type">NodePort type</a></li>
      <li><a href="#loadbalancer-type" id="markdown-toc-loadbalancer-type">LoadBalancer type</a></li>
      <li><a href="#ingress-resource" id="markdown-toc-ingress-resource">Ingress resource</a></li>
    </ul>
  </li>
</ul>

<hr />

<p><a href="https://developer.ibm.com/articles/kubernetes-networking-what-you-need-to-know/" target="_blank">ì›ë¬¸: Kubernetes networking for developers - IBM developers</a></p>

<p>ë¶ˆê³¼ ëª‡ ë…„ ì „ê¹Œì§€ë§Œ í•˜ë”ë¼ë„ ê°œë°œìë“¤ì´ ë„¤íŠ¸ì›Œí¬ì— ëŒ€í•´ ì•Œì•„ì•¼ í•  ì§€ì‹ì€ ê·¸ë ‡ê²Œ ë§ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ê·¸ë“¤ì€ ê·¸ë“¤ì˜ ì½”ë“œë¥¼ ì‘ì„±í•˜ê³  ë¡œì»¬ì—ì„œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸í•œ í›„ í…ŒìŠ¤íŠ¸ë‚˜ ì„œë¹„ìŠ¤ë¥¼ ìœ„í•œ ì„œë²„ì— ë°°í¬í•  ìˆ˜ ìˆì—ˆìœ¼ë©´ ëì—ˆìŠµë‹ˆë‹¤.</p>

<p>ê·¸ëŸ¬ë‚˜ ì‹œê°„ì´ ì§€ë‚˜ë©´ì„œ ì»¨í…Œì´ë„ˆ ê¸°ìˆ ì´ ì ì  ë°œì „ë˜ì–´ê°€ë©° ì´ëŸ° ì¶”ì„¸ê°€ ì•½ê°„ ë³€í•˜ê¸° ì‹œì‘í–ˆìŠµë‹ˆë‹¤. ì´ë²ˆ ê¸€ì„ í†µí•´ ì»¨í…Œì´ë„ˆ ê¸°ë°˜ì˜ ë°°í¬í™˜ê²½ì—ì„œ ê°œë°œìë“¤ì´ ì•Œì•„ë‘ë©´ ì¢‹ì€ ë„¤íŠ¸ì›Œí¬ ì§€ì‹ì— ëŒ€í•´ ì•Œì•„ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.</p>

<h1 id="kubernetes-basics">Kubernetes Basics</h1>

<p>ì»¨í…Œì´ë„ˆëŠ” í•œ ê°œì˜ ì–´í”Œë¦¬ì¼€ì´ì…˜ ë˜ëŠ” í”„ë¡œì„¸ìŠ¤ë¡œ ì´ë“¤ì„ ì‹¤í–‰ì‹œí‚¤ê¸° ìœ„í•´ í•„ìš”í•œ ëª¨ë“  ê²ƒë“¤ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì–´í”Œë¦¬ì¼€ì´ì…˜ ê´€ì ì—ì„œ ì»¨í…Œì´ë„ˆëŠ” ë§ˆì¹˜ ì„œë²„ìœ„ì— ë™ì‘ì¤‘ì¸ í•˜ë‚˜ì˜ ìš´ì˜ì²´ì œì²˜ëŸ¼ ë³´ì…ë‹ˆë‹¤. ì»¨í…Œì´ë„ˆëŠ” ì»¨í…Œì´ë„ˆë§Œì˜ ë„¤íŠ¸ì›Œí¬ ì¸í„°í˜ì´ìŠ¤, íŒŒì¼ ì‹œìŠ¤í…œ ë“± í•„ìš”í•œ ëª¨ë“  ê²ƒë“¤ì„ ê°–ì¶”ê³  ìˆìŠµë‹ˆë‹¤.</p>

<p>ì¿ ë²„ë„¤í‹°ìŠ¤ëŠ” ì´ëŸ¬í•œ ì»¨í…Œì´ë„ˆì˜ ì§‘í•©ìœ¼ë¡œ ì»¨í…Œì´ë„ˆëŠ” ì¿ ë²„ë„¤í‹°ìŠ¤ì˜ ì›Œì»¤ ë…¸ë“œ ì•ˆì—ì„œ ëŒì•„ê°‘ë‹ˆë‹¤. ë§Œì•½ í•­ìƒ í•¨ê»˜ ì„¤ì¹˜ë˜ì–´ì•¼ í•˜ëŠ” ë‘ ê°œì˜ ì–´í”Œë¦¬ì¼€ì´ì…˜ì´ ìˆë‹¤ë©´ ì´ ë‘ ê°œì˜ ì–´í”Œë¦¬ì¼€ì´ì…˜ì„ ê°€ì§„ ì»¨í…Œì´ë„ˆ ë‘ ê°œë¥¼ í•˜ë‚˜ì˜ <strong>íŒŒë“œ(Pod)</strong>ë¡œ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (íŒŒë“œëŠ” í™•ì¥ê°€ëŠ¥í•œ ë‹¨ìœ„ë¡œ ë³´í†µ íŠ¹ì • ë…¸ë“œì— ì¥ì• ê°€ ë°œìƒí•  ê²½ìš° íŒŒë“œì— ë¬¸ì œê°€ ìƒê¸°ëŠ” ê²½ìš°ë¥¼ ëŒ€ë¹„í•´, ì—¬ëŸ¬ ì›Œì»¤ ë…¸ë“œì— íŒŒë“œë¥¼ ë¶„ì‚° ë°°í¬í•©ë‹ˆë‹¤.)</p>

<p><img src="../../images/kube_31.png" alt="" /></p>

<h1 id="localhost-ip-address-127001">Localhost (IP address 127.0.0.1)</h1>
<p>All containers within a pod are running on the same worker node. Kubernetes can take advantage of this structure and give the entire pod a shared network namespace. A network namespace is a Linux kernel feature that allows network resources to be put into groups. Processes running within those groups can only see the network resources defined for their group. For example, processes running in Network Namespace A see one set of network resources, while processes running in Network Namespace B see another set. This approach is how Kubernetes isolates pods from each other on the worker node. For example, Pod A listening on port 80 should not keep Pod B from also listening on port 80.</p>

<p><img src="../../images/kube_32.png" alt="" /></p>

<p>Network namespaces matter because when all containers run in a pod, they all share the same network namespace. While containers inside the same pod can talk to each other over localhost, they canâ€™t listen on the same port.</p>

<h1 id="pod-network">Pod network</h1>
<p>Much like how virtual servers can be assigned an IP address, pods are assigned an IP address. Containers running in a pod can bind to ports on the pod IP address, just like processes running on a virtual server can bind to ports on its IP address. In this way, a Kubernetes pod is very much like a virtual server from a networking perspective.</p>

<p>The IP addresses used come from an addresses block known as the pod network. Each time a pod is spun up, Kubernetes pulls an available IP address from the pod network and assigns it to the pod before turning it on. Pods all appear to be on the same network and can communicate with each other over this network (by default). There are network policies that can limit what a pod can talk to, but by default they are free to talk to each other.</p>

<p>From a development perspective, there are a couple of points to note here. An IP address that is assigned to a pod stays with the pod until the pod is deleted. Therefore, if a container crashes and restarts, it has the same IP address as it did before it crashed. In contrast, when a pod is deleted, it loses its IP address all together.</p>

<p>Itâ€™s generally a bad development practice to depend on this behavior because pods are commonly deleted and created either during a scaling operation, or when rebalancing the pods in the cluster. Consider a common scenario: when a worker node dies, the pods that were running on the worker node are created again on another worker node, getting a new pod IP address.</p>

<p>The bottom line here is your application needs to be completely independent of IP addresses, or be able to handle IP address changes of application instances. Do not depend on your application IP address to remain static.</p>

<h1 id="service-network">Service network</h1>
<p>The previous section described how pod IP addresses are dynamic, and change as pods are created and deleted. So how then are pods expected to know where other pods are and communicate with each other? The answer is a Kubernetes Service. A Kubernetes Service is a definition that describes a domain name and which pods traffic is directed to. For example:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">web</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">my-app</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">web-server</span>
  <span class="na">ports</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">web</span>
    <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
    <span class="na">port</span><span class="pi">:</span> <span class="m">80</span>
    <span class="na">targetPort</span><span class="pi">:</span> <span class="m">80</span>
</code></pre></div></div>

<p>The previous service example would create a web.my-app.svc.cluster.local DNS entry that resolves to an IP address on the service network. The service network is similar to the pod network, except that the IPs are assigned to services, not pods. The IP address of the service stays with the service until the service is deleted. The service IP assigned balances the load of traffic to all pods that match the serviceâ€™s spec.selector definition. In the previous example, any pod with metadata.labels.app equal to web-server, would be considered to send traffic to on port 80.</p>

<p><img src="../../images/kube_33.png" alt="" /></p>

<p>By default, services are the ClusterIP type. However, the following types are supported:</p>

<ul>
  <li>ClusterIP</li>
  <li>NodePort</li>
  <li>LoadBalancer</li>
  <li>ExternalName</li>
</ul>

<p>Most likely, your application depends on external services or applications. Instead of the IP address of those endpoints, use domain names and let Kubernetes worry about the actual IP. So instead of configuring your application to talk to https://172.30.102.188/stuff, configure it to talk to https://web.my-app.svc.cluster.local/stuff and let Kubernetes address the other needed networking tasks.</p>

<p>If your application exposes an endpoint, you should expect to create a Kubernetes service to expose it to the cluster. Also note that you can include any combination of ports and protocols in a single service in case you need to listen on multiple ports.</p>

<h1 id="inside-and-outside-traffic">Inside and outside traffic</h1>
<p>So far, this article dealt with traffic within a Kubernetes cluster. This section discusses how services can communicate outside the cluster. Both the pod network and service network are address spaces that only exist within the Kubernetes cluster. You canâ€™t reach these addresses from the outside.</p>

<p>In order to accommodate external traffic, Kubernetes created constructs that allow its services to join with real address spaces outside the cluster. These constructs build on one another and are denoted by the service type (such as ClusterIP, NodePort, LoadBalancer). A service of the type NodePort includes the functionality of the type ClusterIP. A service of the type LoadBalancer includes the functionality of the type NodePort. (The only exception is ExternalName, which is not discussed in this article.)</p>

<h2 id="nodeport-type">NodePort type</h2>
<p>Each worker node in the cluster has one or more IP addresses assigned to it. These IP addresses are the physical IPs (instead of the virtualized pod and service networks) that the worker nodes communicate over. Worker nodes have a private IP assigned, but if your cluster is exposed to the oustide world, it might have both a private and a public IP address assigned.</p>

<p>When a service is of the type NodePort, it picks a random port with a range (default: 30000-32767) to expose the traffic on. This port is opened up on all worker nodes. When traffic hits that port, it balances the load of traffic to a pod, just like it does when the service is of type ClusterIP. NodePort. Effectively, it just binds a random port on all worker nodes to your service, allowing external services to communicate with it. Sending traffic to any worker node on that port gets the traffic to the right place.</p>

<h2 id="loadbalancer-type">LoadBalancer type</h2>
<p>While NodePort gets the job done, itâ€™s not very useful by itself. Itâ€™s not great to tell users to talk to you service at http://some.external.domain:31633/stuff. Kubernetes allows external load balancers to integrate by creating the service of the type LoadBalancer. The options available for this type are dependent on the cloud provider. Basically, it allows you to define an external IP address on a port of your choosing, and have that traffic automatically directed to the auto-assigned port on the worker node.</p>

<p>LoadBalancer type services are NodePort type services, except they orchestrate an external non-worker node IP to point to the randomly assigned port on the worker node.</p>

<p><img src="../../images/kube_34.png" alt="" /></p>

<p>Because the IP address used is external to the Kubernetes cluster, it doesnâ€™t matter if that IP is a public IP or a private IP. The behavior is the same.</p>

<h2 id="ingress-resource">Ingress resource</h2>
<p>Ingress is not a type of Kubernetes Service, but it works in conjunction with them. An ingress is a Kubernetes resource that allows HTTP/HTTPS traffic to be routed to services based on the HTTP routes in the request. It allows you to route https://my-domain.com/service_a to service_a.my-app.svc.cluster.local, and https://my-domain.com/service_b to service_b.my-app.svc.cluster.local.</p>

<p>For application design and development, the ingress resource can affect how you expose your applications to the outside world and affect the service architecture you decide to use.</p>
:ET