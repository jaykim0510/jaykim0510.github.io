I"3!<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#변수란-무엇인가-왜-필요한가" id="markdown-toc-변수란-무엇인가-왜-필요한가">변수란 무엇인가? 왜 필요한가?</a></li>
  <li><a href="#변수-선언" id="markdown-toc-변수-선언">변수 선언</a></li>
  <li><a href="#변수-호이스팅" id="markdown-toc-변수-호이스팅">변수 호이스팅</a></li>
  <li><a href="#값의-할당" id="markdown-toc-값의-할당">값의 할당</a></li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<p><img src="../../images/js_1.jpeg" alt="" width="50%" /></p>

<h1 id="변수란-무엇인가-왜-필요한가">변수란 무엇인가? 왜 필요한가?</h1>

<p>사람은 계산과 기억을 모두 두뇌에서 하지만, 컴퓨터는 연산과 기억을 수행하는 부품이 나눠져 있다. 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.</p>

<p>메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다. 메모리 셀 하나의 크기는 1바이트이다. 각 셀은 고유의 메모리 주소를 갖는다. 모든 값은 메모리 상의 임의의 위치에 저장되고 CPU는 이 값을 읽어들여 연산을 수행한다. 연산 결과로 생성된 값도 메모리 상의 임의의 위치에 저장된다. 하지만 문제는 이 값을 재사용하기 위해서는 어디 저장되어야 하는지 알아야 하는데 모른다는 것이다. 설령 안다고 하더라도 개발자가 직접적으로 메모리에 접근하는 것은 위험하다. 그래서 자바스크립트는 직접적인 메모리 제어를 허용하지 않는다.</p>

<p>프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.</p>

<p>변수는 하나의 값을 저장하기 위해 확보한 <strong>메모리 공간을 식별하기 위해 붙인 이름</strong>을 말한다.</p>

<p>변수는 컴파일러 또는 인터프리터에 의해 메모리 공간의 주소로 치환되어 실행된다. 따라서 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 변수를 통해 안전하게 값에 접근할 수 있다.</p>

<h1 id="변수-선언">변수 선언</h1>
<p>변수 선언이란 변수를 생성하는 것을 말한다. 좀 더 자세히 말하면 메모리에는 값을 저장하기 위한 공간을 확보하고, 변수 이름을 메모리 공간의 주소로 연결(name binding)하는 것을 말한다.</p>

<p>변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 <code class="language-plaintext highlighter-rouge">var</code>, <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code> 키워드를 사용한다. ES6에서 let, const 키워드가 도입되기 전까지는 var 키워드가 변수 선언을 위한 유일한 키워드였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🦄 **var 키워드의 단점**  
var 키워드의 가장 대표적인 단점은 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프만 지원한다는 것이다.  
</code></pre></div></div>

<p>자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 걸쳐 수행한다.</p>
<ul>
  <li><strong>선언 단계</strong>: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.</li>
  <li><strong>초기화 단계</strong>: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 <code class="language-plaintext highlighter-rouge">undefined</code>를 할당해 초기화한다.</li>
</ul>

<p>이렇게 초기화 단계를 거침으로써 이전에 다른 애플리케이션이 사용했던 값(garbage value)이 재사용되는 것을 방지해줄 수 있다.</p>

<h1 id="변수-호이스팅">변수 호이스팅</h1>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">score</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">score</span><span class="p">;</span>
</code></pre></div></div>

<p>위의 코드를 보면 변수 선언문보다 변수를 참조하는 코드가 앞에 있다. 그럼에도 결과는 에러가 아닌 <code class="language-plaintext highlighter-rouge">undefined</code>다.</p>

<p>자바스크립트에서는 <strong>변수 선언이 런타임(소스코드가 실행되는 시점)이 아니라 그 이전 단계에서 먼저 실행</strong>된다.</p>

<p>자바스크립트 엔진은 소스코드를 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다. 이 과정에서 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아서 먼저 실행한다. 그리고 이 과정이 끝나면 비로소 모든 선언문을 제외한 나머지 코드를 한 줄씩 순차적으로 실행한다.</p>

<p>이처럼 모든 선언문(<code class="language-plaintext highlighter-rouge">var</code>, <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code>, <code class="language-plaintext highlighter-rouge">function</code>, <code class="language-plaintext highlighter-rouge">function*</code>, <code class="language-plaintext highlighter-rouge">class</code>이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 특징을 <strong>변수 호이스팅</strong>이라 한다.</p>

<h1 id="값의-할당">값의 할당</h1>

<p>변수에 값을 할당할 때는 연산자 <code class="language-plaintext highlighter-rouge">=</code>를 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">score</span><span class="p">;</span> <span class="c1">// 변수 선언</span>
<span class="nx">score</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">// 값의 할당</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">score</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">// 변수 선언과 값의 할당</span>
</code></pre></div></div>

<p>자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 2개의 문으로 나누어 각각 실행한다. 이 때 주의할 점은 변수 선언과 값의 할당의 실행 시점이 다르다는 것이다. 변수 선언은 값의 할당이 일어나는 런타임 이전에 이루어진다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">score</span><span class="p">);</span> <span class="c1">// undefined</span>

<span class="kd">var</span> <span class="nx">score</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">score</span><span class="p">);</span> <span class="c1">// 80</span>
</code></pre></div></div>

<p>또한 변수의 선언과 값의 할당을 하나의 문으로 단축 표현해도 자바스크립트 엔진은 나누어 실행하므로, 변수에 먼저 <code class="language-plaintext highlighter-rouge">undefined</code>가 할당되어 초기화되는 것은 변함이 없다. 그리고 값이 할당될 때에는 새로운 메모리 공간을 확보하고 그 곳에 할당 값을 저장한다.</p>

<p><img src="../../images/js_8.png" alt="" /></p>

<p>이렇게 되고나면 <code class="language-plaintext highlighter-rouge">undefined</code>는 가비지 컬렉션에 의해 메모리에서 자동 해제된다.</p>

<h1 id="참고">참고</h1>
<ul>
  <li><a href="https://ko.wikipedia.org/wiki/네임_바인딩" target="_blank">name-binding</a></li>
</ul>
:ET