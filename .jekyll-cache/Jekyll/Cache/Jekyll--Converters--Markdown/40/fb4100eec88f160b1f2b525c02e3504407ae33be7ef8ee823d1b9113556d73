I"x<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#프로세스" id="markdown-toc-프로세스">프로세스</a>    <ul>
      <li><a href="#프로세스의-네-가지-상태" id="markdown-toc-프로세스의-네-가지-상태">프로세스의 네 가지 상태</a></li>
      <li><a href="#프로세스의-구조" id="markdown-toc-프로세스의-구조">프로세스의 구조</a></li>
      <li><a href="#프로세스의-생성과-복사" id="markdown-toc-프로세스의-생성과-복사">프로세스의 생성과 복사</a></li>
      <li><a href="#프로세스의-전환" id="markdown-toc-프로세스의-전환">프로세스의 전환</a></li>
      <li><a href="#프로세스의-계층-구조" id="markdown-toc-프로세스의-계층-구조">프로세스의 계층 구조</a></li>
    </ul>
  </li>
  <li><a href="#스레드" id="markdown-toc-스레드">스레드</a>    <ul>
      <li><a href="#스레드의-개념" id="markdown-toc-스레드의-개념">스레드의 개념</a></li>
      <li><a href="#멀티스레드" id="markdown-toc-멀티스레드">멀티스레드</a></li>
    </ul>
  </li>
  <li><a href="#프로세스-간-통신" id="markdown-toc-프로세스-간-통신">프로세스 간 통신</a>    <ul>
      <li><a href="#동기화" id="markdown-toc-동기화">동기화</a></li>
      <li><a href="#프로세스-간-통신의-종류" id="markdown-toc-프로세스-간-통신의-종류">프로세스 간 통신의 종류</a>        <ul>
          <li><a href="#전역-변수를-이용한-통신" id="markdown-toc-전역-변수를-이용한-통신">전역 변수를 이용한 통신</a></li>
          <li><a href="#파일을-이용한-통신" id="markdown-toc-파일을-이용한-통신">파일을 이용한 통신</a></li>
          <li><a href="#소켓을-이용한-통신" id="markdown-toc-소켓을-이용한-통신">소켓을 이용한 통신</a></li>
        </ul>
      </li>
      <li><a href="#임계구역" id="markdown-toc-임계구역">임계구역</a>        <ul>
          <li><a href="#임계구역-해결-조건" id="markdown-toc-임계구역-해결-조건">임계구역 해결 조건</a></li>
          <li><a href="#임계구역-해결-방법" id="markdown-toc-임계구역-해결-방법">임계구역 해결 방법</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#교착-상태" id="markdown-toc-교착-상태">교착 상태</a></li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>
<hr />

<h1 id="프로세스">프로세스</h1>
<p>프로세스 관리는 운영체제의 핵심적인 역할</p>

<p>프로세스가 생성되고 작업을 마칠 때까지의 상태 변화</p>

<p>프로세스와 스레드 비교</p>

<p>스레드 사용의 이점</p>

<p>운영체제에서 프로세스는 하나의 작업 단위</p>

<p>프로그램을 실행하면 프로세스가 된다</p>

<p>프로그램은 하드디스크 같은 저장장치에 저장</p>

<p>프로그램을 실행하면 해당 코드가 메모리에 올라와서 작업이 진행된다</p>

<p>프로그램은 저장장치에 저장되어 있는 정적인 상태</p>

<p>프로세스는 실행을 위해 메모리에 올라온 동적인 상태</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>프로그램 - 클래스 - 레시피

프로세스 - 객체  - 요리
</code></pre></div></div>

<p>CPU가 시간을 쪼개어 여러 프로세스에 적당히 배분함으로써 도잇에 실행하는 것처럼 느껴진다</p>

<h2 id="프로세스의-네-가지-상태">프로세스의 네 가지 상태</h2>

<p>시분할 방식에서의 예상치 못한 상황 처리</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>새우튀김을 해야하는데 새우가 아직 손질되지 않았다고 가정해보자. 메인 셰프가 보조 요리사에게 새우 손질을 지시한다  
그동안 메인 셰프가 아무것도 하지 않으면 비효율적이다.  
메인 셰프는 새우튀김을 '대기 목록'으로 옮기고 주문 목록에 있는 다른 주문서를 가져와서 요리를 해야한다.  

새우 손질이 끝났다고 가정해보자. 그렇다고 바로 대기 목록에서 새우튀김을 가져와서 바로 요리하지는 않는다.  

우선 현재 작업 중이던 요리를 마친 뒤 새우튀김을 만드는 것이 좋다. 따라서 새우튀김 요리 주문서를 대기 목록에서 주문 목록 뒤에 이동시킨 뒤 순서를 기다린다.  
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>손님이 급한 볼일을 보느라 음식을 천천히 달라고 요청하는 경우도 있다. 손님의 지연 요청은 언제 끝날지 알 수 없기 때문에 무작정 대기 목록에 올려둘 수 없다. (손님이 지연 끝에 취소를 할 수도 있다)  

이와 같이 언제 다시 시작될지 모르는 주문서는 '보류 목록'으로 옮기고, 손님이 음식을 달라고 하면 보류 목록에 있는 주문서를 '주문 목록'으로 보낸다.  
보류 목록은 언제 다시 시작될지 모르거나, 중간에 그만둘지 모르는 작업들을 모아두는 곳이다
</code></pre></div></div>

<p>현대의 운영체제는 시분할 방식을 기본으로 사용한다. 프로세스가 여러 상태를 오가며 실행된다. 그렇다면 운영체제가 어떻게 여러 프로세스를 동시에 처리하는지 살펴보자.</p>

<p><strong>프로그램에서 프로세스로의 전환</strong></p>

<p>프로세스는 컴퓨터 시스템의 작업 단위로 태스크라고도 불린다.</p>

<p>시분할 방식 시스템에서 프로그램이 프로세스로 전환될 때 어떤 일이 일어나는지 살펴보자</p>

<p>우선 운영체제는 프로그램을 메모리의 적당한 위치로 가져온다. 그와 동시에 주문서에 해당하는 작업 지시서(프로세스 제어블록)를 만든다. 프로세스 제어블록에는 프로세스를 처리하는 데 필요한 다양한 정보가 들어 있다. 프로그램이 프로세스로 전환되려면 운영체제로부터 프로세스 제어블록을 받아야 한다. (프로세스 제어블록은 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에 운영체제 영역에 만들어진다) 프로세스가 종료되면 메모리에서 삭제되고, 프로세스 제어블록도 폐기된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>프로세스 제어블록에 포함된 대표적인 정보

- 프로세스 구분자: 프로세스를 구분하는 구분자(PID)

- 메모리 관련 정보: 프로세스가 올라가 있는 메모리의 위치 정보

- 각종 중간값: 프로세스가 사용했던 각종 중간값 (시분할 시스템이기 때문에 중간값을 저장해야 한다) 
            (ex. 다음 작업할 코드의 위치가 담긴 프로그램 카운터, 각종 중간값을 보관 중인 레지스터)
</code></pre></div></div>

<p><img src="/images/os_3.png" alt="" /></p>

<p><strong>프로세스의 상태</strong></p>

<p>앞서 레스토랑의 예에서 주문서가 다양한 목록을 옮겨 다니는 것과 같이, 운영체제에서도 여러 가지 이유로 프로세스 상태가 변화된다. 시분할 시스템에서 프로세스는 CPU 리소스를 넘겨주고 다시 받고 하는 일이 빈번하게 일어난다. 프로세스는 상황에 따라 다섯 가지 상태를 오간다.</p>

<ul>
  <li><strong>생성 상태</strong>
    <ul>
      <li>프로세스가 메모리에 올라와 실행 준비를 완료한 상태</li>
      <li>프로세스를 관리하는데 필요한 프로세스 제어블록이 생성됨</li>
    </ul>
  </li>
  <li><strong>준비 상태</strong>
    <ul>
      <li>생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태</li>
      <li>디스패치: CPU 스케줄러가 준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일</li>
    </ul>
  </li>
  <li><strong>실행 상태</strong>
    <ul>
      <li>준비 상태에 있던 프로세스가 CPU를 얻어 실제 작업을 수행하는 상태</li>
      <li>프로세스 제어블록을 CPU에 전달</li>
      <li>주어진 시간내 작업이 끝나지 않은 경우 다시 준비 상태로 돌아감(클록이 인터럽트를 사용해 CPU에 알림)</li>
      <li>작업이 끝날때까지 준비 상태와 실행 상태를 왔다 갔다함</li>
    </ul>
  </li>
  <li><strong>완료 상태</strong>
    <ul>
      <li>실행 상태의 프로세스가 시간내 작업을 마치면 완료 상태로 진입</li>
      <li>프로세스 제어블록이 사라진 상태</li>
    </ul>
  </li>
  <li><strong>대기 상태</strong>
    <ul>
      <li>프로세스가 입출력을 요청하면 입출력 관리자가 입출력을 완료하기 전까지 프로세스를 대기 상태로 옮겨둔다</li>
      <li>입출력 관리자가 입출력을 완료하면 프로세스를 대기 상태에서 준비 상태로 옮긴다</li>
    </ul>
  </li>
</ul>

<p><img src="/images/os_5.png" alt="" /></p>

<p><strong>컨텍스트 스위칭</strong></p>

<p>컨텍스트 스위칭(context switching)은 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다. 이 때 두 프로세스 제어블록의 내용이 변경된다. 실행 상태에서 나가는 프로세스 제어블록에는 CPU에 있던 지금까지의 작업 내용을 저장하고, 반대로 실행 상태로 들어오는 프로세스 제어블록의 내용으로 CPU를 다시 세팅한다. 이와 같이 두 프로세스의 프로세스 제어블록을 교환하는 작업을 컨텍스트 스위칭이라 한다.</p>

<p>컨텍스트 스위칭은 인터럽트가 걸렸을 때 발생한다.</p>

<ul>
  <li>타임아웃 인터럽트</li>
  <li>프로세스가 자신에게 주어진 메모리 공간을 넘어가려 할 때 발생하는 인터럽트 등</li>
</ul>

<h2 id="프로세스의-구조">프로세스의 구조</h2>

<p><img src="/images/os_7.png" alt="" /></p>

<ul>
  <li><strong>코드 영역</strong>
    <ul>
      <li>프로그램의 코드가 기술된 곳으로 텍스트 영역이라고도 함</li>
      <li>자기 자신을 수정하는 프로그램은 존재하지 않기 때문에, 코드는 읽기 전용으로 처리</li>
    </ul>
  </li>
  <li><strong>데이터 영역</strong>
    <ul>
      <li>코드가 실행되면서 사용되는 변수나 파일 등의 각종 데이터를 모아놓는 곳</li>
      <li>변수는 기본적으로 읽기와 쓰기가 가능</li>
    </ul>
  </li>
  <li><strong>스택 영역</strong>
    <ul>
      <li>프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳</li>
      <li>예를들어, 함수가 호출되면 함수를 수행하고 마치면 다시 되돌아올 위치를 이 영역에 저장</li>
      <li>스택 영역은 운영체제가 사용자의 프로세스를 작동하기 위해 유지하는 영역이므로 사용자에게는 보이지 않음</li>
    </ul>
  </li>
</ul>

<h2 id="프로세스의-생성과-복사">프로세스의 생성과 복사</h2>

<p>프로세스는 프로그램을 실행할 때 새로 생성된다. 사용자가 프로그램을 실행하면 운영체제는 프로그램을 메모리에 가져와 코드 영역에 넣고 프로세스 제어블록을 생성한다. 그리고 메모리에 데이터 영역과 스택 영역을 확보한 후 프로세스를 실행한다.</p>

<p>프로세스를 새로 생성하는 방법뿐만 아니라 <strong>실행 중인 프로세스로부터 새로운 프로세스를 복사하는 방법</strong>도 있다.</p>

<p><strong>fork()</strong></p>

<p>커널이 제공하는 <code class="language-plaintext highlighter-rouge">fork()</code> 시스템 호출은 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수이다. 이 함수는 워드 프로그램, 브라우저 등에서 프로그램을 하나 더 실행할 때 전형적으로 호출된다. 이렇게 프로세스를 복사하게 되면 기존의 프로세스는 부모 프로세스가 되고, 새로 생긴 프로세스는 자식 프로세스가 된다.</p>

<h2 id="프로세스의-전환">프로세스의 전환</h2>

<p><strong>exec()</strong></p>

<p><code class="language-plaintext highlighter-rouge">exec()</code> 시스템 호출을 사용하면 복사된 프로세스를 새로운 프로세스로 전환할 수 있다. 이 함수를 사용하는 목적은 프로세스의 구조체를 재활용하기 위함이다.</p>

<p>새로운 프로세스를 만들려면 제어블록을 만들고 메모리의 자리를 확보하는 과정이 필요하다. 또한 프로세스를 종료하고 사용한 메모리를 청소(garbage collection)하기 위해 상위 프로세스와 부모-자식 관계를 만들어야 한다.</p>

<p><code class="language-plaintext highlighter-rouge">exec()</code>를 사용하면 이미 만들어진 제어블록, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있어 편리하다. 새로운 코드 영역만 가져오면 되기 때문에 운영체제의 작업이 수월하다.</p>

<p><code class="language-plaintext highlighter-rouge">exec()</code> 함수의 동작과정은 간단하다. 호출을 하면 코드 영역에 있는 기존의 내용을 지우고 새로운 코드로 바꾼다. 또한 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋된다. 제어블록의 내용 중 프로세스 구분자, 부모 프로세스 구분자, 메모리 관련 사항 등은 변하지 않지만 프로그램 카운터 레지스터 값을 비롯한 각종 레지스터와 사용한 파일 정보가 모두 리셋된다.</p>

<h2 id="프로세스의-계층-구조">프로세스의 계층 구조</h2>

<p>위에서 배운 프로세스의 복사와 전환은 프로세스의 계층 구조를 이해하는데 핵심 열쇠가 된다.</p>

<p><code class="language-plaintext highlighter-rouge">fork()</code>와 <code class="language-plaintext highlighter-rouge">exec()</code>를 사용하면 프로세스들을 자동적으로 부모-자식 프로세스의 계층 구조로 만들어준다. 프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져서 시스템을 관리하기가 수월하다. 프로세스가 작업을 마쳐서 그 프로세스가 사용하던 자원을 회수(garbage collection)할 때 특히 편리하다. 만약 모든 프로세스가 독립적으로 만들어지면 프로세스가 종료될 때마다 운영체제가 직접 자원을 회수해야 하기 때문에 작업이 복잡해질 것이다. 그러나 모든 프로세스를 부모-자식 관계로 만들면 자식 프로세스가 작업을 마쳤을 떄 사용하던 자원을 부모 프로세스가 회수하면 된다.</p>

<p><strong>고아 프로세스</strong></p>

<p>부모 프로세스는 자원을 회수하기 위해 자식 프로세스가 끝날 때까지 기다려야 된다. 그런데 부모 프로세스가 먼저 종료되거나 자식 프로세스가 비정상적으로 종료되어 부모 프로세스에 연락이 안되는 경우도 있다. 이렇게 부모 프로세스가 먼저 종료되고 비정상적으로 남아있는 자식 프로세스를 고아 프로세스 또는 좀비 프로세스라고 한다. 좀비 프로세스는 자식 프로세스를 종료했음에도 부모가 뒤처리를 하지 않을 떄 발생한다. 이런 좀비 프로세스가 많아지면 자원이 낭비되게 된다. 따라서 운영체제는 반환되지 못한 자원을 주기적으로 회수해야 한다.</p>

<h1 id="스레드">스레드</h1>

<p>오늘날의 운영체제는 프로세스의 낭비 요소를 제거하고, 프로세스 작업의 유연성을 얻기 위해 멀티스레드를 사용한다.</p>

<h2 id="스레드의-개념">스레드의 개념</h2>

<p>프로세스는 요리 작업 전체, 스레드는 요리를 완성하기 위해 수행하는 각각의 조리에 해당</p>

<p>CPU 스케줄러가 CPU에 전달하는 일 하나가 스레드. 그러므로 CPU가 처리하는 작업의 단위는 프로세스로부터 전달받은 스레드</p>

<p>운영체제 입장에서의 작업 단위는 프로세스이고, CPU 입장에서의 작업 단위는 스레드</p>

<p>프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위</p>

<p><strong>프로세스와 스레드의 차이</strong></p>

<p>프로세스끼리는 약하게 연결되어 있는 반면, 스레드끼리는 강하게 연결되어 있음</p>

<p>프로세스는 스테이크, 스프와 같이 서로 큰 영향을 미치지 않음</p>

<p>스레드는 스테이크 요리 내에서 고기 굽기, 채소 굽기, 소스 뿌리기와 같이 서로 강하게 연결되어 있음</p>

<p><strong>멀티 태스크</strong></p>

<p>운영체제가 CPU에 작업을 줄 떄 시간을 잘게 나누어 배분하는 기법</p>

<p>시분할 시스템에서 운영체제가 CPU에 전달하는 작업은 프로세스가 아니라 스레드이다.</p>

<p>서로 독립적인 여러 개의 프로세스로 구성</p>

<p>프로세스 간 데이터를 주고 받기 위해 IPC(Inter Process Communication)을 이용한다.</p>

<p><strong>멀티 프로세싱</strong></p>

<p>멀티프로세싱은 CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경을 말한다.</p>

<p>멀티프로세싱은 하나의 컴퓨터에 여러 개의 CPU 혹은 하나의 CPU내 여러 개의 코어에 스레드를 배정하여 동시에 작동하는 것.</p>

<p><strong>멀티 스레드</strong></p>

<p>멀티스레드는 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법</p>

<p>멀티스레드는 변수나 파일 등을 공유하고 전역 변수나 함수 호출 등의 방법으로 스레드간 통신을 한다.</p>

<p><strong>CPU 멀티 스레드</strong></p>

<p>CPU 멀티스레드는 한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법</p>

<p>하드웨어적인 방법으로 하나의 CPU에서 여러 스레드를 동시에 처리하는 병렬 처리 기법<br />
(멀티스레드는 운영체제가 소프트웨어적으로 프로세스를 작은 단위의 스레드로 분할하여 운영하는 기법)</p>

<h2 id="멀티스레드">멀티스레드</h2>

<p>CPU와 프로그래밍 기술이 발전하면서 여러 개의 코어를 가진 CPU가 생겨나 멀티스레드를 지원하기 시작</p>

<p><strong>멀티스레드의 구조</strong></p>

<p>스레드가 어떻게 생겨나고 어떻게 구성되는지 프로세스의 입장에서 살펴보자. C언어와 같은 절차지향 프로그래밍 언어는 순차적으로 실행되기 때문에 프로세스로 여러 개의 작업을 동시에 처리하기가 불편했다. 여러 개의 작업을 동시에 처리하기 위해 fork() 시스템 호출을 사용해 프로세스를 생성하는 방법을 이용했다. 그러나 fork()는 코드 영역과 데이터 영역의 일부가 메모리에 중복되어 존재하는 낭비 요소가 생길 수 밖에 없었다.</p>

<p>예를 들어, 워드프로세서 같은 문서 편집기를 이용해 숙제, 편지쓰기, 자료 정리 작업을 동시에 진행한다고 해보자. 이 때 각각의 워드프로세서를 여러 개 실행할 경우, 내부적으로는 fork() 시스템 호출이 발생한다. 이렇게 되면 워드프로세서의 코드 일부, 프로세스 제어 블록, 공유 변수가 메모리의 여러 곳에 중복되어 메모리가 낭비된다.</p>

<p>스레드는 이러한 멀티태스킹의 낭비 요소를 제거하기 위해 사용한다. 비슷한 일을 하는 2개의 프로세스를 만드는 대신, 코드, 데이터 등을 공유하면서 여러 개의 일을 하나의 프로세스 내에서 하는 것이다.</p>

<p>프로세스는 크게 정적인 영역과 동적인 영역으로 구분된다. 동적인 영역의 대표적인 예는 레지스터 값, 스택, 힙 등이다.</p>

<p>오늘날에는 여러 작업을 하기 위해 fork() 시스템 호출 대신 하나의 프로세스에 여러 개의 스레드를 만들어 사용한다.</p>

<p>멀티스레드는 코드, 파일 등의 자원을 공유함으로써 자원의 낭비를 막고 효율성을 향상한다.</p>

<p><img src="/images/os_8.png" alt="" /></p>

<p><strong>멀티스레드의 장점</strong></p>

<ul>
  <li>응답성 향상: 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답할 수 있다</li>
  <li>자원 공유: 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원활하게 진행할 수 있다</li>
  <li>효율성 향상: 불필요한 자원의 중복을 막음으로써 시스템의 효율이 향상된다</li>
  <li>다중 CPU 지원: 2개 이상의 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티스레드를 동시에 처리하여 CPU 사용량이 증가하고 프로세스의 처리 시간이 단축된다</li>
</ul>

<p><strong>멀티스레드의 단점</strong></p>

<p>모든 스레드가 자원을 공유하기 때문에 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미친다.</p>

<h1 id="프로세스-간-통신">프로세스 간 통신</h1>

<p>프로세스는 서로 독립적이기 때문에 데이터를 주고 받기 위해서는 프로세스 간 통신을 해야 한다.</p>

<p>프로세스끼리 통신을 할 때에는 누가 먼저 작업할지, 작업이 언제 끝날지 등을 서로 알려주어야 하는데 이를 <strong>동기화</strong>라고 한다.</p>

<p>그리고 같은 데이터를 여러 프로세스가 사용할 때는 서로 침범하면 안되는 <strong>임계구역</strong>이 존재한다.</p>

<p>프로세스 간 통신(IPC, Inter Process Communication)에는 같은 컴퓨터내에 있는 프로세스 간 통신도 있고, 네트워크로 연결된 다른 컴퓨터에 있는 프로세스 간 통신도 있다.</p>

<p><img src="/images/os_9.png" alt="" /></p>

<ul>
  <li><strong>프로세스 내부 데이터 통신</strong>: 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우의 통신. 프로세스 내부의 스레드는 전역 변수나 파일을 이용해 데이터를 주고 받는다</li>
  <li><strong>프로세스 간 데이터 통신</strong>: 같은 컴퓨터에 있는 여러 프로세스끼리 통신하는 경우로, 공용 파일 또는 운영체제가 제공하는 파이프를 사용하여 통신한다</li>
  <li><strong>네트워크를 이용한 데이터 통신</strong>: 여러 컴퓨터가 네트워크로 연결되어 있을 때도 통신이 가능한데, 이 경우 프로세스는 소켓을 이용하여 데이터를 주고받는다. 이처럼 소켓을 이용하는 프로세스 간 통신을 네트워킹이라고 한다. 다른 컴퓨터에 있는 함수를 호출하여 통신하는 원격 프로시저 호출(RPC)도 여기에 해당한다.</li>
</ul>

<p>(같은 프로세스끼리도 루프백(127.0.0.1) 주소를 사용하면 소켓을 이용하여 통신할 수도 있지만, 소켓을 사용하려면 많은 전처리를 해야하기 때문에 같은 컴퓨터에 있는 프로세스 간 통신에는 소켓을 거의 사용하지 않는다)</p>

<h2 id="동기화">동기화</h2>
<p>프로세스 간 통신은 겉으로 보기에는 단순하다. 데이터를 주거나(send), 받는것(receive)을 의미한다. 예를 들어 전역 변수를 이용해 통신하는 경우를 생각해보자. 데이터를 보내는 프로세스는 데이터를 전역 변수에 저장한다. 데이터를 받는 프로세스는 전역 변수에 저장된 데이터를 읽어간다.</p>

<p>하지만 내부적으로는 이것보다는 복잡하다. 예를 들어 통신하려는 상대 프로세스를 어떻게 찾을지, 데이터의 크기는 얼마로 할지, 데이터 도착 여부를 어떻게 확인할지 등의 문제를 해결해야 한다.</p>

<p>프로세스 간 통신 방법을 분류할 때는 크게 두 가지가 기준이 된다. 바로 <strong>통신 방향</strong>과 <strong>동기화의 유무</strong>이다.</p>

<ul>
  <li><strong>단방향</strong>: 모스 신호처럼 한쪽 방향으로만 데이터를 전송할 수 있는 구조. (전역 변수, 파이프)</li>
  <li>
    <p><strong>양방향</strong>: 데이터를 동시에 양쪽 방향으로 전송할 수 있는 구조 (소켓 통신)</p>
  </li>
  <li><strong>동기화</strong>: 상대쪽에서 데이터를 전송하면 운영체제가 데이터가 도착했음을 알려준다. (파이프, 소켓)</li>
  <li><strong>비동기화</strong>: 상대쪽에서 데이터를 전송했는지 반복문을 무한 실행하며 기다려야 한다(바쁜 대기). (전역 변수, 파일)</li>
</ul>

<h2 id="프로세스-간-통신의-종류">프로세스 간 통신의 종류</h2>

<h3 id="전역-변수를-이용한-통신">전역 변수를 이용한 통신</h3>

<p>전역 변수를 이용한 통신은 공동으로 관리하는 메모리를 사용하여 데이터를 주고 받는 것이다.</p>

<p>전역 변수를 이용한 통신은 변수를 두 개를 사용하면 양방향 통신을 가능하게 한다.</p>

<p>하지만 동기화 문제가 해결되지 않는다.</p>

<h3 id="파일을-이용한-통신">파일을 이용한 통신</h3>

<p>파일을 이용한 통신은 부모-자식 프로세스 간 통신에 많이 사용</p>

<p>운영체제가 별다른 동기화를 제공하지 않기 때문에, 프로세스가 알아서 동기화를 해야 한다.</p>

<p>동기화를 위해 주로 부모 프로세스가 wait() 함수를 이용하여 자식 프로세스의 작업이 끝날 때까지 기다렸다가 작업을 시작한다.</p>

<h3 id="소켓을-이용한-통신">소켓을 이용한 통신</h3>

<p>서로 다른 컴퓨터에 있는 프로세스 간 통신은 원격 프로시저 호출(RPC)이나 소켓을 이용한다.</p>

<p>원격 프로시저 호출은 다른 컴퓨터에 있는 함수를 호출하는 것을 뜻한다.</p>

<p>객체지향 언어에서 다른 컴퓨터에 있는 객체의 메소드를 불러와 사용하는 것이 원격 프로시저 호출의 대표적인 예이다.</p>

<p>원격 프로시저 호출은 일반적으로 소켓을 이용하여 구현한다.</p>

<p>프로세스는 소켓에 쓰기 연산을 통해 데이터를 전송하고 읽기 연산을 통해 데이터를 받는다.</p>

<p>소켓은 동기화를 지원한다.</p>

<p>소켓은 하나만 사용해도 양방향 통신이 가능하다.</p>

<p>네트워크 프로그래밍을 흔히 소켓 프로그래밍이라 부르는 이유는 네트워킹의 기본이 소켓이기 때문이다.</p>

<p><img src="/images/os_10.png" alt="" /></p>

<p><img src="/images/os_11.png" alt="" /></p>

<p>여러 컴퓨터에 있는 프로세스에 데이터를 전달하는 방법 중 가장 대중화된 것은 소켓을 이용한 네트워킹이다. 소켓을 이용한 네트워킹에서도 open(), read()/write(), close() 구조를 사용한다.</p>

<p>위의 그림은 클라이언트와 서버가 어떤 절차를 거쳐서 통신하는지를 보여준다. 클라이언트와 서버는 둘 다 소켓을 사용한다. 소켓은 양방향 통신을 지원하고 동기화도 지원한다.</p>

<p>클라이언트는 소켓을 생성한 후 connect()를 사용하여 서버와의 접속을 시도한다. 서버와 접속되면 read() 혹은 write() 작업을 하며, 작업이 끝나면 사용한 소켓 디스크립터를 닫고 종료한다.</p>

<p>서버 쪽 통신 절차는 좀 더 복잡하다. 서버는 소켓을 생성한 후 bind()를 삿용하여 생성한 소켓을 특정 포트에 등록한다. 포트는 한 컴퓨터 내에 존재하는 여러 프로세스를 구분하기 위한 목적이다. 포트를 사용해 어떤 프로세스와 통신할지 구분할 수 있다.</p>

<p>하나의 포트 번호에 소켓이 하나만 생성되는 것은 아니다. 네이버 홈페이지를 운영하는 서버의 포트 번호는 80번인데, 여기에 소켓을 하나만 생성할 수 있다면단 한사람에게만 서비스를 할 수 있을 것이다. 서버는 동시에 여러 클라이언트에 서비스를 하기 위해 하나의 포트 번호에 여러 개의 소켓을 생성한다. 따라서 bind()는 특정 포트에 새로운 소켓을 등록하겠다는 의미이다.</p>

<p>bind()로 소켓이 정상적으로 등록되면 listen()을 실행하여 클라이언트를 받을 준비를 한다. accept()는 클라이언트의 connect(), 즉 연결 요청을 기다리다가 여러 명의 클라이언트가 동시에 connect()를 하는 경우 그중 하나를 골라 작업을 시작하게 해준다. 따라서 클라이언트가 accept()되면 소켓 디스크립터가 생성되고 작업이 시작된다. read()혹은 write() 작업을 마치면 생성된 소켓 디스크립터를 닫고 다음 클라이언트를 기다린다.</p>

<p>서버에서의 소켓 생성은 listen()으로 클라이언트의 접속을 확인한 후, accept()에서 이루어진다.</p>

<p>서버의 경우 계속 클라이언트를 받아 작업해야 하기 때문에 무한 루프를 돌며 작업을 반복한다.</p>

<h2 id="임계구역">임계구역</h2>

<p>임계구역은 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역을 말한다.</p>

<h3 id="임계구역-해결-조건">임계구역 해결 조건</h3>

<ul>
  <li>상호 배제: 한 프로세스가 임계구역에 들어가면 다른 프로세스는 들어갈 수 없다</li>
  <li>한정 대기: 어떤 프로세스도 무한 대기하지 않아야 한다</li>
  <li>진행의 융통성: 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다</li>
</ul>

<h3 id="임계구역-해결-방법">임계구역 해결 방법</h3>

<ul>
  <li>세마포어: 임계구역에 진입하기 전에 스위치를 사용 중으로 놓고 임계구역으로 들어가는 방법</li>
</ul>

<h1 id="교착-상태">교착 상태</h1>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;barcode=9791156644071" target="_blank">쉽게 배우는 운영체제 책 참고</a></li>
</ul>
:ET