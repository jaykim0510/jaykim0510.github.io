I"k<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#state" id="markdown-toc-state">State</a>    <ul>
      <li><a href="#operator-state" id="markdown-toc-operator-state">Operator State</a></li>
      <li><a href="#keyed-state" id="markdown-toc-keyed-state">Keyed State</a></li>
    </ul>
  </li>
  <li><a href="#recovery" id="markdown-toc-recovery">Recovery</a>    <ul>
      <li><a href="#checkpoint" id="markdown-toc-checkpoint">Checkpoint</a></li>
      <li><a href="#savepoint" id="markdown-toc-savepoint">Savepoint</a></li>
    </ul>
  </li>
  <li><a href="#statebackend" id="markdown-toc-statebackend">StateBackend</a></li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<h1 id="state">State</h1>

<p>대부분의 어플리케이션은 상태를 저장하고 활용(stateful)합니다. 만약 각각의 이벤트를 단순히 변환(transformation)하는 용도의 어플리케이션이라면 상태(state)가 필요하지 않을 수도 있습니다. 하지만 단순한 비즈니스 로직조차도 이전의 이벤트나 중간 결과를 사용하는 경우가 대부분이기 때문에 상태를 저장해 활용하는 것은 대부분의 서비스에 중요한 요소입니다.</p>

<p>스트림 처리 어플리케이션의 경우 상태(state)의 중요성이 더욱 커지게 됩니다. 스트림 처리 어플리케이션에서 상태가 중요한 이유는 다음과 같습니다.</p>

<ul>
  <li>스트림 처리는 짧은 지연을 위해 값을 출력 후 갱신을 통해 정확도를 높이는 방식이기에 이전 값을 기억해야함</li>
  <li>장애 발생시 저장된 상태를 통해 다시 복구가 가능</li>
</ul>

<p><img src="/images/flink_17.png" alt="" /></p>

<p>플링크에서는 상태를 프로그래밍 모델의 일급 시민(first-class citizen)으로 사용하고 있습니다. 플링크에서 상태 핸들링에 관한 주요 특징들에는 다음과 같은 것들이 있습니다.</p>

<ul>
  <li><strong>Multiple State Primitives</strong>: Flink provides state primitives for different data structures, such as atomic values, lists, or maps. Developers can choose the state primitive that is most efficient based on the access pattern of the function.</li>
  <li><strong>Pluggable State Backends</strong>: Application state is managed in and checkpointed by a pluggable state backend. Flink features different state backends that store state in memory or in RocksDB, an efficient embedded on-disk data store. Custom state backends can be plugged in as well.</li>
  <li><strong>Exactly-once state consistency</strong>: Flink’s checkpointing and recovery algorithms guarantee the consistency of application state in case of a failure. Hence, failures are transparently handled and do not affect the correctness of an application.</li>
  <li><strong>Very Large State</strong>: Flink is able to maintain application state of several terabytes in size due to its asynchronous and incremental checkpoint algorithm.</li>
  <li><strong>Scalable Applications</strong>: Flink supports scaling of stateful applications by redistributing the state to more or fewer workers.</li>
</ul>

<p>플링크에서 상태는 단순히 변수에 저장되는 하나의 값일 수도 있고, 파일이나 데이터베이스에 저장되는 데이터일 수도 있습니다. 이런 상태의 다양성을 반영하기 위해 플링크에서는 크게 두 가지 종류의 상태를 제공하며 또 각각의 상태별로 표현할 수 있는 기본 상태(State primitive)도 여러가지 입니다.</p>

<h2 id="operator-state">Operator State</h2>

<p><img src="/images/flink_15.png" alt="" /></p>

<p>Operator State (or non-keyed state) is state that is bound to one parallel operator instance. The Kafka Connector is a good motivating example for the use of Operator State in Flink. Each parallel instance of the Kafka consumer maintains a map of topic partitions and offsets as its Operator State.</p>

<p>The Operator State interfaces support redistributing state among parallel operator instances when the parallelism is changed. There are different schemes for doing this redistribution.</p>

<p>In a typical stateful Flink Application you don’t need operators state. It is mostly a special type of state that is used in source/sink implementations and scenarios where you don’t have a key by which state can be partitioned.</p>

<p>Notes: Operator state is still not supported in Python DataStream API.</p>

<h2 id="keyed-state">Keyed State</h2>

<p><img src="/images/flink_16.png" alt="" /></p>

<h1 id="recovery">Recovery</h1>

<h2 id="checkpoint">Checkpoint</h2>

<h2 id="savepoint">Savepoint</h2>

<h1 id="statebackend">StateBackend</h1>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791161754093&amp;orderClick=LEa&amp;Kc=" target="_blank">아파치 플링크로 하는 스트림 데이터 처리 책</a></li>
  <li><a href="https://flink.apache.org/flink-applications.html" target="_blank">Flink 공식문서: What is Apache Flink? — Applications</a></li>
  <li><a href="https://nightlies.apache.org/flink/flink-docs-master/docs/concepts/stateful-stream-processing/" target="_blank">Flink 공식문서: Stateful Stream Processing</a></li>
  <li><a href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/fault-tolerance/state/#keyed-datastream" target="_blank">Flink 공식문서: Working with State</a></li>
  <li><a href="https://www.ververica.com/blog/performance-factors-stateful-functions-operators-flink" target="_blank">Ververica: 3 important performance factors for stateful functions and operators in Flink</a></li>
  <li><a href="https://mehmetozanguven.github.io/apache-flink/2020/05/02/state-backend-and-state-example.html" target="_blank">mehmetozanguven: Apache Flink Series 8-State Backend &amp; State Example</a></li>
</ul>
:ET