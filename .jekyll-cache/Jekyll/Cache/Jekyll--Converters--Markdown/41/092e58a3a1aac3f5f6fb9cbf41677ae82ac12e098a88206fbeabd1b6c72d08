I"><hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#inner-join" id="markdown-toc-inner-join">INNER JOIN</a></li>
  <li><a href="#left-join-right-join" id="markdown-toc-left-join-right-join">LEFT JOIN, RIGHT JOIN</a></li>
  <li><a href="#union" id="markdown-toc-union">UNION</a></li>
  <li><a href="#subquery" id="markdown-toc-subquery">Subquery</a>    <ul>
      <li><a href="#서브쿼리를-사용할-수-있는-위치" id="markdown-toc-서브쿼리를-사용할-수-있는-위치">서브쿼리를 사용할 수 있는 위치</a></li>
    </ul>
  </li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<h1 id="inner-join">INNER JOIN</h1>

<ul>
  <li>두 테이블 모두 조건을 만족하는 레코드만 가지고 옴</li>
  <li>MySQL에서는 INNER JOIN, JOIN, 콤마(,) 모두 INNER JOIN을 뜻함</li>
  <li>ON에서 두 테이블을 연결시킬 조건없이 사용하는 경우를 Cartesian Product(곱집합) 이라고 함</li>
  <li>ex. A: {1, 2, 3}, B: {x, y}일 때 FROM A, B를 하면 -&gt; {[1, x], [1, y], [2, x], [2, y], [3, x], [3, y]}</li>
  <li>INNER JOIN은 인덱스 유무에 따라 옵티마이저가 알아서 기준 테이블(Driving table)과 대상 테이블(Driven table)이 정해짐</li>
  <li>드리븐 테이블이 성능 부하가 많은 편이라 인덱스가 있는 테이블을 드리븐 테이블로 사용해, 최대한 드리븐 테이블의 성능 부하를 낮춘다</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 정석적인 작성법</span>
<span class="k">SELECT</span> <span class="n">u</span><span class="p">.</span><span class="n">userid</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">name</span> 
<span class="k">FROM</span> <span class="n">usertbl</span> <span class="k">AS</span> <span class="n">u</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">buytbl</span> <span class="k">AS</span> <span class="n">b</span> 
<span class="k">ON</span> <span class="n">u</span><span class="p">.</span><span class="n">userid</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">userid</span> 
<span class="k">WHERE</span> <span class="n">u</span><span class="p">.</span><span class="n">userid</span><span class="o">=</span><span class="nv">"111"</span>

<span class="c1">-- 축약 작성법</span>
<span class="k">SELECT</span> <span class="n">u</span><span class="p">.</span><span class="n">userid</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">name</span> 
<span class="k">FROM</span> <span class="n">usertbl</span> <span class="n">u</span><span class="p">,</span> <span class="n">buytbl</span> <span class="n">b</span> 
<span class="k">WHERE</span> <span class="n">u</span><span class="p">.</span><span class="n">userid</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">userid</span> <span class="k">AND</span> <span class="n">u</span><span class="p">.</span><span class="n">userid</span><span class="o">=</span><span class="nv">"111"</span>

<span class="cm">/*
내 생각에 위의 방법은 딱 교집합인 결과에서 WHERE 조건절로 필터링
아래 방법은 곱집합으로 len(u) * len(b)만큼의 결과에서 WHERE 조건절 사용 -&gt; 훨씬 느릴것 같다
*/</span>
</code></pre></div></div>

<p>참고로 JOIN이 있는 쿼리문의 실행 순서는 다음과 같다.</p>

<ol>
  <li>FROM</li>
  <li>ON</li>
  <li>JOIN</li>
  <li>WHERE</li>
  <li>GROUP BY</li>
  <li>HAVING</li>
  <li>SELECT</li>
  <li>ORDER BY</li>
  <li>LIMIT</li>
</ol>

<h1 id="left-join-right-join">LEFT JOIN, RIGHT JOIN</h1>

<ul>
  <li>둘 다 OUTER JOIN</li>
  <li>LEFT는 첫 번째 테이블을 기준으로 두 번째 테이블을 조인, RIGHT는 두 번째 테이블이 기준</li>
  <li>그래서 OUTER JOIN은 순서가 중요 -&gt; 결과 자체의 측면과 성능적 측면 두 가지가 있음
    <ul>
      <li>우선 성능을 따지기 전에 결과 자체가 우리가 원하는 결과가 나와야 함 -&gt; 모든 레코드가 나와야 하는 테이블을 기준 테이블</li>
      <li>순서에 상관없이 결과가 같다고 판단되는 경우 성능을 따져야함 -&gt; 인덱스가 있는 테이블을 드리븐 테이블로 쓰자(LEFT면 두 번째)</li>
    </ul>
  </li>
  <li>만약 OUTER JOIN, INNER JOIN 어떤 것을 써도 된다면 옵티마이저가 드라이빙 테이블을 선택할 수 있는 INNER JOIN이 나음</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUDENT</span><span class="p">.</span><span class="n">NAME</span><span class="p">,</span> <span class="n">PROFESSOR</span><span class="p">.</span><span class="n">NAME</span> 
<span class="k">FROM</span> <span class="n">STUDENT</span> <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">PROFESSOR</span>
<span class="k">ON</span> <span class="n">STUDENT</span><span class="p">.</span><span class="n">PID</span> <span class="o">=</span> <span class="n">PROFESSOR</span><span class="p">.</span><span class="n">ID</span> 
<span class="k">WHERE</span> <span class="n">GRADE</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<h1 id="union">UNION</h1>

<ul>
  <li>같은 구조를 가지는 테이블을 합치는 것</li>
  <li>UNION은 두 테이블이 같은 데이터를 가질 경우 한 개만 최종 테이블에 반영되도록 함 (중복 허용 X)</li>
  <li>UNION ALL은 두 테이블이 같은 레코드를 가지더라도 합칠 경우 둘 다 최종 테이블에 반영(중복 허용)</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="err">필드이름</span> <span class="k">FROM</span> <span class="err">테이블이름</span>
<span class="k">UNION</span>
<span class="k">SELECT</span> <span class="err">필드이름</span> <span class="k">FROM</span> <span class="err">테이블이름</span>
</code></pre></div></div>

<h1 id="subquery">Subquery</h1>

<ul>
  <li>서브쿼리(subquery)는 다른 쿼리 내부에 포함되어 있는 SELETE 문을 의미</li>
  <li>서브쿼리는 다음과 같이 괄호()로 감싸서 표현</li>
  <li>메인쿼리 실행 중간에 서브쿼리 실행. 서브쿼리 종료 후, 메인쿼리도 실행 모두 마치고 종료</li>
  <li>메인쿼리 실행 되면 먼저 FROM으로 메인 테이블 불러오기 때문에, 서브쿼리는 메인쿼리의 컬럼 사용 가능</li>
  <li>서브쿼리는 가독성이 좋다는 장점이 있지만 JOIN 보다 성능이 느림 -&gt; 둘다 가능한 경우 JOIN 사용</li>
  <li>(최신 MySQL은 사용자가 서브쿼리문을 사용하면 자체적으로 조인문으로 변환하여 실행시키도록 업데이트 되었음)</li>
</ul>

<h2 id="서브쿼리를-사용할-수-있는-위치">서브쿼리를 사용할 수 있는 위치</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> 
<span class="k">FROM</span>
<span class="k">WHERE</span>
<span class="k">HAVING</span>
<span class="k">INSERT</span>
<span class="k">UPDATE</span>
</code></pre></div></div>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC-%EC%A0%95%EB%A6%AC?category=890808" target="_blank">인파, [MYSQL] 📚 서브쿼리 개념 &amp; 문법 💯 정리</a></li>
  <li><a href="https://www.navicat.com/en/company/aboutus/blog/1704-joins-versus-subqueries-which-is-faster" target="_blank">Navicat, Joins versus Subqueries: Which Is Faster?</a></li>
</ul>
:ET