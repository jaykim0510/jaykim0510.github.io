I"m<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#dockerfile" id="markdown-toc-dockerfile">Dockerfile</a></li>
  <li><a href="#dockerfile-instructions" id="markdown-toc-dockerfile-instructions">Dockerfile Instructions</a>    <ul>
      <li><a href="#from" id="markdown-toc-from">FROM</a>        <ul>
          <li><a href="#multi-stage-builds" id="markdown-toc-multi-stage-builds">Multi-Stage Builds</a></li>
        </ul>
      </li>
      <li><a href="#run" id="markdown-toc-run">RUN</a></li>
      <li><a href="#label" id="markdown-toc-label">LABEL</a></li>
      <li><a href="#env" id="markdown-toc-env">ENV</a></li>
    </ul>
  </li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />
<p><strong>Dockerfile instruction</strong></p>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />FROM</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />RUN</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />LABEL</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />ENV</li>
</ul>

<h1 id="dockerfile">Dockerfile</h1>

<h1 id="dockerfile-instructions">Dockerfile Instructions</h1>

<h2 id="from">FROM</h2>
<p>FROM은 빌드를 위한 stage를 초기화하고 이후의 명령어를 위한 <strong>기본 이미지를 만듭니다</strong>. 그렇기 때문에 유효한 Dockerfile은 반드시 FROM 명령어로부터 시작해야 합니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</code></li>
  <li><code class="language-plaintext highlighter-rouge">FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</code></li>
</ul>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># python:3.8-buster 이미지를 기본 이미지로 만듭니다</span>
<span class="k">FROM</span><span class="s"> python:3.8-buster</span>

<span class="c"># 현재 Dockerfile이 있는 위치에 있는 모든 파일을 새로 만든 이미지의 디렉토리 위치로 복사합니다</span>
<span class="k">COPY</span><span class="s"> . .</span>

<span class="c"># 복사된 requirements.txt 파일에 있는 라이브러리를 설치</span>
<span class="k">RUN </span>pip <span class="nb">install</span> <span class="nt">-r</span> requirements.txt
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># deeplearning:pytorch 라는 새로운 이미지를 만듭니다</span>
docker build <span class="nt">-t</span> deeplearning:pytorch <span class="nb">.</span>
</code></pre></div></div>

<h3 id="multi-stage-builds">Multi-Stage Builds</h3>
<p>One of the most challenging things about building images is keeping the image size down. Each instruction in the Dockerfile adds a layer to the image, and you need to remember to clean up any artifacts you don’t need before moving on to the next layer.</p>

<p><code class="language-plaintext highlighter-rouge">이미지를 빌드할 때 가장 중요한 것은 이미지의 사이즈를 줄이는 것</code>입니다. Dockerfile에서 각각의 명령어는 이미지의 layer를 하나씩 늘려나가게 됩니다. 이를 경량화하는 방법으로 RUN 명령어 사용시 Bash에서 &amp;&amp; 연산자를 사용할 수 있습니다.</p>

<p>또한 만약 여러 개의 이미지로부터 새로운 이미지를 불러와야 하는 상황이라면 <strong>FROM 과 COPY를 사용해 이미지를 경량화</strong> 할 수 있습니다. 이를 이용하면 각각의 이미지에서 <strong>원하는 파일만 선택적으로 복사해 다음 이미지로 전달시키고 필요없는 파일(다운로드 과정에서 필요한 코드와 같은 부수적인 파일들)은 제거할 수 있습니다</strong>. 이 방법을 <strong>Multi-Stage Builds</strong>라고 하는데 이 방법은 여러 개의 이미지로 부터 새로운 이미지를 생성할 때 여러 개의 Dockerfile이 필요없이 <strong>하나의 파일에 관리할 수 있다</strong>는 장점도 있습니다.</p>

<h2 id="run">RUN</h2>

<h2 id="label">LABEL</h2>

<h2 id="env">ENV</h2>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="https://docs.docker.com/engine/reference/builder/#cmd" target="_blank">Docker 공식문서</a></li>
</ul>
:ET