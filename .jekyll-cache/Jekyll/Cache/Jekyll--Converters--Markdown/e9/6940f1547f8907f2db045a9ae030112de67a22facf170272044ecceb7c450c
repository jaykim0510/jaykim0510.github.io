I"Æ<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#pytestê°€-ì¢‹ì€-ì´ìœ " id="markdown-toc-pytestê°€-ì¢‹ì€-ì´ìœ ">pytestê°€ ì¢‹ì€ ì´ìœ </a>    <ul>
      <li><a href="#less-boilerplate" id="markdown-toc-less-boilerplate">Less Boilerplate</a></li>
      <li><a href="#nicer-output" id="markdown-toc-nicer-output">Nicer Output</a></li>
      <li><a href="#less-to-learn" id="markdown-toc-less-to-learn">Less to Learn</a></li>
      <li><a href="#easier-to-manage-state-and-dependencies" id="markdown-toc-easier-to-manage-state-and-dependencies">Easier to Manage State and Dependencies</a></li>
      <li><a href="#easy-to-filter-tests" id="markdown-toc-easy-to-filter-tests">Easy to Filter Tests</a></li>
      <li><a href="#allows-test-parametrization" id="markdown-toc-allows-test-parametrization">Allows Test Parametrization</a></li>
      <li><a href="#has-a-plugin-based-architecture" id="markdown-toc-has-a-plugin-based-architecture">Has a Plugin-Based Architecture</a></li>
    </ul>
  </li>
  <li><a href="#fixtures-managing-state-and-dependencies" id="markdown-toc-fixtures-managing-state-and-dependencies">Fixtures: Managing State and Dependencies</a></li>
  <li><a href="#marks-categorizing-tests" id="markdown-toc-marks-categorizing-tests">Marks: Categorizing Tests</a></li>
  <li><a href="#parametrization-combining-tests" id="markdown-toc-parametrization-combining-tests">Parametrization: Combining Tests</a></li>
</ul>

<hr />

<p>Testing your code brings a wide variety of benefits. It increases your confidence that the code behaves as you expect and ensures that changes to your code wonâ€™t cause regressions. Writing and maintaining tests is hard work, so you should leverage all the tools at your disposal to make it as painless as possible. <code class="language-plaintext highlighter-rouge">pytest</code> is one of the best tools that you can use to boost your testing productivity.</p>

<p>If youâ€™ve written unit tests for your Python code before, then you may have used Pythonâ€™s built-in <code class="language-plaintext highlighter-rouge">unittest</code> module. <code class="language-plaintext highlighter-rouge">unittest</code> provides a solid base on which to build your test suite, but it has a few shortcomings.</p>

<p>A number of third-party testing frameworks attempt to address some of the issues with <code class="language-plaintext highlighter-rouge">unittest</code>, and <code class="language-plaintext highlighter-rouge">pytest</code> has proven to be one of the most popular. <code class="language-plaintext highlighter-rouge">pytest</code> is a feature-rich, plugin-based ecosystem for testing your Python code.</p>

<h1 id="pytestê°€-ì¢‹ì€-ì´ìœ ">pytestê°€ ì¢‹ì€ ì´ìœ </h1>

<h2 id="less-boilerplate">Less Boilerplate</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">unittest</code>ëŠ” ìƒì†ë°›ê³ , unittestì—ì„œ ì œê³µí•˜ëŠ” assertë¬¸ì„ ì‚¬ìš©í•´ì•¼í•¨
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_with_unittest.py
</span>
<span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">TestCase</span>

<span class="k">class</span> <span class="nc">TryTesting</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_always_passes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_always_fails</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">pytest</code>ëŠ” ë³´í†µ í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ë“¯ ì‘ì„±í•˜ê³ , íŒŒì´ì¬ì—ì„œ ì œê³µí•˜ëŠ” assertë¬¸ ì‚¬ìš©í•˜ë©´ ë¨
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_with_pytest.py
</span>
<span class="k">def</span> <span class="nf">test_always_passes</span><span class="p">():</span>
    <span class="k">assert</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">test_always_fails</span><span class="p">():</span>
    <span class="k">assert</span> <span class="bp">False</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Most functional tests follow the Arrange-Act-Assert model:</p>

<ul>
  <li><strong>Arrange</strong>, or set up, the conditions for the test</li>
  <li><strong>Act</strong> by calling some function or method</li>
  <li><strong>Assert</strong> that some end condition is true</li>
</ul>

<h2 id="nicer-output">Nicer Output</h2>

<ul>
  <li>ë¨¼ì € ì‹œìŠ¤í…œ ìƒíƒœ, íŒŒì´ì¬ ë²„ì „, ë£¨íŠ¸ ë””ë ‰í† ë¦¬, ë°œê²¬ëœ í…ŒìŠ¤íŠ¸ì˜ ìˆ˜ì™€ ê°™ì€ ì •ë³´ë¥¼ ì œê³µ</li>
  <li>í…ŒìŠ¤íŠ¸ ê²°ê³¼ì˜ ì•„ì›ƒí’‹ì€ ë‹¤ìŒê³¼ ê°™ìŒ
    <ul>
      <li>A dot (.) means that the test passed.</li>
      <li>An F means that the test has failed.</li>
      <li>An E means that the test raised an unexpected exception.</li>
    </ul>
  </li>
</ul>

<h2 id="less-to-learn">Less to Learn</h2>

<h2 id="easier-to-manage-state-and-dependencies">Easier to Manage State and Dependencies</h2>

<h2 id="easy-to-filter-tests">Easy to Filter Tests</h2>

<h2 id="allows-test-parametrization">Allows Test Parametrization</h2>

<h2 id="has-a-plugin-based-architecture">Has a Plugin-Based Architecture</h2>

<h1 id="fixtures-managing-state-and-dependencies">Fixtures: Managing State and Dependencies</h1>

<h1 id="marks-categorizing-tests">Marks: Categorizing Tests</h1>

<h1 id="parametrization-combining-tests">Parametrization: Combining Tests</h1>
:ET