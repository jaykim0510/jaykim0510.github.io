I":<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#운영체제" id="markdown-toc-운영체제">운영체제</a></li>
  <li><a href="#프로세스" id="markdown-toc-프로세스">프로세스</a>    <ul>
      <li><a href="#프로세스의-4가지-상태" id="markdown-toc-프로세스의-4가지-상태">프로세스의 4가지 상태</a></li>
      <li><a href="#프로세스-스케줄러" id="markdown-toc-프로세스-스케줄러">프로세스 스케줄러</a></li>
      <li><a href="#스레드" id="markdown-toc-스레드">스레드</a></li>
      <li><a href="#멀티프로세싱과-멀티스레딩" id="markdown-toc-멀티프로세싱과-멀티스레딩">멀티프로세싱과 멀티스레딩</a></li>
      <li><a href="#뮤텍스와-세마포어" id="markdown-toc-뮤텍스와-세마포어">뮤텍스와 세마포어</a></li>
    </ul>
  </li>
  <li><a href="#메모리" id="markdown-toc-메모리">메모리</a>    <ul>
      <li><a href="#가상-메모리" id="markdown-toc-가상-메모리">가상 메모리</a></li>
      <li><a href="#가변-분할" id="markdown-toc-가변-분할">가변 분할</a></li>
      <li><a href="#고정-분할" id="markdown-toc-고정-분할">고정 분할</a></li>
      <li><a href="#가상-메모리와-물리-메모리" id="markdown-toc-가상-메모리와-물리-메모리">가상 메모리와 물리 메모리</a></li>
      <li><a href="#페이지-교체-알고리즘" id="markdown-toc-페이지-교체-알고리즘">페이지 교체 알고리즘</a></li>
    </ul>
  </li>
  <li><a href="#운영체제-일문일답" id="markdown-toc-운영체제-일문일답">운영체제 일문일답</a>    <ul>
      <li><a href="#프로세스-1" id="markdown-toc-프로세스-1">프로세스</a></li>
      <li><a href="#메모리-1" id="markdown-toc-메모리-1">메모리</a></li>
    </ul>
  </li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<h1 id="운영체제">운영체제</h1>

<ul>
  <li>운영체제는 컴퓨터 전원을 켜면 가장 먼저 만나게 되는 소프트웨어 (ex. 윈도우, 맥OS, 리눅스, 안드로이드 등)</li>
  <li>컴퓨터 시스템의 자원들을 효율적으로 관리하며, 응용 프로그램과 하드웨어 간의 인터페이스 역할을 제공</li>
  <li>운영체제의 대표적인 역할
    <ul>
      <li>CPU 스케줄링과 프로세스 관리: CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생애주기를 관리</li>
      <li>메모리 관리: 한정된 메모리를 어떤 프로세스에 얼마나 할당할지 관리</li>
      <li>파일시스템 관리: 파일을 디스크에 어떤 방법으로 보관할지 관리</li>
      <li>사용자 인터페이스 제공 (CLI, GUI)</li>
      <li>하드웨어 인터페이스 제공</li>
    </ul>
  </li>
  <li>운영체제의 구조
    <ul>
      <li>커널(kernel): 프로세스 관리, 메모리 관리, 저장장치 관리와 같은 운영체제의 핵심적인 기능을 담당</li>
      <li>인터페이스(interface): 커널과 사용자 사이에서 명령을 전달하고, 실행 결과를 보여주는 역할 (리눅스에서는 이를 쉘이라고 함)</li>
    </ul>
  </li>
</ul>

<p><img src="../../images/os_1.png" alt="" /></p>

<h1 id="프로세스">프로세스</h1>

<ul>
  <li>하드디스크의 프로그램이 메모리에 올라온 상태
    <ul>
      <li>이 때 코드 영역, 데이터 영역 등은 사용자 영역에,</li>
      <li>프로세스를 처리하는데 필요한 정보를 가지고 있는 프로세스 제어블록은 운영체제 영역에 올라감</li>
    </ul>
  </li>
</ul>

<h2 id="프로세스의-4가지-상태">프로세스의 4가지 상태</h2>

<ul>
  <li>프로세스는 메모리에 올라온다고 CPU가 바로 작업을 처리해 주지는 않는다
    <ul>
      <li>프로세스는 4가지 상태를 오가게 된다</li>
      <li>준비상태
        <ul>
          <li>생성된 프로세스가 레디큐에서 CPU를 기다리고 있는 상태</li>
          <li>CPU는 준비상태에 있는 프로세스중 다음 프로세스를 선택해야 한다 (이를 디스패치 라고함)</li>
        </ul>
      </li>
      <li>실행상태
        <ul>
          <li>CPU를 얻어 실제 작업을 수행하는 상태</li>
          <li>CPU는 프로세스 제어블록을 전달 받는다</li>
          <li>시간내 작업이 끝나면 종료상태, 못 끝내면 다시 준비상태로 돌려보낸다</li>
          <li>작업도중 입출력이 필요하면 대기상태로 보낸다</li>
        </ul>
      </li>
      <li>대기상태
        <ul>
          <li>프로세스가 입출력을 요청하면 입출력 관리자가 입출력을 완료하기 전까지 프로세스를 대기상태로 옮겨둔다</li>
          <li>입출력이 완료되면 다시 준비상태로 돌려보낸다</li>
        </ul>
      </li>
      <li>종료상태
        <ul>
          <li>작업이 종료되고 프로세스 제어블록이 사라짐</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="프로세스-스케줄러">프로세스 스케줄러</h2>

<ul>
  <li>레디큐에 있는 준비상태의 프로세스중 어떤 것을 실행 상태로 옮길 것인가</li>
  <li>FCFS: 준비상태에 들어온 순서대로 처리</li>
  <li>SJF: CPU 소요시간이 짧은 프로세스부터 처리</li>
  <li>SRTF: SJF + 더 짧은 프로세스 들어오면 다시 스케줄링</li>
  <li>Round Robin: 모든 프로세스에 동일한 시간을 할당, 시간 다되면 다시 레디큐의 맨 뒤로</li>
</ul>

<h2 id="스레드">스레드</h2>

<ul>
  <li>사실 스케줄러에 의해 처리되는 단위는 프로세스가 아니라 스레드다</li>
  <li>스레드는 프로세스에 정의된 작업을 처리하는 실행의 단위</li>
  <li>스레드는 실행 단위이기 때문에 실행할 때마다 달라져야 하는 스택 영역을 제외하고 나머지 영역은 스레드끼리 공유</li>
  <li>스레드의 이러한 메모리 영역 공유 덕분에 멀티스레딩만의 장점이 있는 것</li>
</ul>

<h2 id="멀티프로세싱과-멀티스레딩">멀티프로세싱과 멀티스레딩</h2>
<ul>
  <li>멀티 프로세싱
    <ul>
      <li>멀티스레딩에 대해 알아보기 전에 먼저 멀티 프로세싱을 살펴보자</li>
      <li>점차 CPU 한개에 더 많은 코어수가 생기고, 분산 시스템을 지원하면서,</li>
      <li>하나의 프로세스를 여러 프로세서가 처리하길 원했다</li>
      <li>이를 위해 멀티 프로세싱은 하나의 프로세스를 여러 프로세스로 만들고, 다수의 프로세서에게 처리하도록 했다</li>
      <li>하지만 프로세스 단위는 무겁고, 메모리 낭비가 심해 이를 개선할 필요가 있었다</li>
    </ul>
  </li>
  <li>멀티 스레딩
    <ul>
      <li>메모리 낭비를 개선하고자, 프로세스를 여러 스레드 단위로 나누었는데 이를 멀티 스레딩이라고 한다</li>
      <li>멀티 스레딩은 메모리 자원 공유로 인해 얻는 장점도 있지만, 이로 인해 생기는 단점도 있다</li>
      <li>장점
        <ul>
          <li>메모리 절약, 빠른 컨텍스트 스위칭</li>
        </ul>
      </li>
      <li>단점
        <ul>
          <li>메모리 영역중 여러 작업이 동시에 접근할 때 문제가 생기는 영역을 임계 영역이라고 하는데,</li>
          <li>멀티 스레딩은 메모리 영역 공유로 임계 영역을 여러 작업이 동시에 접근하게 될 위험이 생긴다</li>
          <li>여러 작업이 동시에 접근할 때 생기는 대표적인 문제가 스레드끼리 같은 영역에 대해 서로 다른 결과를 가지는 비동기화 문제이다</li>
          <li>그래서 동기화를 위해 작업 처리 순서와 공유자원에 대한 접근을 컨트롤 해야 하는데 이 때 등장한 개념이 뮤텍스와 세마포어이다</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="뮤텍스와-세마포어">뮤텍스와 세마포어</h2>

<ul>
  <li>뮤텍스
    <ul>
      <li>접근 후 락을 걸어서 못들어오게 한다</li>
      <li>이진 세마포어라고도 한다</li>
    </ul>
  </li>
  <li>세마포어
    <ul>
      <li>카운팅 세마포어: 접근 가능한 수를 카운팅하며 접근을 컨트롤한다</li>
    </ul>
  </li>
  <li>뮤텍스와 세마포어는 비동기화 문제를 해결해주지만, 잘못되면 과도한 락으로 병목현상이 생기고 성능을 저하시킬 수 있다</li>
  <li>최악의 경우 뫼비우스의 띠처럼 데드락으로 인해 아예 프로세서가 작업을 처리하지 못하게 될 수도 있다</li>
</ul>

<h1 id="메모리">메모리</h1>

<ul>
  <li>CPU의 작업공간, 프로세스가 올라오는 공간</li>
  <li>메모리는 1Byte 단위로 주소를 가진다</li>
  <li>CPU가 필요한 데이터의 메모리 주소는 MAR 레지스터에 보관한다</li>
  <li>메모리 관리는 MMU (메모리 관리 유닛)라는 메모리 관리자가 한다</li>
</ul>

<h2 id="가상-메모리">가상 메모리</h2>

<ul>
  <li>프로그램이 실행되면 프로세스의 상태로 메모리에 올라온다</li>
  <li>하지만 메모리에 남은 크기보다 더 큰 크기의 프로세스를 실행해야 할 때도 있다</li>
  <li>이런 문제를 해결해준 것이 바로 오버레이(overlay)다</li>
  <li>오버레이는 프로세스를 더 작은 크기로 잘라 필요한 조각만 메모리에 올리고,</li>
  <li>바로 사용하지 않는 조각들은 스왑 영역에 올려둔다</li>
  <li>어떤 조각을 메모리에 올릴지는 CPU의 PC(프로그램 카운터) 레지스터에 의해 결정된다</li>
  <li>프로세스 조각을 올릴 메모리의 크기는 어떻게 할까? 조각의 크기에 비례해 가변 분할? 조각 크기에 상관 없이 고정 분할?</li>
</ul>

<h2 id="가변-분할">가변 분할</h2>

<ul>
  <li>프로세스의 크기에 비례해 메모리를 자른다</li>
  <li>연속된 공간에 배치 가능</li>
  <li>가용 가능한 메모리중에 프로세스 크기에 맞는 메모리가 없으면 남은 메모리를 합친다 (조각 모음)</li>
  <li>연속된 공간에 배치해서 프로세스를 관리하기는 편하지만, 계속 프로세스를 재배열 하는 조각 모음이 일어난다</li>
</ul>

<h2 id="고정-분할">고정 분할</h2>

<ul>
  <li>프로세스 크기에 상관없이 일정한 크기로 메모리를 자른다</li>
  <li>프로세스가 고정된 크기보다 크면 작게 나누어 여기저기 가능한 메모리에 흩어서 배치한다</li>
  <li>메모리 크기가 고정되기 때문에 작게 남은 부분을 활용할 수 없다 -&gt; 메모리 낭빕가 생긴다</li>
  <li>메모리 관리는 편하지만 낭비가 발생한다</li>
</ul>

<h2 id="가상-메모리와-물리-메모리">가상 메모리와 물리 메모리</h2>

<ul>
  <li>컴퓨터를 사용하면서 어떤 프로세스가 스왑 영역에 있고, 메모리 영역에 있는지 고민해 본 적은 크게 없을 것이다</li>
  <li>왜냐하면 우리 눈에 보이는 메모리는 0번지부터 시작되는 16,777,216TB 크기의 가상 메모리이기 때문이다</li>
  <li>이러한 가상 메모리에 있는 논리 주소는 페이지 매핑 테이블에 의해 알아서 물리주소로 매핑된다</li>
  <li>만약 매핑된 물리 주소가 메모리 영역이면 해당 메모리 주소를 이용하고, 스왑 영역이면 메모리에 올리고 그 메모리 주소를 이용한다</li>
  <li>이러한 과정은 메모리 관리자가 페이지 교체 알고리즘에 따라 적절히 가져오기, 배치, 재배치 기능을 수행함으로써 이루어진다</li>
</ul>

<h2 id="페이지-교체-알고리즘">페이지 교체 알고리즘</h2>

<ul>
  <li>FIFO 페이지 교체
    <ul>
      <li>가장 간단한 페이지 교체 알고리즘으로 FIFO(first-in first-out)의 흐름을 가진다. 즉, 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것이다.</li>
    </ul>
  </li>
  <li>LRU 페이지 교체(LRU Page Replacement)
    <ul>
      <li>최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.</li>
    </ul>
  </li>
  <li>LFU 페이지 교체(LFU Page Replacement)
    <ul>
      <li>참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.</li>
    </ul>
  </li>
</ul>

<h1 id="운영체제-일문일답">운영체제 일문일답</h1>

<h2 id="프로세스-1">프로세스</h2>
<ul>
  <li>운영체제란?</li>
  <li>프로세스와 스레드</li>
  <li>멀티 프로세스 vs 멀티 스레드</li>
  <li>스케줄러</li>
  <li>동기와 비동기</li>
  <li>프로세스 동기화</li>
  <li>프로세스 주소 공간</li>
  <li>인터럽트(Interrupt)</li>
  <li>시스템 콜(System Call)</li>
  <li>PCB와 Context Switching</li>
  <li>IPC(Inter Process Communication)</li>
  <li>임계 구역(Critical Section)</li>
  <li>데드락(DeadLock)</li>
  <li>경쟁 상태(Race Condition)</li>
  <li>세마포어와 뮤텍스</li>
  <li>스레드 세이프(Thread-safe)</li>
</ul>

<h2 id="메모리-1">메모리</h2>
<ul>
  <li>메모리 관리 전략</li>
  <li>가상 메모리</li>
  <li>캐시의 지역성</li>
  <li>페이징과 세그먼테이션</li>
  <li>페이지 교체 알고리즘</li>
</ul>

<h1 id="참고">참고</h1>
<ul>
  <li><a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner" target="_blank">JaeYeopHan/Interview_Question_for_Beginner</a></li>
  <li><a href="https://github.com/WeareSoft/tech-interview" target="_blank">WeareSoft/tech-interview</a></li>
  <li><a href="https://gyoogle.dev/blog/guide/%EB%A9%B4%EC%A0%91%20%EC%A4%80%EB%B9%84.html" target="_blank">gyoogle, Tech Interview 준비</a></li>
  <li><a href="https://blex.me/@baealex/%EC%B7%A8%EC%A4%80%EC%83%9D%EC%9D%B4-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84" target="_blank">배진오, 신입 개발자 기술면접 준비하기</a></li>
  <li><a href="https://dingrr.com/blog/post/python-python-%EB%A9%B4%EC%A0%91-%EC%98%88%EC%A0%9C-2%ED%8E%B8" target="_blank">[PYTHON] Python 면접 예제 2편</a></li>
  <li><a href="https://syujisu.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%A7%81%EB%AC%B4-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8?category=871132" target="_blank">exp_blog, 데이터베이스 직무 면접 질문</a></li>
  <li><a href="https://mangkyu.tistory.com/88" target="_blank">망나니 개발자 CS 준비</a></li>
</ul>
:ET