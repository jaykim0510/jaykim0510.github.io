I"fA<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#heap" id="markdown-toc-heap">Heap</a>    <ul>
      <li><a href="#우선순위-큐" id="markdown-toc-우선순위-큐">우선순위 큐</a></li>
      <li><a href="#힙" id="markdown-toc-힙">힙</a></li>
    </ul>
  </li>
  <li><a href="#heap-관련-연산" id="markdown-toc-heap-관련-연산">Heap 관련 연산</a>    <ul>
      <li><a href="#힙에-삽입이-발생한-경우" id="markdown-toc-힙에-삽입이-발생한-경우">힙에 삽입이 발생한 경우</a></li>
      <li><a href="#힙에-삭제가-발생한-경우" id="markdown-toc-힙에-삭제가-발생한-경우">힙에 삭제가 발생한 경우</a></li>
    </ul>
  </li>
  <li><a href="#heap-구현" id="markdown-toc-heap-구현">Heap 구현</a>    <ul>
      <li><a href="#파이썬의-heapq-모듈" id="markdown-toc-파이썬의-heapq-모듈">파이썬의 heapq 모듈</a></li>
      <li><a href="#파이썬-리스트를-이용해-직접-구현" id="markdown-toc-파이썬-리스트를-이용해-직접-구현">파이썬 리스트를 이용해 직접 구현</a></li>
    </ul>
  </li>
  <li><a href="#heap-활용" id="markdown-toc-heap-활용">Heap 활용</a></li>
</ul>

<hr />

<h1 id="heap">Heap</h1>

<blockquote>
  <p>In many CS applications, we only need to access the largest or smallest element in the dataset. how do we efficiently access the largest or smallest element in the current dataset? The answer would be heap!</p>
</blockquote>

<h2 id="우선순위-큐">우선순위 큐</h2>

<ul>
  <li>힙과 우선순위 큐는 다른 의미</li>
  <li>힙은 데이터 구조(low-level), 우선순위 큐는 추상 자료형(high-level)</li>
  <li>힙은 우선순위 큐를 구현하는 한 가지 방법</li>
  <li>힙 말고도 배열, 링크드 리스트로 우선순위 큐를 구현할 수 있음(물론 시간 복잡도 차이 있음)</li>
</ul>

<h2 id="힙">힙</h2>

<ul>
  <li>힙은 <strong>완전 이진 트리</strong>의 특별한 케이스
    <ul>
      <li>완전 이진 트리: 이진 트리 + 리프 노드가 왼쪽부터 채워짐</li>
    </ul>
  </li>
  <li>각 노드들은 자식 노드보다 크다 (최대힙) (최소힙은 반대)</li>
</ul>

<h1 id="heap-관련-연산">Heap 관련 연산</h1>

<ul>
  <li>삽입 연산: O(logN)</li>
  <li>삭제 연산: O(logN)</li>
  <li>최대값/최소값 얻기: O(1)</li>
  <li>element가 힙에서 삽입/삭제되어도 계속 힙 성질이 유지되어야함
    <ul>
      <li>heapify 연산으로 힙 성질을 유지함</li>
      <li>한 번 삽입/삭제 연산이 일어날 때마다 heapify 실행</li>
      <li>heapify: 부모 노드와 자식 노드의 값을 계속 비교하며 스왑</li>
    </ul>
  </li>
</ul>

<h2 id="힙에-삽입이-발생한-경우">힙에 삽입이 발생한 경우</h2>

<ul>
  <li>삽입된 노드는 리프 노드에 추가 -&gt; 추가된 리프 노드에서 부터 heapify</li>
</ul>

<h2 id="힙에-삭제가-발생한-경우">힙에 삭제가 발생한 경우</h2>

<ul>
  <li>삭제는 항상 루트 노드에서 발생 -&gt; 루트 노드의 빈자리는 리프 노드가 채움 -&gt; 루트 노드에서 부터 heapify</li>
</ul>

<h1 id="heap-구현">Heap 구현</h1>

<h2 id="파이썬의-heapq-모듈">파이썬의 heapq 모듈</h2>

<ul>
  <li>힙을 파이썬에서 사용할 때는 간단히 heapq 모듈을 이용해 사용 가능
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">heapq</span>

<span class="n">heap_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Insert
</span><span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap_list</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">heap_list</span> <span class="o">==</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span>

<span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap_list</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">heap_list</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="c1"># Get
</span><span class="n">heap_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Delete
</span><span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap_list</span><span class="p">)</span>

<span class="c1"># List를 힙으로 만들 떄
</span><span class="n">tmp_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">heapq</span><span class="p">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">tmp_list</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="파이썬-리스트를-이용해-직접-구현">파이썬 리스트를 이용해 직접 구현</h2>

<ul>
  <li>힙을 직접 구현할 때는 리스트를 사용함
    <ul>
      <li>완전 이진 트리의 성질을 가지도록 하기 위해 부모 노드와 자식 노드의 관계를 정의해야함
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root node: 1
parent node: n
left child node: 2*n
right child node: 2*n + 1
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>heapify
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># 추출, 힙리스트, 힙정렬 모든 곳에 쓰임
</span>  <span class="k">def</span> <span class="nf">heapify</span><span class="p">(</span><span class="n">myheap</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
      <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">myheap</span><span class="p">)</span>
      <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:</span>
          <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">idx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
          <span class="n">smallest_idx</span> <span class="o">=</span> <span class="n">idx</span>
          <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="ow">and</span> <span class="n">myheap</span><span class="p">[</span><span class="n">smallest_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">myheap</span><span class="p">[</span><span class="n">left</span><span class="p">]:</span>
              <span class="n">smallest_idx</span> <span class="o">=</span> <span class="n">left</span>
          <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="ow">and</span> <span class="n">myheap</span><span class="p">[</span><span class="n">smallest_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">myheap</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
              <span class="n">smallest_idx</span> <span class="o">=</span> <span class="n">right</span>
          <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">smallest_idx</span><span class="p">:</span>
              <span class="n">myheap</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">myheap</span><span class="p">[</span><span class="n">smallest_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">myheap</span><span class="p">[</span><span class="n">smallest_idx</span><span class="p">],</span> <span class="n">myheap</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
              <span class="n">idx</span> <span class="o">=</span> <span class="n">smallest_idx</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="k">break</span>


  <span class="c1"># heap에 원소 삽입
</span>  <span class="k">def</span> <span class="nf">heap_push</span><span class="p">(</span><span class="n">myheap</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>
      <span class="n">myheap</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
      <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">myheap</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="k">while</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">parent</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">//</span> <span class="mi">2</span>
          <span class="k">if</span> <span class="n">myheap</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">myheap</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
              <span class="n">myheap</span><span class="p">[</span><span class="n">parent</span><span class="p">],</span> <span class="n">myheap</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">myheap</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">myheap</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span>
              <span class="n">idx</span> <span class="o">=</span> <span class="n">parent</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="k">break</span>


  <span class="c1"># heap에서 루트 노드를 추출
</span>  <span class="k">def</span> <span class="nf">heap_pop</span><span class="p">(</span><span class="n">myheap</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">myheap</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="s">"There is no element to pop"</span><span class="p">)</span>
          <span class="k">return</span>
      <span class="n">pop_elem</span> <span class="o">=</span> <span class="n">myheap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 8
</span>      <span class="n">new_root</span> <span class="o">=</span> <span class="n">myheap</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 9
</span>      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">myheap</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
          <span class="n">myheap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_root</span>
          <span class="n">heapify</span><span class="p">(</span><span class="n">myheap</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">pop_elem</span>

  <span class="c1"># heap으로 만든다
</span>  <span class="k">def</span> <span class="nf">heap_list</span><span class="p">(</span><span class="n">mylist</span><span class="p">):</span>
      <span class="n">myheap</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">mylist</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">myheap</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
          <span class="n">heapify</span><span class="p">(</span><span class="n">myheap</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">myheap</span>

  <span class="c1"># heap을 입력 받아서 정렬된 리스트를 리턴
</span>  <span class="k">def</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">List</span><span class="p">):</span>
      <span class="n">answer</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">len_heap</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_heap</span><span class="p">):</span>
          <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">heap_pop</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">answer</span>

  <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
  <span class="n">heap_x</span> <span class="o">=</span> <span class="n">heap_list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"주어진 힙: </span><span class="si">{</span><span class="n">heap_x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"정렬된 리스트: </span><span class="si">{</span><span class="n">heap_sort</span><span class="p">(</span><span class="n">heap_x</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="heap-활용">Heap 활용</h1>

<ul>
  <li>
    <p>힙 정렬</p>
  </li>
  <li>
    <p>Top-K 문제</p>
  </li>
  <li>
    <p>K-th 요소</p>
  </li>
</ul>
:ET