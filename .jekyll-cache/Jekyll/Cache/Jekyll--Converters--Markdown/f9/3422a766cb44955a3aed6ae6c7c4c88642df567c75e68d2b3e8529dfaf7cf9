I"‡+<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#ë™ì ì¸-ì›¹í˜ì´ì§€" id="markdown-toc-ë™ì ì¸-ì›¹í˜ì´ì§€">ë™ì ì¸ ì›¹í˜ì´ì§€</a></li>
  <li><a href="#state" id="markdown-toc-state">State</a>    <ul>
      <li><a href="#usestate" id="markdown-toc-usestate">useState</a></li>
      <li><a href="#stateì˜-íŠ¹ì„±" id="markdown-toc-stateì˜-íŠ¹ì„±">Stateì˜ íŠ¹ì„±</a></li>
    </ul>
  </li>
  <li><a href="#re-rendering" id="markdown-toc-re-rendering">Re-rendering</a>    <ul>
      <li><a href="#state-as-a-snapshot" id="markdown-toc-state-as-a-snapshot">State as a snapshot</a></li>
      <li><a href="#queueing-a-series-of-state-updates" id="markdown-toc-queueing-a-series-of-state-updates">Queueing a series of state updates</a></li>
      <li><a href="#updating-objects-in-state" id="markdown-toc-updating-objects-in-state">Updating objects in state</a></li>
    </ul>
  </li>
  <li><a href="#ì°¸ê³ " id="markdown-toc-ì°¸ê³ ">ì°¸ê³ </a></li>
</ul>

<hr />

<h1 id="ë™ì ì¸-ì›¹í˜ì´ì§€">ë™ì ì¸ ì›¹í˜ì´ì§€</h1>

<ul>
  <li>ìš”ì¦˜ ì›¹í˜ì´ì§€ëŠ” ëŒ€ë¶€ë¶„ ë™ì ì´ë‹¤</li>
  <li>ë™ì ì¸ ìš”ì†ŒëŠ” ì‹œê°„ì— ë”°ë¼ ë³€í•˜ëŠ” ê²ƒë„ ìˆê³ , ìœ ì €ì˜ ì´ë²¤íŠ¸ì— ë”°ë¼ ë³€í•˜ëŠ” ê²ƒë„ ìˆë‹¤</li>
  <li>ì˜ˆë¥¼ ë“¤ì–´ ê²€ìƒ‰ì°½ì— ì…ë ¥í•œ í…ìŠ¤íŠ¸ê°€ UIì— ë°˜ì˜ë˜ëŠ” ê²ƒ, êµ¬ë§¤í•  ìƒí’ˆì˜ ê°œìˆ˜ë¥¼ +,- ë²„íŠ¼ìœ¼ë¡œ ëˆ„ë¥¼ ë•Œë§ˆë‹¤ ìˆ«ìê°€ ë³€í•˜ëŠ” ê²ƒ, ë‹¤í¬ëª¨ë“œ/ë¼ì´íŠ¸ëª¨ë“œì— ë”°ë¼ í™”ë©´ ìƒ‰ê¹”ì´ ë°”ë€ŒëŠ” ê²ƒ ë“±ì´ ë™ì ì¸ ìš”ì†Œë¼ê³  í•  ìˆ˜ ìˆë‹¤</li>
</ul>

<p><br /></p>

<ul>
  <li>ë¦¬ì•¡íŠ¸ì—ì„œëŠ” ì´ë ‡ê²Œ <strong>ë³€í•˜ëŠ” ë°ì´í„°ë¥¼ ìƒíƒœ(state)</strong>ë¼ê³  í•œë‹¤</li>
  <li>ìƒíƒœê°€ ë³€í•  ë•Œë§ˆë‹¤ ìƒíƒœë¥¼ í¬í•¨í•˜ê³  ìˆëŠ” <strong>ì»´í¬ë„ŒíŠ¸ê°€ ì—…ë°ì´íŠ¸ë˜ëŠ” ê²ƒì„ ë¦¬ë Œë”ë§(re-rendering)</strong>ì´ë¼ê³  í•œë‹¤</li>
</ul>

<h1 id="state">State</h1>

<ul>
  <li>ìƒíƒœëŠ” í˜„ì¬ ê°’ì„ ì €ì¥í•´ë‘” ë³€ìˆ˜ì™€ ë¹„ìŠ·í•˜ë©° ë¦¬ì•¡íŠ¸ ì»´í¬ë„ŒíŠ¸ê°€ ê¸°ì–µí•˜ê³  ìˆëŠ” ê°’ì´ë¼ê³  í•  ìˆ˜ ìˆë‹¤</li>
  <li>ì¼ë°˜ ë³€ìˆ˜ëŠ” ê°’ì´ ë³€ê²½ë¼ë„ í™”ë©´ì´ ì—…ë°ì´íŠ¸ ë˜ì§€ ì•Šì§€ë§Œ, ë¦¬ì•¡íŠ¸ì˜ ìƒíƒœëŠ” ë³€ê²½ë˜ë©´ í™”ë©´ì´ ì—…ë°ì´íŠ¸ ëœë‹¤</li>
  <li>ë¦¬ì•¡íŠ¸ ì»´í¬ë„ŒíŠ¸ê°€ ìƒíƒœì˜ í˜„ì¬ ê°’ì„ ì €ì¥í•´ë’€ë‹¤ê°€ ìƒíƒœ ê°’ì´ í˜„ì¬ ê°’ê³¼ ë¹„êµí•´ ë³€ê²½ëœ ê²½ìš°, ë¦¬ì•¡íŠ¸ëŠ” ì´ëŸ¬í•œ ë³€í™”ë¥¼ ì—…ë°ì´íŠ¸í•´ í™”ë©´ì— ë°˜ì˜í•œë‹¤</li>
</ul>

<h2 id="usestate">useState</h2>

<ul>
  <li>ë¦¬ì•¡íŠ¸ì—ì„œ ìƒíƒœëŠ” <code class="language-plaintext highlighter-rouge">useState</code> ë¼ëŠ” í›…ì„ ì´ìš©í•´ ì •ì˜í•  ìˆ˜ ìˆë‹¤</li>
  <li><code class="language-plaintext highlighter-rouge">useState</code>ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì€ ë¦¬ì•¡íŠ¸ ì»´í¬ë„ŒíŠ¸ì—ê²Œ ë¬´ì–¸ê°€ë¥¼ ê¸°ì–µí•˜ë¼ê³  í•˜ëŠ” ê²ƒê³¼ ê°™ë‹¤</li>
  <li><code class="language-plaintext highlighter-rouge">useState</code> í•¨ìˆ˜ëŠ” ì¸ìë¡œ ìƒíƒœì˜ ì´ˆê¸° ê°’ì„ ë°›ê³ , <strong>[state, setState]</strong> ìŒì„ ë°˜í™˜í•œë‹¤</li>
  <li>ë¦¬ì•¡íŠ¸ì—ì„œëŠ” ìƒíƒœ(state)ê°€ ë³€í™”í•  ë•Œë§ˆë‹¤ í™”ë©´ì— ê²°ê³¼ë¥¼ ë°˜ì˜í•œë‹¤</li>
  <li>ë¦¬ì•¡íŠ¸ëŠ” ìƒíƒœê°€ ì„¸í„° í•¨ìˆ˜(setState)ì— ì˜í•´ ë³€ê²½ë  ë•Œë§Œ í™”ë©´ì— ê²°ê³¼ë¥¼ ë°˜ì˜í•œë‹¤</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="stateì˜-íŠ¹ì„±">Stateì˜ íŠ¹ì„±</h2>

<ul>
  <li>State is isolated and private
    <ul>
      <li>State is not tied to a particular function call or a place in the code, but itâ€™s â€œlocalâ€ to the specific place on the screen</li>
      <li>What if you wanted both galleries to keep their states in sync? The right way to do it in React is to remove state from child components and add it to their closest shared parent</li>
    </ul>
  </li>
</ul>

<h1 id="re-rendering">Re-rendering</h1>

<ul>
  <li>The componentâ€™s (or one of its ancestorsâ€™) state has been updated</li>
  <li>Updating your componentâ€™s state automatically queues a render</li>
  <li>â€œRenderingâ€ is React calling your components.
    <ul>
      <li>On initial render, React will call the root component.</li>
      <li>For subsequent renders, React will call the function component whose state update triggered the render</li>
    </ul>
  </li>
  <li>
    <p>After rendering (calling) your components, React will modify the DOM.</p>

    <ul>
      <li>For the initial render, React will use the appendChild() DOM API to put all the DOM nodes it has created on screen.</li>
      <li>For re-renders, React will apply the minimal necessary operations (calculated while rendering!) to make the DOM match the latest rendering output.</li>
    </ul>
  </li>
  <li>React only changes the DOM nodes if thereâ€™s a difference between renders. For example, here is a component that re-renders with different props passed from its parent every second. Notice how you can add some text into the <code class="language-plaintext highlighter-rouge">&lt;input&gt;</code>, updating its value, but the text doesnâ€™t disappear when the component re-renders:</li>
  <li>After rendering is done and React updated the DOM, the browser will repaint the screen. Although this process is known as â€œbrowser renderingâ€, weâ€™ll refer to it as â€œpaintingâ€</li>
</ul>

<h2 id="state-as-a-snapshot">State as a snapshot</h2>

<ul>
  <li>Setting state requests a new re-render, but does not change it in the already running code</li>
  <li>â€œRenderingâ€ means that React is calling your component, which is a function. The JSX you return from that function is like a snapshot of the UI in time. Its props, event handlers, and local variables were all calculated using its state at the time of the render.</li>
</ul>

<p><img src="/images/react_state_1.png" alt="" /></p>

<ul>
  <li>State actually â€œlivesâ€ in React itselfâ€”as if on a shelf!â€”outside of your function. When React calls your component, it gives you a snapshot of the state for that particular render. Your component returns a snapshot of the UI with a fresh set of props and event handlers in its JSX, all calculated using the state values from that render!</li>
</ul>

<p><img src="/images/react_state_2.png" alt="" /></p>

<ul>
  <li>ì•„ë˜ ì½”ë“œë¥¼ ë³´ì</li>
</ul>

<p><img src="/images/react_state_3.png" alt="" /></p>

<ul>
  <li>ë²„íŠ¼ í´ë¦­ í•œ ë²ˆì— <code class="language-plaintext highlighter-rouge">setNumber</code> í•¨ìˆ˜ê°€ ì„¸ ë²ˆ í˜¸ì¶œëœë‹¤. í•˜ì§€ë§Œ í´ë¦­ í•˜ë©´ ìˆ«ìëŠ” <code class="language-plaintext highlighter-rouge">1</code> ë°–ì— ì¦ê°€í•˜ì§€ ì•ŠëŠ”ë‹¤</li>
  <li>ì™œëƒí•˜ë©´ setter í•¨ìˆ˜ëŠ” ìƒíƒœ(state)ë¥¼ ì½”ë“œ ì‹¤í–‰ ì¤‘ì— ë°”ê¾¸ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ì»´í¬ë„ŒíŠ¸ê°€ ë°˜í™˜ë˜ëŠ” ì‹œì ì— ë°”ê¾¸ê¸° ë•Œë¬¸ì´ë‹¤</li>
  <li>ê·¸ë˜ì„œ í•¨ìˆ˜ê°€ ì„¸ ë²ˆ í˜¸ì¶œë˜ëŠ” ë™ì•ˆ <code class="language-plaintext highlighter-rouge">number</code>ëŠ” ê³„ì† <code class="language-plaintext highlighter-rouge">0</code>ì´ë‹¤</li>
  <li>
    <p>ë‹¤ì‹œ ë§í•´ ìƒíƒœ ë³€ìˆ˜ëŠ” ë Œë”ë§ì¤‘ì—ëŠ” ê³ ì •ë˜ì–´ ìˆë‹¤</p>
  </li>
  <li>Setting state requests a new render.</li>
  <li>React stores state outside of your component, as if on a shelf.</li>
  <li>When you call useState, React gives you a snapshot of the state for that render.</li>
  <li>Variables and event handlers donâ€™t â€œsurviveâ€ re-renders. Every render has its own event handlers.</li>
  <li>Every render (and functions inside it) will always â€œseeâ€ the snapshot of the state that - React gave to that render.</li>
  <li>You can mentally substitute state in event handlers, similarly to how you think about the rendered JSX.</li>
  <li>Event handlers created in the past have the state values from the render in which they were created.</li>
</ul>

<h2 id="queueing-a-series-of-state-updates">Queueing a series of state updates</h2>

<ul>
  <li>ì—¬ëŸ¬ ë²ˆì˜ setter í•¨ìˆ˜ í˜¸ì¶œì„ ë‹¤ìŒ ë Œë”ë§ í•˜ë‚˜ì— ë°˜ì˜í•˜ê³  ì‹¶ì„ ë•Œ, React ë°°ì¹˜ ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ì•Œë©´ ë„ì›€ì´ ëœë‹¤</li>
  <li>ë¦¬ì•¡íŠ¸ëŠ” ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì•ˆì— ìˆëŠ” ëª¨ë“  ì½”ë“œë¥¼ ì‹¤í–‰í•œ í›„ì— ìƒíƒœ ë³€ìˆ˜ë¥¼ ì—…ë°ì´íŠ¸ í•œë‹¤</li>
</ul>

<p><br /></p>

<ul>
  <li>ë§Œì•½ ë‹¤ìŒ ë Œë”ë§ ì „ê¹Œì§€ ì—¬ëŸ¬ ë²ˆì— ê±¸ì³ ìƒíƒœ ê°’ì´ ë°”ë€Œê¸¸ ì›í•˜ë©´, setter í•¨ìˆ˜ ì•ˆì— í™”ì‚´í‘œ í•¨ìˆ˜ í˜•íƒœë¡œ ì¸ìë¥¼ ì£¼ë©´ ëœë‹¤. setter í•¨ìˆ˜ ì•ˆì— ìˆëŠ” í™”ì‚´í‘œ í•¨ìˆ˜ëŠ” ìƒíƒœ ê°’ì˜ ì´ì „ ê°’ì„ ë°”íƒ•ìœ¼ë¡œ ê°’ì„ ë³€ê²½í•œë‹¤</li>
</ul>

<p><img src="/images/react_state_4.png" alt="" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">n =&gt; n + 1</code> ê³¼ ê°™ì€ í•¨ìˆ˜ë¥¼ updater í•¨ìˆ˜ë¼ê³  í•œë‹¤</li>
  <li>updater í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ setter í•¨ìˆ˜ë¥¼ ì‘ì„±í•œ ê²½ìš° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë™ì‘í•œë‹¤
    <ul>
      <li>updater í•¨ìˆ˜ë¥¼ íì— ë‹´ì•„ë‘ê³  ë¨¼ì € ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì•ˆì— ìˆëŠ” ë‹¤ë¥¸ ì½”ë“œë¥¼ ëª¨ë‘ ì‹¤í–‰í•œë‹¤</li>
      <li>ë¦¬ì•¡íŠ¸ëŠ” íì— ìˆëŠ” ëª¨ë“  updater í•¨ìˆ˜ë¥¼ ì§€ë‚˜ë©° ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸ í•˜ê³  ìµœì¢… ìƒíƒœë¥¼ ë°˜í™˜í•œë‹¤</li>
    </ul>
  </li>
  <li>
    <p>updater í•¨ìˆ˜ë¿ë§Œ ì•„ë‹ˆë¼ ê·¸ëƒ¥ replace ê°’ë„ íì— ì €ì¥ë¨
<img src="/images/react_state_5.png" alt="" /></p>
  </li>
  <li>Setting state does not change the variable in the existing render, but it requests a new render.</li>
  <li>React processes state updates after event handlers have finished running. This is called batching.</li>
  <li>To update some state multiple times in one event, you can use setNumber(n =&gt; n + 1) updater function.</li>
</ul>

<h2 id="updating-objects-in-state">Updating objects in state</h2>

<ul>
  <li>Treat all state in React as immutable.</li>
  <li>When you store objects in state, mutating them will not trigger renders and will change the state in previous render â€œsnapshotsâ€.</li>
  <li>Instead of mutating an object, create a new version of it, and trigger a re-render by setting state to it.</li>
  <li>You can use the {â€¦obj, something: â€˜newValueâ€™} object spread syntax to create copies of objects.</li>
  <li>Spread syntax is shallow: it only copies one level deep.</li>
  <li>To update a nested object, you need to create copies all the way up from the place youâ€™re updating.</li>
  <li>To reduce repetitive copying code, use Immer.</li>
</ul>

<h1 id="ì°¸ê³ ">ì°¸ê³ </h1>

<ul>
  <li><a href="https://react.dev/learn/adding-interactivity">Adding Interactivity, react.dev</a></li>
  <li><a href="https://www.developerway.com/posts/react-re-renders-guide#part2">React re-renders guide: everything, all at once, Developer Way</a></li>
  <li><a href="https://www.geeksforgeeks.org/re-rendering-components-in-reactjs/">Re-rendering Components in ReactJS, Geeksforgeeks</a></li>
  <li><a href="https://blog.logrocket.com/how-when-to-force-react-component-re-render/">How and when to force a React component to re-render, LogRocket</a></li>
</ul>
:ET