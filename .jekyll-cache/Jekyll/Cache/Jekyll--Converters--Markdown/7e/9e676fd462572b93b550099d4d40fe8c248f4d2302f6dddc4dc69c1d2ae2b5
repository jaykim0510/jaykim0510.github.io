I"U&<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#pytest가-좋은-이유" id="markdown-toc-pytest가-좋은-이유">pytest가 좋은 이유</a>    <ul>
      <li><a href="#less-boilerplate" id="markdown-toc-less-boilerplate">Less Boilerplate</a></li>
      <li><a href="#nicer-output" id="markdown-toc-nicer-output">Nicer Output</a></li>
      <li><a href="#easier-to-manage-state-and-dependencies" id="markdown-toc-easier-to-manage-state-and-dependencies">Easier to Manage State and Dependencies</a></li>
      <li><a href="#easy-to-filter-tests" id="markdown-toc-easy-to-filter-tests">Easy to Filter Tests</a></li>
      <li><a href="#allows-test-parametrization" id="markdown-toc-allows-test-parametrization">Allows Test Parametrization</a></li>
      <li><a href="#has-a-plugin-based-architecture" id="markdown-toc-has-a-plugin-based-architecture">Has a Plugin-Based Architecture</a></li>
    </ul>
  </li>
  <li><a href="#fixtures-managing-state-and-dependencies" id="markdown-toc-fixtures-managing-state-and-dependencies">Fixtures: Managing State and Dependencies</a></li>
  <li><a href="#marks-categorizing-tests" id="markdown-toc-marks-categorizing-tests">Marks: Categorizing Tests</a></li>
  <li><a href="#parametrization-combining-tests" id="markdown-toc-parametrization-combining-tests">Parametrization: Combining Tests</a></li>
</ul>

<hr />

<p>Testing your code brings a wide variety of benefits. It increases your confidence that the code behaves as you expect and ensures that changes to your code won’t cause regressions. Writing and maintaining tests is hard work, so you should leverage all the tools at your disposal to make it as painless as possible. <code class="language-plaintext highlighter-rouge">pytest</code> is one of the best tools that you can use to boost your testing productivity.</p>

<p>If you’ve written unit tests for your Python code before, then you may have used Python’s built-in <code class="language-plaintext highlighter-rouge">unittest</code> module. <code class="language-plaintext highlighter-rouge">unittest</code> provides a solid base on which to build your test suite, but it has a few shortcomings.</p>

<p>A number of third-party testing frameworks attempt to address some of the issues with <code class="language-plaintext highlighter-rouge">unittest</code>, and <code class="language-plaintext highlighter-rouge">pytest</code> has proven to be one of the most popular. <code class="language-plaintext highlighter-rouge">pytest</code> is a feature-rich, plugin-based ecosystem for testing your Python code.</p>

<h1 id="pytest가-좋은-이유">pytest가 좋은 이유</h1>

<h2 id="less-boilerplate">Less Boilerplate</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">unittest</code>는 상속받고, unittest에서 제공하는 assert문을 사용해야함
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_with_unittest.py
</span>
<span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">TestCase</span>

<span class="k">class</span> <span class="nc">TryTesting</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_always_passes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_always_fails</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">pytest</code>는 보통 함수를 작성하듯 작성하고, 파이썬에서 제공하는 assert문 사용하면 됨
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_with_pytest.py
</span>
<span class="k">def</span> <span class="nf">test_always_passes</span><span class="p">():</span>
    <span class="k">assert</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">test_always_fails</span><span class="p">():</span>
    <span class="k">assert</span> <span class="bp">False</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Most functional tests follow the Arrange-Act-Assert model:</p>

<ul>
  <li><strong>Arrange</strong>, or set up, the conditions for the test</li>
  <li><strong>Act</strong> by calling some function or method</li>
  <li><strong>Assert</strong> that some end condition is true</li>
</ul>

<h2 id="nicer-output">Nicer Output</h2>

<ul>
  <li>먼저 시스템 상태, 파이썬 버전, 루트 디렉토리, 발견된 테스트의 수와 같은 정보를 제공</li>
  <li>테스트 결과의 아웃풋은 다음과 같음
    <ul>
      <li>A dot (.) means that the test passed.</li>
      <li>An F means that the test has failed.</li>
      <li>An E means that the test raised an unexpected exception.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test_with_pytest.py .F                                                   [ 50%]
test_with_unittest.py F.                                                 [100%]
</code></pre></div></div>

<p>위의 결과를 해석해보면, test_with_pytest.py 파일 안에는 두 개의 테스트 코드가 있고, 하나는 성공, 하나는 실패했음을 나타낸다. test_with_unittest.py 파일 안에서는 하나는 실패, 하나는 성공했을음 나타낸다. pytest로 실행하면 위와같이 unittest로 작성한 테스트 코드도 인식할 수 있다.</p>

<h2 id="easier-to-manage-state-and-dependencies">Easier to Manage State and Dependencies</h2>

<ul>
  <li>테스트에 사용되는 데이터 타입이 dict, json과 같이 다르다</li>
  <li>pytest takes a different approach. It leads you toward explicit dependency declarations that are still reusable thanks to the availability of fixtures. pytest fixtures are functions that can create data, test doubles, or initialize system state for the test suite. Any test that wants to use a fixture must explicitly use this fixture function as an argument to the test function, so dependencies are always stated up front:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># fixture_demo.py
</span>
<span class="kn">import</span> <span class="nn">pytest</span>

<span class="o">@</span><span class="n">pytest</span><span class="p">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">example_fixture</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">test_with_fixture</span><span class="p">(</span><span class="n">example_fixture</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">example_fixture</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Looking at the test function, you can immediately tell that it depends on a fixture, without needing to check the whole file for fixture definitions.</p>

<h2 id="easy-to-filter-tests">Easy to Filter Tests</h2>

<ul>
  <li>프로젝트 규모가 커지고, 테스트 코드 규모도 함께 커지면 나중에는 원하는 몇 개의 테스트만 필터링하고 싶을 때가 있음</li>
  <li>pytest 에서는 테스트를 필터링 하는 몇가지 방법을 제공
    <ul>
      <li><strong>Name-based filtering</strong>: You can limit pytest to running only those tests whose fully qualified names match a particular expression. You can do this with the -k parameter.</li>
      <li><strong>Directory scoping</strong>: By default, pytest will run only those tests that are in or under the current directory.</li>
      <li><strong>Test categorization</strong>: pytest can include or exclude tests from particular categories that you define. You can do this with the -m parameter.</li>
    </ul>
  </li>
</ul>

<p>Test categorization in particular is a subtly powerful tool. pytest enables you to create marks, or custom labels, for any test you like. A test may have multiple labels, and you can use them for granular control over which tests to run. Later in this tutorial, you’ll see an example of how pytest marks work and learn how to make use of them in a large test suite.</p>

<h2 id="allows-test-parametrization">Allows Test Parametrization</h2>

<ul>
  <li>어떤 하나의 테스트 코드에 대해서 다양한 인풋을 넣어서 실험하는 경우가 있음</li>
  <li>unittest는 이 때의 결과를 하나로 출력 -&gt; 인풋중 하나라도 실패하면 그냥 그 테스트 전체가 실패한 것으로 간주</li>
  <li>pytest는 각각의 인풋에 대해서 어떤 인풋이 실패하는지를 알려줌</li>
</ul>

<h2 id="has-a-plugin-based-architecture">Has a Plugin-Based Architecture</h2>

<ul>
  <li>pytest는 모듈화되어 확장성이 뛰어나도록 설계됨</li>
  <li>많은 개발자들이 커스터마이징해서 사용중</li>
</ul>

<h1 id="fixtures-managing-state-and-dependencies">Fixtures: Managing State and Dependencies</h1>

<h1 id="marks-categorizing-tests">Marks: Categorizing Tests</h1>

<h1 id="parametrization-combining-tests">Parametrization: Combining Tests</h1>
:ET