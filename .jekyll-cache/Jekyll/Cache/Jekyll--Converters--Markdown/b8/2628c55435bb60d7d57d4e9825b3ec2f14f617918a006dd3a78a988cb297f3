I"ÈB<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#ë¶„ì‚°-ì‹œìŠ¤í…œ" id="markdown-toc-ë¶„ì‚°-ì‹œìŠ¤í…œ">ë¶„ì‚° ì‹œìŠ¤í…œ</a>    <ul>
      <li><a href="#ê°œìš”" id="markdown-toc-ê°œìš”">ê°œìš”</a></li>
      <li><a href="#íŠ¹ì§•" id="markdown-toc-íŠ¹ì§•">íŠ¹ì§•</a></li>
      <li><a href="#ì¥ì " id="markdown-toc-ì¥ì ">ì¥ì </a></li>
      <li><a href="#ë‹¨ì " id="markdown-toc-ë‹¨ì ">ë‹¨ì </a></li>
      <li><a href="#ì•„í‚¤í…ì²˜" id="markdown-toc-ì•„í‚¤í…ì²˜">ì•„í‚¤í…ì²˜</a></li>
      <li><a href="#ì–´ë ¤ìš´-ì " id="markdown-toc-ì–´ë ¤ìš´-ì ">ì–´ë ¤ìš´ ì </a>        <ul>
          <li><a href="#synchronization" id="markdown-toc-synchronization">Synchronization</a></li>
          <li><a href="#network-partition" id="markdown-toc-network-partition">Network Partition</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#ë¶„ì‚°-íŒŒì¼-ì‹œìŠ¤í…œ" id="markdown-toc-ë¶„ì‚°-íŒŒì¼-ì‹œìŠ¤í…œ">ë¶„ì‚° íŒŒì¼ ì‹œìŠ¤í…œ</a></li>
  <li><a href="#ë¶„ì‚°-ë°ì´í„°ë² ì´ìŠ¤" id="markdown-toc-ë¶„ì‚°-ë°ì´í„°ë² ì´ìŠ¤">ë¶„ì‚° ë°ì´í„°ë² ì´ìŠ¤</a></li>
  <li><a href="#ë¶„ì‚°-ì²˜ë¦¬" id="markdown-toc-ë¶„ì‚°-ì²˜ë¦¬">ë¶„ì‚° ì²˜ë¦¬</a></li>
  <li><a href="#ë¶„ì‚°-ì‹œìŠ¤í…œê³¼-ì¿ ë²„ë„¤í‹°ìŠ¤" id="markdown-toc-ë¶„ì‚°-ì‹œìŠ¤í…œê³¼-ì¿ ë²„ë„¤í‹°ìŠ¤">ë¶„ì‚° ì‹œìŠ¤í…œê³¼ ì¿ ë²„ë„¤í‹°ìŠ¤</a></li>
  <li><a href="#ì°¸ê³ " id="markdown-toc-ì°¸ê³ ">ì°¸ê³ </a></li>
</ul>

<hr />

<h1 id="ë¶„ì‚°-ì‹œìŠ¤í…œ">ë¶„ì‚° ì‹œìŠ¤í…œ</h1>

<h2 id="ê°œìš”">ê°œìš”</h2>

<p>Distributed System is a collection of autonomous computer systems that are physically separated but are connected by a centralized computer network that is equipped with distributed system software. The autonomous computers will communicate among each system by sharing resources and files and performing the tasks assigned to them.</p>

<p><img src="/images/dist_1.png" alt="" /></p>

<h2 id="íŠ¹ì§•">íŠ¹ì§•</h2>

<ul>
  <li><strong>Resource Sharing</strong>: It is the ability to use any Hardware, Software, or Data anywhere in the System.</li>
  <li><strong>Openness</strong>: It is concerned with Extensions and improvements in the system (i.e., How openly the software is developed and shared with                                others)</li>
  <li><strong>Concurrency</strong>: It is naturally present in the Distributed Systems, that deal with the same activity or functionality that can be performed by separate users who are in remote locations. Every local system has its independent Operating Systems and Resources.</li>
  <li><strong>Scalability</strong>: It increases the scale of the system as a number of processors communicate with more users by accommodating to improve the responsiveness of the system.</li>
  <li><strong>Fault tolerance</strong>: It cares about the reliability of the system if there is a failure in Hardware or Software, the system continues to operate properly without degrading the performance the system.</li>
  <li><strong>Transparency</strong>: It hides the complexity of the Distributed Systems to the Users and Application programs as there should be privacy in every system.(ìœ ì €ëŠ” ìì‹ ì´ ì‚¬ìš©í•˜ëŠ” ì–´í”Œë¦¬ì¼€ì´ì…˜ì´ ë¶„ì‚°ì‹œìŠ¤í…œì¸ì§€ ì¸ì§€í•˜ì§€ ëª»í•¨ -&gt; ë‹¨ì¼ ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì²˜ëŸ¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ)</li>
</ul>

<h2 id="ì¥ì ">ì¥ì </h2>

<ul>
  <li>Applications in Distributed Systems are Inherently Distributed Applications.</li>
  <li>Information in Distributed Systems is shared among geographically distributed users.</li>
  <li>Resource Sharing (Autonomous systems can share resources from remote locations).</li>
  <li>It has a better price performance ratio and flexibility.</li>
  <li>It has shorter response time and higher throughput.</li>
  <li>It has higher reliability and availability against component failure.</li>
  <li>It has extensibility so that systems can be extended in more remote locations and also incremental growth.</li>
</ul>

<h2 id="ë‹¨ì ">ë‹¨ì </h2>

<ul>
  <li>Relevant Software for Distributed systems does not exist currently.</li>
  <li>Security possess a problem due to easy access to data as the resources are shared to multiple systems.</li>
  <li>Networking Saturation may cause a hurdle in data transfer i.e., if there is a lag in the network then the user will face a problem accessing data.</li>
</ul>

<h2 id="ì•„í‚¤í…ì²˜">ì•„í‚¤í…ì²˜</h2>

<ul>
  <li>Centralized Architecture</li>
  <li>Decentralized Architecture</li>
</ul>

<h2 id="ì–´ë ¤ìš´-ì ">ì–´ë ¤ìš´ ì </h2>

<h3 id="synchronization">Synchronization</h3>

<p>Distributed System is a collection of computers connected via the high speed communication network. In the distributed system, the hardware and software components communicate and coordinate their actions by message passing. Each node in distributed systems can share their resources with other nodes. So, there is need of proper allocation of resources to preserve the state of resources and help coordinate between the several processes. To resolve such conflicts, synchronization is used. Synchronization in distributed systems is achieved via clocks.</p>

<p>The physical clocks are used to adjust the time of nodes.Each node in the system can share its local time with other nodes in the system. The time is set based on UTC (Universal Time Coordination). UTC is used as a reference time clock for the nodes in the system.</p>

<p>The clock synchronization can be achieved by 2 ways: External and Internal Clock Synchronization.</p>

<ul>
  <li>External clock synchronization is the one in which an external reference clock is present. It is used as a reference and the nodes in the system can set and adjust their time accordingly.</li>
  <li>Internal clock synchronization is the one in which each node shares its time with other nodes and all the nodes set and adjust their times accordingly.</li>
</ul>

<p>There are 2 types of clock synchronization algorithms: Centralized and Distributed.</p>

<ul>
  <li>Centralized is the one in which a time server is used as a reference. The single time server propagates its time to the nodes and all the nodes adjust the time accordingly. It is dependent on single time server so if that node fails, the whole system will lose synchronization. Examples of centralized are- Berkeley Algorithm, Passive Time Server, Active Time Server etc.</li>
  <li>Distributed is the one in which there is no centralized time server present. Instead the nodes adjust their time by using their local time and then, taking the average of the differences of time with other nodes. Distributed algorithms overcome the issue of centralized algorithms like the scalability and single point failure. Examples of Distributed algorithms are â€“ Global Averaging Algorithm, Localized Averaging Algorithm, NTP (Network time protocol) etc.</li>
</ul>

<h3 id="network-partition">Network Partition</h3>

<ul>
  <li>ë¶„ì‚° ì‹œìŠ¤í…œì„ ì´ìš©í•œ ì¸í„°ë„· ì„œë¹„ìŠ¤ì—ì„œ ì‚¬ìš©í•˜ëŠ” ì–´í”Œë¦¬ì¼€ì´ì…˜ì˜ ì•„í‚¤í…ì²˜ëŠ” ëŒ€ë¶€ë¶„ ë¹„ê³µìœ  ì•„í‚¤í…ì²˜(Shared-nothing)
    <ul>
      <li>ê° ë…¸ë“œëŠ” CPU, RAM, ë””ìŠ¤í¬ë¥¼ ë…ë¦½ì ìœ¼ë¡œ ì‚¬ìš©(ë””ìŠ¤í¬ë„ ë…ë¦½ëœë‹¤ëŠ” ì ì—ì„œ Shared Disk Architectureì™€ ë‹¤ë¦„)</li>
    </ul>
  </li>
  <li>ë¹„ê³µìœ  ì‹œìŠ¤í…œì—ì„œ ì¥ë¹„ë“¤ì´ í†µì‹ í•˜ëŠ” ìœ ì¼í•œ ìˆ˜ë‹¨ì€ ë„¤íŠ¸ì›Œí¬</li>
  <li>ì „ì†¡ ì¸¡ì€ íŒ¨í‚·ì´ ì „ì†¡ ëœê±´ì§€, ë„¤íŠ¸ì›Œí¬ ë¬¸ì œì¸ì§€, ìˆ˜ì‹  ì¸¡ ì„œë²„ ë¬¸ì œì¸ì§€ ì•Œ ìˆ˜ ì—†ìœ¼ë©° ì‹¬ì§€ì–´ ì „ë‹¬ì´ ì‹¤íŒ¨í•œê±´ì§€ ì•„ë‹ˆë©´ ì§€ì—°ëœê±´ì§€ ì¡°ì°¨ ì•Œ ìˆ˜ ì—†ìŒ</li>
</ul>

<p><img src="/images/dist_3.png" alt="" /></p>

<h1 id="ë¶„ì‚°-íŒŒì¼-ì‹œìŠ¤í…œ">ë¶„ì‚° íŒŒì¼ ì‹œìŠ¤í…œ</h1>

<p>A Distributed File System (DFS) as the name suggests, is a file system that is distributed on multiple file servers or multiple locations. It allows programs to access or store isolated files as they do with the local ones, allowing programmers to access files from any network or computer.</p>

<p>The main purpose of the Distributed File System (DFS) is to allows users of physically distributed systems to share their data and resources by using a Common File System. A collection of workstations and mainframes connected by a Local Area Network (LAN) is a configuration on Distributed File System. A DFS is executed as a part of the operating system. In DFS, a namespace is created and this process is transparent for the clients.</p>

<p><strong>Working of DFS</strong><br />
There are two ways in which DFS can be implemented:</p>

<ul>
  <li>Standalone DFS namespace
    <ul>
      <li>It allows only for those DFS roots that exist on the local computer and are not using Active Directory. A Standalone DFS can only be acquired on those computers on which it is created. It does not provide any fault liberation and cannot be linked to any other DFS. Standalone DFS roots are rarely come across because of their limited advantage.</li>
    </ul>
  </li>
  <li>Domain-based DFS namespace
    <ul>
      <li>It stores the configuration of DFS in Active Directory, creating the DFS namespace root accessible at \<domainname>\<dfsroot> or \\<FQDN>\<dfsroot></dfsroot></FQDN></dfsroot></domainname></li>
    </ul>
  </li>
</ul>

<p><img src="/images/dist_2.png" alt="" /></p>

<p><strong>Advantages</strong></p>
<ul>
  <li>DFS allows multiple user to access or store the data.</li>
  <li>It allows the data to be share remotely.</li>
  <li>It improved the availability of file, access time, and network efficiency.</li>
  <li>Improved the capacity to change the size of the data and also improves the ability to exchange the data.</li>
  <li>Distributed File System provides transparency of data even if server or disk fails.
<strong>Disadvantages</strong></li>
  <li>In Distributed File System nodes and connections needs to be secured therefore we can say that security is at stake.</li>
  <li>There is a possibility of lose of messages and data in the network while movement from one node to another.</li>
  <li>Database connection in case of Distributed File System is complicated.</li>
  <li>Also handling of the database is not easy in Distributed File System as compared to a single user system.</li>
  <li>There are chances that overloading will take place if all nodes tries to send data at once.</li>
</ul>

<h1 id="ë¶„ì‚°-ë°ì´í„°ë² ì´ìŠ¤">ë¶„ì‚° ë°ì´í„°ë² ì´ìŠ¤</h1>

<h1 id="ë¶„ì‚°-ì²˜ë¦¬">ë¶„ì‚° ì²˜ë¦¬</h1>

<h1 id="ë¶„ì‚°-ì‹œìŠ¤í…œê³¼-ì¿ ë²„ë„¤í‹°ìŠ¤">ë¶„ì‚° ì‹œìŠ¤í…œê³¼ ì¿ ë²„ë„¤í‹°ìŠ¤</h1>

<p>ì¿ ë²„ë„¤í‹°ìŠ¤ëŠ” â€˜Aë¼ëŠ” ì»¨í…Œì´ë„ˆí™”ëœ í”„ë¡œì„¸ìŠ¤ë¥¼ ì–´ëŠ ì„œë²„ì— ë„ìš¸ê¹Œ? í”„ë¡œì„¸ìŠ¤ë¥¼ ëª‡ ëŒ€ì˜ ì„œë²„ì— ë³µì œí•´ë‘ê³  ì¼ë¶€ ì„œë²„ê°€ ì¥ì• ê°€ ìƒê¸°ë©´ ë‹¤ë¥¸ ì„œë²„ì— ìˆëŠ” í”„ë¡œì„¸ìŠ¤ë¡œ ëŒ€ì²´â€™</p>

<p>ë¶„ì‚° ì‹œìŠ¤í…œì€ â€˜Aë¼ëŠ” ì–´í”Œë¦¬ì¼€ì´ì…˜ì„ ì—¬ëŸ¬ ì„œë²„ì—ì„œ ë™ì‘í•˜ë„ë¡ í•˜ì—¬ ë™ì‹œì²˜ë¦¬(ë³‘ë ¬ì ìœ¼ë¡œ)í•˜ë„ë¡ í•˜ê³ , ì¼ë¶€ ì„œë²„ì— ì¥ì• ê°€ ë°œìƒí•˜ë©´ í•´ë‹¹ ì„œë²„ì— ìˆëŠ” ì–´í”Œë¦¬ì¼€ì´ì…˜ì„ í´ëŸ¬ìŠ¤í„°ì—ì„œ ì œì™¸, ë³µêµ¬ ë˜ì—ˆëŠ”ì§€ ì£¼ê¸°ì ìœ¼ë¡œ í—¬ìŠ¤ì²´í¬í•´ì„œ ë³µêµ¬ ë˜ë©´ ë‹¤ì‹œ í´ëŸ¬ìŠ¤í„°ì— ì¶”ê°€â€™</p>

<p>ë¶„ì‚° ì‹œìŠ¤í…œ<br />
According to Coulouris et al., â€œA distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another.â€</p>

<p>ë¶„ì‚° ì‹œìŠ¤í…œì˜ ì¥ì <br />
Performance: ê°€ê²© ëŒ€ë¹„ ë†’ì€ ì„±ëŠ¥</p>

<p>Scalability: ë…¸ë“œ ê°œìˆ˜ë¥¼ ì¡°ì ˆí•¨ìœ¼ë¡œì¨ íŠ¸ë˜í”½ëŸ‰ì— ëŒ€í•´ ìœ ì—°í•˜ê²Œ ëŒ€ì²˜ ê°€ëŠ¥</p>

<p>Availability: ability of the system to remain functional despite failures in parts of it.</p>

<p>ì–´ë ¤ìš´ ì </p>

<p>Network asynchrony: ë°ì´í„°ê°€ ë„¤íŠ¸ì›Œí¬ ë¬¸ì œë¡œ ì „ë‹¬ì´ ëŠ¦ì–´ì§ˆ ìˆ˜ë„, ì•„ì˜ˆ ì‹¤íŒ¨í•  ìˆ˜ë„ ìˆìŒ</p>

<p>Partial failures: í´ëŸ¬ìŠ¤í„° ì¤‘ ì¼ë¶€ ë…¸ë“œê°€ ì¥ì• ë¡œ ë‹¤ìš´ë  ìˆ˜ ìˆìŒ</p>

<p>Concurrency: Two processes writing to the same resource concurrently</p>

<p>The asynchronous nature of the network in a distributed system can make it very hard for us to differentiate between a crashed node and a node that is just really slow to respond to requests.</p>

<p>Timeouts is the main mechanism we can use to detect failures in distributed systems. Since an asynchronous network can infinitely delay messages, timeouts impose an artificial upper bound on these delays. As a result, we can assume that a node fails when it is slower than this bound.</p>

<p>However, a timeout does not represent an actual limit. Thus, it creates the following trade-off.</p>

<p>ë‚´ê°€ ì •í•œ íƒ€ì„ì•„ì›ƒ ì„¤ì •ì´ ë°œìƒí•œ ë¬¸ì œì˜ ê·¼ë³¸ì ì¸ ì›ì¸ì„ í•´ê²°í•˜ëŠ” ì ì€ ì•„ë‹ˆë‹¤. ë°œìƒí•œ ë¬¸ì œë¡œ ìƒê²Œë˜ëŠ” ì„±ëŠ¥ì´ ì‹¤ì œ ì´ìƒìœ¼ë¡œ ë–¨ì–´ì§ˆ ìˆ˜ ë°–ì— ì—†ë‹¤. íƒ€ì„ì•„ì›ƒ ê°’ì— ë”°ë¼ Completenessì™€ Accruacy ì‚¬ì´ì— íŠ¸ë ˆì´ë“œ ì˜¤í”„ ë°œìƒ</p>

<p>Completeness corresponds to the percentage of crashed nodes a failure detector successfully identifies in a certain period.</p>

<p>Accuracy corresponds to the number of mistakes a failure detector makes in a certain period.</p>

<p>Scalability lets us store and process datasets much larger than what we could with a single machine.</p>

<p>One of the primary mechanisms of achieving scalability is partitioning.</p>

<p>Distributed Systemì—ì„œ ë§í•˜ëŠ” partitioningì€ horizontal partitioning</p>

<p>horizontal partitionì—ëŠ” í¬ê²Œ range partitioning, hash partitioning, consistent hashing</p>

<p>Partitioning can improve the scalability and performance of a system by distributing data and request load to multiple nodes.</p>

<p>Another dimension that benefits from using a distributed system is known as availability.</p>

<p>Distributed system uses replication to achieve availability.</p>

<p>Replication is the main technique used in distributed systems to increase availability. It consists of storing the same piece of data in multiple nodes (called replicas) so that if one of them crashes, data is not lost, and requests can be served from the other nodes in the meanwhile.</p>

<p>However, the benefit of increased availability from replication comes with a set of new complications.</p>

<p>Replication implies that the system now has multiple copies of every piece of data. These copies must be maintained and <strong>kept in sync with each other on every update</strong>.</p>

<p>Ideally, replication should function transparently to the end-user, or engineer. This is to create the illusion that thereâ€™s only one copy of every piece of data. This makes a distributed system look like a simple, centralized system of a single node that is much easier to reason about and develop software around.</p>

<p>Of course, this is not always possible. We may require significant hardware resources or need to give up other desirable properties to achieve this ideal. For instance, engineers sometimes willingly accept a system that provides much higher performance, but occasionally gives a non-consistent view of the data. Hence, they only do this under specific conditionsâ€”and in a specific wayâ€”they can account for when they design the application.</p>

<p>Therefore, there are two main strategies for replication:</p>

<p>Pessimistic replication<br />
Optimistic replication<br />
Pessimistic replication<br />
Pessimistic replication tries to guarantee from the beginning that all the replicas are identical to each otherâ€”as if there was only one copy of the data all along.</p>

<p>Optimistic replication<br />
Optimistic replication, or lazy replication, allows the different replicas to diverge. This guarantees that they will converge again if the system does not receive any updates, or enters a quiesced state, for a period of time.</p>

<h1 id="ì°¸ê³ ">ì°¸ê³ </h1>

<ul>
  <li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791161754963&amp;orderClick=LEa&amp;Kc=" target="_blank">ì±…, Database Internals</a></li>
  <li><a href="https://www.slideshare.net/rubentan/basic-distributed-systems-principles" target="_blank">slideshare: Basic distributed systems principles</a></li>
  <li><a href="https://vowi.fsinf.at/images/b/bc/TU_Wien-Verteilte_Systeme_VO_%28G%C3%B6schka%29_-_Tannenbaum-distributed_systems_principles_and_paradigms_2nd_edition.pdf" target="_blank">pdf: Distributed Systems: Principles and Paradigms</a></li>
  <li><a href="https://www.geeksforgeeks.org/what-is-a-distributed-system/?ref=gcse" target="_blank">GeeksforGeeks: What is a Distributed System?</a></li>
  <li><a href="https://www.geeksforgeeks.org/comparison-centralized-decentralized-and-distributed-systems/?ref=gcse" target="_blank">GeeksforGeeks: Comparison â€“ Centralized, Decentralized and Distributed Systems</a></li>
  <li><a href="https://www.geeksforgeeks.org/synchronization-in-distributed-systems/?ref=gcse" target="_blank">GeeksforGeeks: Synchronization in Distributed Systems</a></li>
  <li><a href="https://www.geeksforgeeks.org/what-is-dfsdistributed-file-system/?ref=gcse" target="_blank">GeeksforGeeks: What is DFS (Distributed File System)?</a></li>
</ul>
:ET