I"‘><hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#log" id="markdown-toc-log">Log</a>    <ul>
      <li><a href="#use" id="markdown-toc-use">Use</a></li>
    </ul>
  </li>
  <li><a href="#log-in-distributed-system" id="markdown-toc-log-in-distributed-system">Log in Distributed System</a></li>
  <li><a href="#kafka-log" id="markdown-toc-kafka-log">Kafka Log</a>    <ul>
      <li><a href="#commit-log" id="markdown-toc-commit-log">Commit Log</a></li>
    </ul>
  </li>
  <li><a href="#rdbms-log" id="markdown-toc-rdbms-log">RDBMS Log</a>    <ul>
      <li><a href="#postgresql" id="markdown-toc-postgresql">PostgreSQL</a></li>
      <li><a href="#mysql--mariadb" id="markdown-toc-mysql--mariadb">MySQL / MariaDB</a></li>
      <li><a href="#write-ahead-log" id="markdown-toc-write-ahead-log">Write Ahead Log</a></li>
      <li><a href="#transaction-logredo-log--undo-log" id="markdown-toc-transaction-logredo-log--undo-log">Transaction Log(Redo log + Undo log)</a></li>
      <li><a href="#binary-log" id="markdown-toc-binary-log">Binary Log</a></li>
    </ul>
  </li>
  <li><a href="#ì°¸ê³ " id="markdown-toc-ì°¸ê³ ">ì°¸ê³ </a></li>
</ul>

<hr />

<h1 id="log">Log</h1>

<ul>
  <li>
    <p>A log, in a computing context, is the automatically produced and time-stamped documentation of events relevant to a particular system. Virtually all software applications and systems produce log files.</p>
  </li>
  <li>
    <p>Logs are everywhere in software development. Without them thereâ€™d be no relational databases, git version control, or most analytics platforms.</p>
  </li>
  <li>
    <p>A log can be useful for keeping track of computer use, emergency recovery, and application improvement.</p>
  </li>
</ul>

<p><strong>A few common types of logs</strong>:</p>
<ul>
  <li><strong>Transaction Log (Redo Log, Undo Log)</strong>: contains a history of database changes. The term is usually associated with RDBMS. When you insert, update or delete database rows, the changes are journaled in the Transaction Log. Real-world RDBMS systems are based on one of the following types of the journal.</li>
  <li><strong>Commit Log</strong>: includes only committed transactions in their commit order. Every committed transaction is appended to the log sequentially as a group of change events. Rolled-back transactions will not appear in the Commit Log.</li>
  <li><strong>Binary Log</strong>: binary log ì—ëŠ” ë°ì´í„°ë² ì´ìŠ¤ì— ëŒ€í•œ ëª¨ë“  ë³€ê²½ ì‚¬í•­(ë°ì´í„° ë° êµ¬ì¡°)ê³¼ ê° ëª…ë ¹ë¬¸ ì‹¤í–‰ ì‹œê°„ì´ ê¸°ë¡ë˜ì–´ ìˆë‹¤. binary log ì˜ ëª©ì ì€ ë°±ì—… ì‘ì—…ì„ ì§€ì›í• ë¿ë§Œ ì•„ë‹ˆë¼, í•˜ë‚˜ ì´ìƒì˜ ë§ˆìŠ¤í„°ì—ì„œ í•˜ë‚˜ ì´ìƒì˜ ìŠ¬ë ˆì´ë¸Œ ì„œë²„ë¡œ ë°ì´í„°ê°€ ì „ì†¡ë˜ì–´ ë³µì œí•˜ë„ë¡ í•˜ê¸° ìœ„í•œ ê²ƒì´ë‹¤.</li>
  <li><strong>Write-Ahead Log (WAL)</strong>: The changes are first journaled in the log, then the database is changed. The log is updated simultaneously as parallel transactions make changes. If a transaction is rolled-back, a special record is written to the log.</li>
  <li><strong>Access Log</strong>: lists all requests for individual files that people have requested from a website</li>
  <li><strong>Audit Log</strong>: Audit logg is the record of activity within the software systems used across your organization. Audit logs record the occurrence of an event, the time at which it occurred, the responsible user or service, and the impacted entity</li>
  <li><strong>System Log</strong>: syslog are records of the operating system (OS) events that indicate how the system was running. Information, errors, and warnings related to the computer operating system are displayed in the syslog.</li>
</ul>

<p>Transaction Log, Redo Log, Commit Log, Binary Logë“¤ì€ ì¢€ í˜¼ìš©ë˜ì„œ ì‚¬ìš©í•˜ëŠ” ê²ƒ ê°™ë‹¤. DBë§ˆë‹¤ ê°™ì€ ìš©ì–´ì¸ë° ë‹¤ë¥´ê²Œ ì‚¬ìš©ë˜ê¸°ë„ í•˜ê³ , ë˜ ì‚¬ëŒë“¤ë„ ê²°ê³¼ì ìœ¼ë¡œ í˜¼ìš©í•´ì„œ ì‚¬ìš©í•˜ê³  ì„¤ëª…í•´ì„œ, ëª…í™•íˆ ê¸€ë¡œ ì ì–´ë‚´ê¸°ê°€ í˜ë“¤ë‹¤. ê·¸ë˜ì„œ ê·¸ëƒ¥ ìì‹ ì´ ì‚¬ìš©í•˜ëŠ” DBì— ë§ê²Œ ì •ë¦¬í•´ì•¼ í•  ê²ƒ ê°™ë‹¤. ì°¸ê³ ë¡œ MySQLì€ Redo Log, Undo Log ê·¸ë¦¬ê³  Binary Log ì´ 3ê°€ì§€ë¡œ ë¡¤ë°±(Rollback), ì»¤ë°‹(Commit), ë³µêµ¬(Recovery), ë³µì œ(Replication) ê¸°ëŠ¥ì„ êµ¬í˜„í•œë‹¤.</p>

<h2 id="use">Use</h2>
<ul>
  <li>
    <p><strong>ACID</strong>: Transaction Log is used to guarantee ACID properties during crash recovery. RDBMS uses the log after a crash to roll-back transactions that were not committed. After crash recovery, the database returns to a consistent state.</p>
  </li>
  <li>
    <p><strong>Replication</strong>: Database replication is based on streaming Transaction Log events from the master server to its replicas. The events are applied on the replica servers and their state becomes consistent with the master.</p>
  </li>
</ul>

<h1 id="log-in-distributed-system">Log in Distributed System</h1>

<p>The log is a totally-ordered, append-only data structure. Whether itâ€™s application logs, system logs, or access logs, logging is something every developer uses on a daily basis. Essentially, itâ€™s a timestamp and an event, a when and a what, and typically appended to the end of a file. But when we generalize that pattern, we end up with something much more useful for a broad range of problems. It becomes more interesting when we look at the log not just as a system of record but a <strong>central piece in managing data and distributing it across the enterprise efficiently</strong>.</p>

<p>There are a number of implementations of this idea: Apache Kafka, Amazon Kinesis, NATS Streaming, Tank, and Apache Pulsar to name a few. We can probably credit Kafka with popularizing the idea.</p>

<p>There arethree key priorities of these types of systems: <strong>performance, high availability, and scalability</strong>. If itâ€™s not fast enough, the data becomes decreasingly useful. If itâ€™s not highly available, it means we canâ€™t reliably get our data in or out. And if itâ€™s not scalable, it wonâ€™t be able to meet the needs of many enterprises.</p>

<h1 id="kafka-log">Kafka Log</h1>

<h2 id="commit-log">Commit Log</h2>

<p>Usually, Commit Log is associated with relational database systems. In fact, you can think about Commit Log as a part of your architecture where every transaction is written to some reliable log. The transactions are then read from the log and processed by consumers. This architecture can be implemented using the Event Streaming pattern. Kafka is designed for event streaming and acts very similar to a Commit Log. Kafka has a concept of partitions to parallelize the processing of events.</p>

<h1 id="rdbms-log">RDBMS Log</h1>

<h2 id="postgresql">PostgreSQL</h2>
<p>PostgreSQL is based on the Write-Ahead Log. The log represents a binary stream of low-level physical instructions. PostgreSQL provides Logical Decoding to extract the changes in an eye-friendly format.</p>

<h2 id="mysql--mariadb">MySQL / MariaDB</h2>
<p>MySQL has a concept of storage engines that represent different strategies for storing your database. There are many storage engines and you can write your own but the most interesting are InnoDB (B-tree index), MyRocks (LSM index), and MyISAM. This architecture is flexible but requires a separate WAL log used by a storage engine.</p>

<p>Binary Log (also known as binlog) is the Commit Log used for replication and decoupled from storage engines. It has a simple defined format that can be easily parsed. Additionally, every storage engine maintains its own WAL log. The format of the log is specific to the storage engine.</p>

<p>In MySQL, every transaction is written to the Commit Log and a WAL. Transactions are considered distributed as they require a two-phase commit (2PC) in the two log files.</p>

<p>As mentioned above, rolled-back transactions will not appear in the Commit Log. In MySQL, this is true only for transactional storage engines like InnoDB and MyRocks. In non-transactional storage engines like MyISAM rolled-back transactions may appear in the log and make your data inconsistent.</p>

<h2 id="write-ahead-log">Write Ahead Log</h2>

<p>Write-Ahead Logging (WAL) is a standard method for ensuring data integrity. A detailed description can be found in most (if not all) books about transaction processing. Briefly, WALâ€™s central concept is that changes to data files (where tables and indexes reside) must be written only after those changes have been logged, that is, after log records describing the changes have been flushed to permanent storage. If we follow this procedure, we do not need to flush data pages to disk on every transaction commit, because we know that in the event of a crash we will be able to recover the database using the log: any changes that have not been applied to the data pages can be redone from the log records. (This is roll-forward recovery, also known as REDO.)</p>

<p><strong>Tip</strong><br />
Because WAL restores database file contents after a crash, journaled file systems are not necessary for reliable storage of the data files or WAL files. In fact, journaling overhead can reduce performance, especially if journaling causes file system data to be flushed to disk. Fortunately, data flushing during journaling can often be disabled with a file system mount option, e.g., data=writeback on a Linux ext3 file system. Journaled file systems do improve boot speed after a crash.</p>

<p>Using WAL results in a significantly reduced number of disk writes, because only the log file needs to be flushed to disk to guarantee that a transaction is committed, rather than every data file changed by the transaction. The log file is written sequentially, and so the cost of syncing the log is much less than the cost of flushing the data pages. This is especially true for servers handling many small transactions touching different parts of the data store. Furthermore, when the server is processing many small concurrent transactions, one fsync of the log file may suffice to commit many transactions.</p>

<p>WAL also makes it possible to support on-line backup and point-in-time recovery, as described in Section 26.3. By archiving the WAL data we can support reverting to any time instant covered by the available WAL data: we simply install a prior physical backup of the database, and replay the WAL log just as far as the desired time. Whatâ€™s more, the physical backup doesnâ€™t have to be an instantaneous snapshot of the database state â€” if it is made over some period of time, then replaying the WAL log for that period will fix any internal inconsistencies.</p>

<h2 id="transaction-logredo-log--undo-log">Transaction Log(Redo log + Undo log)</h2>

<ul>
  <li>transaction log in Oracle are knwon as the redo log.</li>
  <li>The redo log is a disk-based data structure used during crash recovery to correct data written by incomplete transactions (MySQL ê³µì‹ë¬¸ì„œ)</li>
  <li>The transaction log serves the same functions as the REDO log in other databases- storing writes in a safe way and recovering in the case of a crash, although there are some details in implementation that differ in functionality from other RDMS</li>
  <li>There are redo logs (ib_logfile0 and ib_logfile1)</li>
  <li>The transaction log (usually in files iblog1 and iblog2) is vital to InnoDB for multiple reasons: ROLLBACK, crash recovery, and possibly more.</li>
</ul>

<h2 id="binary-log">Binary Log</h2>
<p>The binary log contains â€œeventsâ€ that describe database changes such as table creation operations or changes to table data. It also contains events for statements that potentially could have made changes (for example, a DELETE which matched no rows), unless row-based logging is used. The binary log also contains information about how long each statement took that updated data.</p>

<p>The binary log has two important purposes:</p>

<ul>
  <li>
    <p>For replication, the binary log on a replication source server provides a record of the data changes to be sent to replicas. The source sends the events contained in its binary log to its replicas, which execute those events to make the same data changes that were made on the source. See Section 16.2, â€œReplication Implementationâ€.</p>
  </li>
  <li>
    <p>Certain data recovery operations require use of the binary log. After a backup has been restored, the events in the binary log that were recorded after the backup was made are re-executed. These events bring databases up to date from the point of the backup. See Section 7.5, â€œPoint-in-Time (Incremental) Recoveryâ€.</p>
  </li>
</ul>

<p>The binary log is generally resilient to unexpected halts because only complete transactions are logged or read back. The binary log is not used for statements such as SELECT or SHOW that do not modify data. To log all statements (for example, to identify a problem query), use the general query log.</p>

<h1 id="ì°¸ê³ ">ì°¸ê³ </h1>

<ul>
  <li><a href="https://bourbonkk.tistory.com/86" target="_blank">í•´ì»¤ì˜ ê°œë°œì¼ê¸°, ë°ì´í„°ë² ì´ìŠ¤ì˜ ë¬´ê²°ì„±ì„ ë³´ì¥í•´ì£¼ëŠ” Write-Ahead-Log</a></li>
  <li><a href="https://www.alibabacloud.com/blog/what-are-the-differences-and-functions-of-the-redo-log-undo-log-and-binlog-in-mysql_598035" target="_blank">alibabacloud, What are the Differences and Functions of the Redo Log, Undo Log, and Binlog in MySQL?</a></li>
  <li><a href="https://coralogix.com/blog/5-essential-mysql-database-logs-to-keep-an-eye-on/" target="_blank">Coralogix, 5 Essential MySQL Database Logs To Keep an Eye On</a></li>
  <li><a href="https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98_%EB%A1%9C%EA%B7%B8" target="_blank">ìœ„í‚¤ë°±ê³¼, íŠ¸ëœì­ì…˜ ë¡œê·¸</a></li>
  <li><a href="datadoghq.com/knowledge-center/audit-logging/" target="_blank">Audit Logging Overview</a></li>
  <li><a href="https://scaling.dev/replication/log" target="_blank">scaling.dev, Transaction Log. Commit Log. WAL.</a></li>
  <li><a href="https://www.quora.com/What-is-a-DB-commit-log" target="_blank">Quora, What is a DB commit log?</a></li>
  <li><a href="https://www.postgresql.org/docs/current/wal-intro.html" target="_blank">PostgreSQL ê³µì‹ë¬¸ì„œ, Write-Ahead Logging (WAL)</a></li>
  <li><a href="https://betterprogramming.pub/mysqls-redolog-and-binlog-1a35bc052489" target="_blank">Dwen, MySQLâ€™s RedoLog and BinLog</a></li>
  <li><a href="https://developpaper.com/you-must-understand-the-three-mysql-logs-binlog-redo-log-and-undo-log/" target="_blank">developPAPER, You must understand the three MySQL logs â€“ binlog, redo log and undo log</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-redo-log.html" target="_blank">MySQL ê³µì‹ë¬¸ì„œ, 14.6.6 Redo Log</a></li>
  <li><a href="https://blog.katastros.com/a?ID=01200-5fbbae7f-7eb9-4570-876c-23048d66fb82" target="_blank">Katastros, InnoDB transaction log (redo log and undo log) detailed</a></li>
  <li><a href="https://github.com/heesuk-ahn/today-I-learned/blob/master/database/binary-log.md" target="_blank">heesuk-ahn, [ë°ì´í„°ë² ì´ìŠ¤] binary log ë€?</a></li>
  <li><a href="https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/binary-log.html" target="_blank">The Binary Log</a></li>
  <li><a href="https://jvns.ca/blog/2017/06/11/log-structured-storage/" target="_blank">Log-structured storage</a></li>
  <li><a href="http://thesecretlivesofdata.com/raft/" target="_blank">Video Demo,  Raft: Understandable Distributed Consensus</a></li>
  <li><a href="https://www.freecodecamp.org/news/in-search-of-an-understandable-consensus-algorithm-a-summary-4bc294c97e0d/" target="_blank">Understanding the Raft consensus algorithm: an academic article summary</a></li>
  <li><a href="https://bravenewgeek.com/building-a-distributed-log-from-scratch-part-2-data-replication/" target="_blank">Building a Distributed Log from Scratch, Part 2: Data Replication</a></li>
  <li><a href="https://hevodata.com/learn/apache-kafka-logs-a-comprehensive-guide/" target="_blank">HEVO, Apache Kafka Logs: A Comprehensive Guide</a></li>
</ul>
:ET