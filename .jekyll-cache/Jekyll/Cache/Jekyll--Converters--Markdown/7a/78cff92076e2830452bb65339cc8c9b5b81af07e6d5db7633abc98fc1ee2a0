I"ò<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#pytestê°€-ì¢‹ì€-ì´ìœ " id="markdown-toc-pytestê°€-ì¢‹ì€-ì´ìœ ">pytestê°€ ì¢‹ì€ ì´ìœ </a>    <ul>
      <li><a href="#less-boilerplate" id="markdown-toc-less-boilerplate">Less Boilerplate</a></li>
      <li><a href="#nicer-output" id="markdown-toc-nicer-output">Nicer Output</a></li>
      <li><a href="#easier-to-manage-state-and-dependencies" id="markdown-toc-easier-to-manage-state-and-dependencies">Easier to Manage State and Dependencies</a></li>
      <li><a href="#easy-to-filter-tests" id="markdown-toc-easy-to-filter-tests">Easy to Filter Tests</a></li>
      <li><a href="#allows-test-parametrization" id="markdown-toc-allows-test-parametrization">Allows Test Parametrization</a></li>
      <li><a href="#has-a-plugin-based-architecture" id="markdown-toc-has-a-plugin-based-architecture">Has a Plugin-Based Architecture</a></li>
    </ul>
  </li>
  <li><a href="#fixtures-managing-state-and-dependencies" id="markdown-toc-fixtures-managing-state-and-dependencies">Fixtures: Managing State and Dependencies</a></li>
  <li><a href="#marks-categorizing-tests" id="markdown-toc-marks-categorizing-tests">Marks: Categorizing Tests</a></li>
  <li><a href="#parametrization-combining-tests" id="markdown-toc-parametrization-combining-tests">Parametrization: Combining Tests</a></li>
</ul>

<hr />

<p>Testing your code brings a wide variety of benefits. It increases your confidence that the code behaves as you expect and ensures that changes to your code wonâ€™t cause regressions. Writing and maintaining tests is hard work, so you should leverage all the tools at your disposal to make it as painless as possible. <code class="language-plaintext highlighter-rouge">pytest</code> is one of the best tools that you can use to boost your testing productivity.</p>

<p>If youâ€™ve written unit tests for your Python code before, then you may have used Pythonâ€™s built-in <code class="language-plaintext highlighter-rouge">unittest</code> module. <code class="language-plaintext highlighter-rouge">unittest</code> provides a solid base on which to build your test suite, but it has a few shortcomings.</p>

<p>A number of third-party testing frameworks attempt to address some of the issues with <code class="language-plaintext highlighter-rouge">unittest</code>, and <code class="language-plaintext highlighter-rouge">pytest</code> has proven to be one of the most popular. <code class="language-plaintext highlighter-rouge">pytest</code> is a feature-rich, plugin-based ecosystem for testing your Python code.</p>

<h1 id="pytestê°€-ì¢‹ì€-ì´ìœ ">pytestê°€ ì¢‹ì€ ì´ìœ </h1>

<h2 id="less-boilerplate">Less Boilerplate</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">unittest</code>ëŠ” ìƒì†ë°›ê³ , unittestì—ì„œ ì œê³µí•˜ëŠ” assertë¬¸ì„ ì‚¬ìš©í•´ì•¼í•¨
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_with_unittest.py
</span>
<span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">TestCase</span>

<span class="k">class</span> <span class="nc">TryTesting</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_always_passes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_always_fails</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">pytest</code>ëŠ” ë³´í†µ í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ë“¯ ì‘ì„±í•˜ê³ , íŒŒì´ì¬ì—ì„œ ì œê³µí•˜ëŠ” assertë¬¸ ì‚¬ìš©í•˜ë©´ ë¨
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_with_pytest.py
</span>
<span class="k">def</span> <span class="nf">test_always_passes</span><span class="p">():</span>
    <span class="k">assert</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">test_always_fails</span><span class="p">():</span>
    <span class="k">assert</span> <span class="bp">False</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Most functional tests follow the Arrange-Act-Assert model:</p>

<ul>
  <li><strong>Arrange</strong>, or set up, the conditions for the test</li>
  <li><strong>Act</strong> by calling some function or method</li>
  <li><strong>Assert</strong> that some end condition is true</li>
</ul>

<h2 id="nicer-output">Nicer Output</h2>

<ul>
  <li>ë¨¼ì € ì‹œìŠ¤í…œ ìƒíƒœ, íŒŒì´ì¬ ë²„ì „, ë£¨íŠ¸ ë””ë ‰í† ë¦¬, ë°œê²¬ëœ í…ŒìŠ¤íŠ¸ì˜ ìˆ˜ì™€ ê°™ì€ ì •ë³´ë¥¼ ì œê³µ</li>
  <li>í…ŒìŠ¤íŠ¸ ê²°ê³¼ì˜ ì•„ì›ƒí’‹ì€ ë‹¤ìŒê³¼ ê°™ìŒ
    <ul>
      <li>A dot (.) means that the test passed.</li>
      <li>An F means that the test has failed.</li>
      <li>An E means that the test raised an unexpected exception.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test_with_pytest.py .F                                                   [ 50%]
test_with_unittest.py F.                                                 [100%]
</code></pre></div></div>

<p>ìœ„ì˜ ê²°ê³¼ë¥¼ í•´ì„í•´ë³´ë©´, test_with_pytest.py íŒŒì¼ ì•ˆì—ëŠ” ë‘ ê°œì˜ í…ŒìŠ¤íŠ¸ ì½”ë“œê°€ ìˆê³ , í•˜ë‚˜ëŠ” ì„±ê³µ, í•˜ë‚˜ëŠ” ì‹¤íŒ¨í–ˆìŒì„ ë‚˜íƒ€ë‚¸ë‹¤. test_with_unittest.py íŒŒì¼ ì•ˆì—ì„œëŠ” í•˜ë‚˜ëŠ” ì‹¤íŒ¨, í•˜ë‚˜ëŠ” ì„±ê³µí–ˆì„ìŒ ë‚˜íƒ€ë‚¸ë‹¤. pytestë¡œ ì‹¤í–‰í•˜ë©´ ìœ„ì™€ê°™ì´ unittestë¡œ ì‘ì„±í•œ í…ŒìŠ¤íŠ¸ ì½”ë“œë„ ì¸ì‹í•  ìˆ˜ ìˆë‹¤.</p>

<h2 id="easier-to-manage-state-and-dependencies">Easier to Manage State and Dependencies</h2>

<ul>
  <li>í…ŒìŠ¤íŠ¸ì— ì‚¬ìš©ë˜ëŠ” ë°ì´í„° íƒ€ì…ì´ dict, jsonê³¼ ê°™ì´ ë‹¤ë¥´ë‹¤</li>
  <li>pytest takes a different approach. It leads you toward explicit dependency declarations that are still reusable thanks to the availability of fixtures. pytest fixtures are functions that can create data, test doubles, or initialize system state for the test suite. Any test that wants to use a fixture must explicitly use this fixture function as an argument to the test function, so dependencies are always stated up front:</li>
</ul>

<h2 id="easy-to-filter-tests">Easy to Filter Tests</h2>

<h2 id="allows-test-parametrization">Allows Test Parametrization</h2>

<h2 id="has-a-plugin-based-architecture">Has a Plugin-Based Architecture</h2>

<h1 id="fixtures-managing-state-and-dependencies">Fixtures: Managing State and Dependencies</h1>

<h1 id="marks-categorizing-tests">Marks: Categorizing Tests</h1>

<h1 id="parametrization-combining-tests">Parametrization: Combining Tests</h1>
:ET