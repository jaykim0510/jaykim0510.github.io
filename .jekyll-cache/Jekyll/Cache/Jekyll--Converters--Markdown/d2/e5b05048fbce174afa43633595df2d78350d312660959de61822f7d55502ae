I"&<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#프로세스" id="markdown-toc-프로세스">프로세스</a>    <ul>
      <li><a href="#프로세스의-네-가지-상태" id="markdown-toc-프로세스의-네-가지-상태">프로세스의 네 가지 상태</a></li>
      <li><a href="#프로세스의-구조" id="markdown-toc-프로세스의-구조">프로세스의 구조</a></li>
    </ul>
  </li>
  <li><a href="#스레드" id="markdown-toc-스레드">스레드</a></li>
  <li><a href="#프로세스간-통신" id="markdown-toc-프로세스간-통신">프로세스간 통신</a></li>
  <li><a href="#교착-상태" id="markdown-toc-교착-상태">교착 상태</a></li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>
<hr />

<h1 id="프로세스">프로세스</h1>
<p>프로세스 관리는 운영체제의 핵심적인 역할</p>

<p>프로세스가 생성되고 작업을 마칠 때까지의 상태 변화</p>

<p>프로세스와 스레드 비교</p>

<p>스레드 사용의 이점</p>

<p>운영체제에서 프로세스는 하나의 작업 단위</p>

<p>프로그램을 실행하면 프로세스가 된다</p>

<p>프로그램은 하드디스크 같은 저장장치에 저장</p>

<p>프로그램을 실행하면 해당 코드가 메모리에 올라와서 작업이 진행된다</p>

<p>프로그램은 저장장치에 저장되어 있는 정적인 상태</p>

<p>프로세스는 실행을 위해 메모리에 올라온 동적인 상태</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>프로그램 - 클래스 - 레시피

프로세스 - 객체  - 요리
</code></pre></div></div>

<p>CPU가 시간을 쪼개어 여러 프로세스에 적당히 배분함으로써 도잇에 실행하는 것처럼 느껴진다</p>

<h2 id="프로세스의-네-가지-상태">프로세스의 네 가지 상태</h2>

<p>시분할 방식에서의 예상치 못한 상황 처리</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>새우튀김을 해야하는데 새우가 아직 손질되지 않았다고 가정해보자. 메인 셰프가 보조 요리사에게 새우 손질을 지시한다  
그동안 메인 셰프가 아무것도 하지 않으면 비효율적이다.  
메인 셰프는 새우튀김을 '대기 목록'으로 옮기고 주문 목록에 있는 다른 주문서를 가져와서 요리를 해야한다.  

새우 손질이 끝났다고 가정해보자. 그렇다고 바로 대기 목록에서 새우튀김을 가져와서 바로 요리하지는 않는다.  

우선 현재 작업 중이던 요리를 마친 뒤 새우튀김을 만드는 것이 좋다. 따라서 새우튀김 요리 주문서를 대기 목록에서 주문 목록 뒤에 이동시킨 뒤 순서를 기다린다.  
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>손님이 급한 볼일을 보느라 음식을 천천히 달라고 요청하는 경우도 있다. 손님의 지연 요청은 언제 끝날지 알 수 없기 때문에 무작정 대기 목록에 올려둘 수 없다. (손님이 지연 끝에 취소를 할 수도 있다)  

이와 같이 언제 다시 시작될지 모르는 주문서는 '보류 목록'으로 옮기고, 손님이 음식을 달라고 하면 보류 목록에 있는 주문서를 '주문 목록'으로 보낸다.  
보류 목록은 언제 다시 시작될지 모르거나, 중간에 그만둘지 모르는 작업들을 모아두는 곳이다
</code></pre></div></div>

<p>현대의 운영체제는 시분할 방식을 기본으로 사용한다. 프로세스가 여러 상태를 오가며 실행된다. 그렇다면 운영체제가 어떻게 여러 프로세스를 동시에 처리하는지 살펴보자.</p>

<p><strong>프로그램에서 프로세스로의 전환</strong></p>

<p>프로세스는 컴퓨터 시스템의 작업 단위로 태스크라고도 불린다.</p>

<p>시분할 방식 시스템에서 프로그램이 프로세스로 전환될 때 어떤 일이 일어나는지 살펴보자</p>

<p>우선 운영체제는 프로그램을 메모리의 적당한 위치로 가져온다. 그와 동시에 주문서에 해당하는 작업 지시서(프로세스 제어블록)를 만든다. 프로세스 제어블록에는 프로세스를 처리하는 데 필요한 다양한 정보가 들어 있다. 프로그램이 프로세스로 전환되려면 운영체제로부터 프로세스 제어블록을 받아야 한다. (프로세스 제어블록은 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에 운영체제 영역에 만들어진다) 프로세스가 종료되면 메모리에서 삭제되고, 프로세스 제어블록도 폐기된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>프로세스 제어블록에 포함된 대표적인 정보

- 프로세스 구분자: 프로세스를 구분하는 구분자(PID)

- 메모리 관련 정보: 프로세스가 올라가 있는 메모리의 위치 정보

- 각종 중간값: 프로세스가 사용했던 각종 중간값 (시분할 시스템이기 때문에 중간값을 저장해야 한다) 
            (ex. 다음 작업할 코드의 위치가 담긴 프로그램 카운터, 각종 중간값을 보관 중인 레지스터)
</code></pre></div></div>

<p><img src="/images/os_3.png" alt="" /></p>

<p><strong>프로세스의 상태</strong></p>

<p>앞서 레스토랑의 예에서 주문서가 다양한 목록을 옮겨 다니는 것과 같이, 운영체제에서도 여러 가지 이유로 프로세스 상태가 변화된다. 시분할 시스템에서 프로세스는 CPU 리소스를 넘겨주고 다시 받고 하는 일이 빈번하게 일어난다. 프로세스는 상황에 따라 다섯 가지 상태를 오간다.</p>

<ul>
  <li><strong>생성 상태</strong>
    <ul>
      <li>프로세스가 메모리에 올라와 실행 준비를 완료한 상태</li>
      <li>프로세스를 관리하는데 필요한 프로세스 제어블록이 생성됨</li>
    </ul>
  </li>
  <li><strong>준비 상태</strong>
    <ul>
      <li>생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태</li>
      <li>디스패치: CPU 스케줄러가 준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일</li>
    </ul>
  </li>
  <li><strong>실행 상태</strong>
    <ul>
      <li>준비 상태에 있던 프로세스가 CPU를 얻어 실제 작업을 수행하는 상태</li>
      <li>프로세스 제어블록을 CPU에 전달</li>
      <li>주어진 시간내 작업이 끝나지 않은 경우 다시 준비 상태로 돌아감(클록이 인터럽트를 사용해 CPU에 알림)</li>
      <li>작업이 끝날때까지 준비 상태와 실행 상태를 왔다 갔다함</li>
    </ul>
  </li>
  <li><strong>완료 상태</strong>
    <ul>
      <li>실행 상태의 프로세스가 시간내 작업을 마치면 완료 상태로 진입</li>
      <li>프로세스 제어블록이 사라진 상태</li>
    </ul>
  </li>
  <li><strong>대기 상태</strong>
    <ul>
      <li>프로세스가 입출력을 요청하면 입출력 관리자가 입출력을 완료하기 전까지 프로세스를 대기 상태로 옮겨둔다</li>
      <li>입출력 관리자가 입출력을 완료하면 프로세스를 대기 상태에서 준비 상태로 옮긴다</li>
    </ul>
  </li>
</ul>

<p><img src="/images/os_5.png" alt="" /></p>

<p><strong>컨텍스트 스위칭</strong></p>

<p>컨텍스트 스위칭(context switching)은 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다. 이 때 두 프로세스 제어블록의 내용이 변경된다. 실행 상태에서 나가는 프로세스 제어블록에는 CPU에 있던 지금까지의 작업 내용을 저장하고, 반대로 실행 상태로 들어오는 프로세스 제어블록의 내용으로 CPU를 다시 세팅한다. 이와 같이 두 프로세스의 프로세스 제어블록을 교환하는 작업을 컨텍스트 스위칭이라 한다.</p>

<p>컨텍스트 스위칭은 인터럽트가 걸렸을 때 발생한다.</p>

<ul>
  <li>타임아웃 인터럽트</li>
  <li>프로세스가 자신에게 주어진 메모리 공간을 넘어가려 할 때 발생하는 인터럽트 등</li>
</ul>

<h2 id="프로세스의-구조">프로세스의 구조</h2>

<p><img src="/images/os_7.png" alt="" /></p>

<ul>
  <li><strong>코드 영역</strong>
    <ul>
      <li>프로그램의 코드가 기술된 곳으로 텍스트 영역이라고도 함</li>
      <li>자기 자신을 수정하는 프로그램은 존재하지 않기 때문에, 코드는 읽기 전용으로 처리</li>
    </ul>
  </li>
  <li><strong>데이터 영역</strong>
    <ul>
      <li>코드가 실행되면서 사용되는 변수나 파일 등의 각종 데이터를 모아놓는 곳</li>
      <li>변수는 기본적으로 읽기와 쓰기가 가능</li>
    </ul>
  </li>
  <li><strong>스택 영역</strong>
    <ul>
      <li>프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳</li>
      <li>예를들어, 함수가 호출되면 함수를 수행하고 마치면 다시 되돌아올 위치를 이 영역에 저장</li>
      <li>스택 영역은 운영체제가 사용자의 프로세스를 작동하기 위해 유지하는 영역이므로 사용자에게는 보이지 않음</li>
    </ul>
  </li>
</ul>

<h1 id="스레드">스레드</h1>

<h1 id="프로세스간-통신">프로세스간 통신</h1>

<h1 id="교착-상태">교착 상태</h1>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;barcode=9791156644071" target="_blank">쉽게 배우는 운영체제 책 참고</a></li>
</ul>
:ET