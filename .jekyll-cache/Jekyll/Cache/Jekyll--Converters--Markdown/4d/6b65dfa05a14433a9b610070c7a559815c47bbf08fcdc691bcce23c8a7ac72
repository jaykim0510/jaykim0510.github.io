I"<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#dynamic-programming" id="markdown-toc-dynamic-programming">Dynamic Programming</a>    <ul>
      <li><a href="#언제-적용-가능한가" id="markdown-toc-언제-적용-가능한가">언제 적용 가능한가</a></li>
      <li><a href="#적용-가능한-문제의-대표적인-특징" id="markdown-toc-적용-가능한-문제의-대표적인-특징">적용 가능한 문제의 대표적인 특징</a></li>
      <li><a href="#문제-예시" id="markdown-toc-문제-예시">문제 예시</a></li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="dynamic-programming">Dynamic Programming</h1>

<ul>
  <li>Explore all possible solution efficiently, systematically</li>
  <li>모든 가능한 경우를 다 확인해야 하는 경우에 효율적이고 정형화된 코드를 작성하도록 하는 알고리즘</li>
</ul>

<h2 id="언제-적용-가능한가">언제 적용 가능한가</h2>

<ul>
  <li>하나의 문제를 여러 개의 작은 문제로 나눌 수 있는 경우
    <ul>
      <li>작은 문제: <strong>overlapping</strong> subproblems -&gt; <strong>reused multiple times</strong></li>
    </ul>
  </li>
  <li>작은 문제의 해를 통해 원래 문제의 해를 만들 수 있는 경우</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F(n-1) + F(n-2)   =   F(n)
  subproblems  original problem
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>즉, 중복되는 부분 문제의 최적해를 통해 원래 문제의 최적 해를 얻을 수 있는 경우
</code></pre></div></div>

<p>하지만 주어진 문제가 이런 조건에 맞는지 알기 어렵다. 반대로, DP로 풀리는 문제가 가지는 대표적인 특징을 알아보자.</p>

<h2 id="적용-가능한-문제의-대표적인-특징">적용 가능한 문제의 대표적인 특징</h2>

<ul>
  <li>최대값, 최소값을 묻는 경우 (최소비용, 최대이윤, 가장 긴 거리)</li>
  <li>~할 수 있는 방법의 수를 묻는 경우 (A에서 B로 갈 수 있는 방법의 수)</li>
  <li>위의 2가지 특징은 Greedy 알고리즘 문제에서도 나타나는 특징</li>
  <li>Greedy 알고리즘과 구분되는 DP 문제만의 특징: <strong>미래의 결정이 이전의 결정에 의존</strong>
    <ul>
      <li>Greedy 알고리즒은 매 시점에서 최대의 이익을 얻는 방법</li>
    </ul>
  </li>
</ul>

<h2 id="문제-예시">문제 예시</h2>

<p>House Robber: 도둑이 집을 털 때, 훔칠 수 있는 돈의 최대 금액</p>

<p>문제가 여기서 끝이라면 Greedy 알고리즘을 써도 된다.</p>

<p>하지만 다음과 같은 제약사항이 있다고 해보자: <strong>adjacent하게 집을 털 수는 없다</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>각 집들이 가지고 있는 돈 = [2, 7, 9, 3, 1]

adjacent하게 집을 털 수 없기 때문에, 

2를 선택할 경우: 2 -&gt; 9 -&gt; 1
7을 선택할 경우: 7 -&gt; 3

과거에 2를 선택했는지, 7을 선택했는지에 따라 다음 내가 선택할 수 있는 결정이 달라진다 -&gt; DP로 접근해야함
</code></pre></div></div>

:ET