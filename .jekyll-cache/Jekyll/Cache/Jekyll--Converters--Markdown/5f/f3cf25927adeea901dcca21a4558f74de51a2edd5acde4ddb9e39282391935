I"<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#스프링-역사" id="markdown-toc-스프링-역사">스프링 역사</a></li>
  <li><a href="#스프링" id="markdown-toc-스프링">스프링</a>    <ul>
      <li><a href="#스프링-프레임워크" id="markdown-toc-스프링-프레임워크">스프링 프레임워크</a></li>
      <li><a href="#스프링-부트" id="markdown-toc-스프링-부트">스프링 부트</a></li>
      <li><a href="#스프링의-핵심-컨셉" id="markdown-toc-스프링의-핵심-컨셉">스프링의 핵심 컨셉</a></li>
    </ul>
  </li>
  <li><a href="#객체-지향" id="markdown-toc-객체-지향">객체 지향</a>    <ul>
      <li><a href="#다형성" id="markdown-toc-다형성">다형성</a></li>
      <li><a href="#제어의-역전-의존-관계-주입" id="markdown-toc-제어의-역전-의존-관계-주입">제어의 역전, 의존 관계 주입</a></li>
      <li><a href="#서버와-클라이언트" id="markdown-toc-서버와-클라이언트">서버와 클라이언트</a></li>
      <li><a href="#solid" id="markdown-toc-solid">SOLID</a></li>
      <li><a href="#스프링과-객체-지향" id="markdown-toc-스프링과-객체-지향">스프링과 객체 지향</a></li>
    </ul>
  </li>
  <li><a href="#스프링-컨테이너와-빈" id="markdown-toc-스프링-컨테이너와-빈">스프링 컨테이너와 빈</a>    <ul>
      <li><a href="#appconfig" id="markdown-toc-appconfig">AppConfig</a></li>
      <li><a href="#applicationcontext" id="markdown-toc-applicationcontext">ApplicationContext</a></li>
    </ul>
  </li>
  <li><a href="#싱글톤-컨테이너" id="markdown-toc-싱글톤-컨테이너">싱글톤 컨테이너</a></li>
  <li><a href="#컴포넌트-스캔" id="markdown-toc-컴포넌트-스캔">컴포넌트 스캔</a></li>
  <li><a href="#의존관계-자동-주입" id="markdown-toc-의존관계-자동-주입">의존관계 자동 주입</a></li>
  <li><a href="#빈-생명주기-콜백" id="markdown-toc-빈-생명주기-콜백">빈 생명주기 콜백</a></li>
  <li><a href="#빈-스코프" id="markdown-toc-빈-스코프">빈 스코프</a>    <ul>
      <li><a href="#프로토타입-스코프" id="markdown-toc-프로토타입-스코프">프로토타입 스코프</a></li>
      <li><a href="#request-스코프" id="markdown-toc-request-스코프">request 스코프</a></li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="스프링-역사">스프링 역사</h1>

<ul>
  <li><strong>EJB(Enterprise Java Beans)</strong>:
    <ul>
      <li>기업환경의 시스템을 구현하기 위한 서버측 컴포넌트 모델 (서버를 구현하기 위해 필요한 각종 기능들을 제공)</li>
      <li>서버 구현에 필요한 거의 모든 기능(ORM, 서버 애플리케이션 프레임워크 등)을 제공했지만 어렵고 느리고 비싸다</li>
    </ul>
  </li>
  <li><strong>하이버네이트(Hybernate)</strong>:
    <ul>
      <li>EJB에서 JPA 기능을 담당하던 엔티티 빈을 훨씬 사용하기 편하도록 구현</li>
      <li>하이버네이트를 조금 더 일반화 시켜 JPA를 표준화(용어를 통일시키고 기능을 일반화)시킴</li>
      <li>하이버네이트는 JPA의 구현체중 하나
<img src="/images/jpa_1.png" alt="" /></li>
    </ul>
  </li>
  <li><strong>스프링(Spring)</strong>:
    <ul>
      <li>EJB의 서버 애플리케이션 프레임워크를 훨씬 사용하기 편하게 만듬</li>
      <li>EJB의 시대가 끝나고 봄(Spring)이 왔다 -&gt; 스프링</li>
    </ul>
  </li>
  <li><strong>스프링 부트(Spring Boot)</strong>:
    <ul>
      <li>스프링은 다 좋은데 설정하기가 힘들다</li>
      <li>스프링은 별도의 웹 서버도 있어야 하고, 서버 애플리케이션을 띄우기 위해 빌드도 해야한다</li>
      <li>스프링 부트가 이 모든 것들을 해결해준다</li>
    </ul>
  </li>
</ul>

<p><strong>JPA(Java Persistence API)</strong></p>

<ul>
  <li>자바 진영의 ORM 표준 기술</li>
  <li>SQL 작성없이 객체를 DB에 직접 저장</li>
</ul>

<p><strong>ORM(Object Relational Mapping)</strong></p>

<ul>
  <li>메모리 상의 객체를 DB에 데이터로 저장시켜주는 기술</li>
</ul>

<h1 id="스프링">스프링</h1>

<ul>
  <li>스프링은 하둡(Hadoop)이 HDFS와 MapReduce와 같은 기술들을 일컫는 생태계를 나타내는 것처럼 스프링도 스프링 생태계를 나타냄</li>
  <li>각각의 기술들은 <a href="https://spring.io/projects"><strong>공식문서 참고</strong></a></li>
</ul>

<p><img src="/images/spring_1.png" alt="" /></p>

<h2 id="스프링-프레임워크">스프링 프레임워크</h2>

<ul>
  <li><strong>핵심 기술</strong>: 스프링 DI 컨테이너, AOP, 이벤트 등 (디자인 패턴 같은 느낌)</li>
  <li><strong>웹 기술</strong>: 스프링 MVC (백엔드 설계 패턴(아키텍처) 같은 느낌)</li>
  <li><strong>데이터 접근</strong> 기술: 트랜잭션, JDBC, JPA</li>
  <li><strong>기술 통합</strong>: 캐시, 이메일, 원격접근, 스케줄링</li>
  <li><strong>테스트</strong>: 스프링 기반 테스트 지원</li>
</ul>

<h2 id="스프링-부트">스프링 부트</h2>

<ul>
  <li>스프링을 편리하게 사용할 수 있도록 지원</li>
  <li>Tomcat 같은 웹 서버 내장</li>
  <li>스프링과 외부 라이브러리 자동 구성</li>
</ul>

<h2 id="스프링의-핵심-컨셉">스프링의 핵심 컨셉</h2>
<ul>
  <li>웹 애플리케이션을 만들어주는 프레임워크</li>
  <li>데이터베이스에 접근을 편리하게 함</li>
  <li><strong>객체 지향 설계를 지원하는 프레임워크</strong></li>
</ul>

<h1 id="객체-지향">객체 지향</h1>

<h2 id="다형성">다형성</h2>
<ul>
  <li>객체 지향 코드를 작성할 때 얻을 수 있는 가장 큰 특징은 <strong>다형성</strong></li>
  <li>다형성은 <strong>역할(인터페이스)과 구현(클래스)으로 나누어</strong> 코드를 설계</li>
  <li>코드 설계시 역할만 알아도 됨</li>
  <li>빠른 설계와 유연한 확장 가능</li>
</ul>

<h2 id="제어의-역전-의존-관계-주입">제어의 역전, 의존 관계 주입</h2>
<ul>
  <li>스프링은 <strong>다형성을 위해 제어의 역전(IoC), 의존관계 주입(DI) 방식으로 개발</strong>하도록 지원</li>
  <li>스프링 컨테이너(<code class="language-plaintext highlighter-rouge">ApplicationContext</code>)가 위 방식을 가능하게 함</li>
  <li>서비스를 공연에 비유하면 스프링 컨테이너는 공연 기획자에 해당</li>
</ul>

<h2 id="서버와-클라이언트">서버와 클라이언트</h2>
<ul>
  <li>서버와 클라이언트를 각각 객체로 구현</li>
  <li>클라이언트는 요청하는 객체, 서버는 응답하는 객체</li>
  <li>수 많은 클라이언트 객체와 서버 객체는 서로 협력 관계를 가짐</li>
  <li>서버와 클라이언트 구조에 다형성을 적용하면, 클라이언트를 변경하지 않고, 서버의 기능을 유연하게 변경할 수 있음</li>
  <li>(인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있음)</li>
  <li>인터페이스를 안정적으로 잘 설계하는 것이 중요</li>
</ul>

<h2 id="solid">SOLID</h2>

<ul>
  <li>좋은 객체 지향 설계를 위한 5가지 원칙</li>
  <li><strong>S</strong>(Single Responsibility Principle): 단일 책임 원칙
    <ul>
      <li>하나의 클래스는 하나의 책임만 가진다</li>
      <li>하나의 책임? -&gt; 모호하다</li>
      <li>핵심 의미는 변경이 생겼을 때 파급 효과가 적냐이다 -&gt; 책임을 적절히 잘 분리해야 한다</li>
    </ul>
  </li>
  <li><strong>O</strong>(Open/Closed Principle): <strong>개방/폐쇄 원칙</strong>
    <ul>
      <li>확장이 되더라도 변경은 일어나면 안된다</li>
      <li>이런 마법같은 일이?</li>
      <li>확장은 구현하는 객체에만 반영하고, 인터페이스에 대한 변경은 막자 -&gt; <strong>다른 구현체에 영향을 끼치지 말자</strong></li>
      <li>객체 지향의 특성중 다형성과 관련 -&gt; 제어의 역전, 의존관계 주입 방식 필요 -&gt; OCP를 지키기 위해서는 IoC와 DI가 있어야됨</li>
    </ul>
  </li>
  <li><strong>L</strong>(Liskov Substitution Principle): 리스코프 치환 원칙
    <ul>
      <li>인터페이스를 구현하는 모든 객체 인스턴스는 인터페이스의 규약을 잘 지켜야함</li>
      <li>그래야 구현한 객체들중 어떤 것들로 치환하더라도 일관되게 동작할 수 있음</li>
    </ul>
  </li>
  <li><strong>I</strong>(Interface Segregation Principle): 인터페이스 분리 원칙
    <ul>
      <li>하나의 범용적인 인터페이스보다 역할에 맞게 인터페이스를 분리하여 정의하는 것이 좋음</li>
      <li>단일 책임 원칙과 비슷한 철학</li>
    </ul>
  </li>
  <li><strong>D</strong>(Dependency Inversion Principle): <strong>의존관계 역전 원칙</strong>
    <ul>
      <li>컴포넌트들이 구현 클래스가 아니라 <strong>인터페이스에 의존</strong>하도록 해야함</li>
      <li>DIP도 다형성과 관련 -&gt; <strong>OCP와 DIP 모두 제어의 역전(IoC), 의존관계 주입(DI)을 필요로함</strong></li>
    </ul>
  </li>
</ul>

<h2 id="스프링과-객체-지향">스프링과 객체 지향</h2>

<ul>
  <li>스프링은 <strong>DI(Dependency Injection) 컨테이너</strong> 기술을 통해 객체지향의 OCP, DIP 원칙을 지키도록 해줌</li>
  <li>DI 컨테이너 기술 덕분에 <strong>기능의 확장을 부품 교체하듯</strong> 할 수 있게 됨</li>
</ul>

<h1 id="스프링-컨테이너와-빈">스프링 컨테이너와 빈</h1>

<ul>
  <li>구현체에는 의존관계가 없어야함 -&gt; 의존관계는 인터페이스간에 있어야함 (DIP 원칙)
    <ul>
      <li>구현체에 의존관계가 있으면 (DIP 원칙 위배) -&gt; 기능 확장시 구현체간에 영향 끼침 (OCP 원칙 위배)</li>
    </ul>
  </li>
  <li>근데 인터페이스간에 의존관계만 정의하게 되면 구현 객체를 상황에 맞게 생성할 수가 없음
    <ul>
      <li>그래서 런타임 단계에서 적절히 구현 객체를 생성하고 연결해 줄 존재가 필요 -&gt; 이를 담당하는 설정 클래스를 만들자 -&gt; <code class="language-plaintext highlighter-rouge">AppConfig</code> 클래스</li>
    </ul>
  </li>
</ul>

<h2 id="appconfig">AppConfig</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">AppConfig</code>는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성</li>
  <li><code class="language-plaintext highlighter-rouge">AppConfig</code>는 생성한 객체 인스턴스의 참조를 생성자를 통해 주입(연결)</li>
  <li><code class="language-plaintext highlighter-rouge">AppConfig</code>가 바로 <strong>의존관계 주입해주는 존재</strong>였음</li>
  <li>기능 변경으로 인한 코드 변경은 <code class="language-plaintext highlighter-rouge">AppConfig</code>에서만 일어난다</li>
  <li><code class="language-plaintext highlighter-rouge">AppConfig</code>는 의존관계 주입뿐만 아니라, <strong>제어의 흐름</strong>까지 담당 -&gt; 구현 객체는 자신의 로직을 실행하는 역할만 담당</li>
  <li>이러한 <code class="language-plaintext highlighter-rouge">AppConfig</code> 클래스를 IoC 컨테이너 또는 <strong>DI 컨테이너</strong>라고 함</li>
  <li>스프링에서는 이러한 <code class="language-plaintext highlighter-rouge">AppConfig</code>를 담당하는 클래스에 <code class="language-plaintext highlighter-rouge">@Configuration</code>을 붙여줌 (<code class="language-plaintext highlighter-rouge">@Configuration</code>이 빈의 싱글톤을 보장)</li>
  <li>그리고 <code class="language-plaintext highlighter-rouge">AppConfig</code>에서 각 구현체를 리턴하는 메서드에는 <code class="language-plaintext highlighter-rouge">@Bean</code>을 붙여줌 -&gt; 스프링 컨테이너에 스프링 빈으로 등록됨 -&gt; 스프링 컨테이너의 관리 대상이 됨</li>
  <li>(<code class="language-plaintext highlighter-rouge">@Bean</code>이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 없으면 생성해서 스프링 컨테이너에 등록하고 반환)</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>
  
  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">MemberService</span> <span class="nf">memberService</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">MemberServiceImpl</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">MemberRepository</span> <span class="nf">memberRepository</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">MemoryRepository</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">AppConfig</span> <span class="n">appConfig</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AppConfig</span><span class="o">();</span>
  <span class="nc">MemberService</span> <span class="n">memberService</span> <span class="o">=</span> <span class="n">appConfig</span><span class="o">.</span><span class="na">memberService</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="applicationcontext">ApplicationContext</h2>
<ul>
  <li><strong>ApplicationContext</strong>를 스프링 컨테이너라 함</li>
  <li>ApplicationContext는 인터페이스이다</li>
  <li>스프링 컨테이너는 DI 컨테이너를 더욱 사용하기 편하게 만든 것</li>
  <li>스프링 컨테이너는 <code class="language-plaintext highlighter-rouge">AppConfig</code> 내의 구현 객체를 스프링 컨테이너에 빈으로 알아서 등록하고 알아서 의존관계를 주입해줌</li>
  <li>빈(Bean)은 의존관계 주입을 위해 스프링 컨테이너에서 기다리는 구현 객체라고 생각하면 됨</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// AnnotationConfigApplicationContext는 ApplicationContext을 구현한 것중 하나</span>
<span class="c1">// ac가 우리의 빈을 관리해주는 스프링 컨테이너</span>
<span class="nc">ApplicationContext</span> <span class="n">ac</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="nc">MemberService</span> <span class="n">memberService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"memberService"</span><span class="o">,</span> <span class="nc">MemberService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

</code></pre></div></div>

<h1 id="싱글톤-컨테이너">싱글톤 컨테이너</h1>

<ul>
  <li>스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생</li>
  <li>웹 애플리케이션은 보통 여러 고객이 동시에 요청</li>
  <li><code class="language-plaintext highlighter-rouge">AppConfig</code> 클래스가 요청이 들어올 때마다 새로운 객체를 생성함 -&gt; 메모리 낭비가 커짐 -&gt; <strong>객체를 1개만 생성하고 공유하도록 설계</strong></li>
  <li><code class="language-plaintext highlighter-rouge">private static final SingletonService instance = new SingletonService();</code></li>
  <li>스프링 컨테이너는 싱글톤 패턴의 문제점(DIP, OCP 위반 가능성. 유연성 떨어짐)을 해결하면서, 객체 인스턴스를 싱글톤으로 관리</li>
  <li>스프링 <strong>빈(Bean)이 바로 싱글톤으로 관리되는 객체</strong></li>
  <li>객체 인스턴스를 공유하기 때문에 싱글톤 객체(스프링 빈)를 <strong>무상태로 설계</strong>해야함 -&gt; 특정 클라이언트에 의존적인 필드가 있으면 안됨, 가급적 읽기만 가능해야함</li>
</ul>

<h1 id="컴포넌트-스캔">컴포넌트 스캔</h1>

<ul>
  <li>스프링에서 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 도와주는 기능</li>
  <li>원래는 <code class="language-plaintext highlighter-rouge">AppConfig</code> 내에 구현체를 리턴하는 메서드를 정의하고 위에 @Bean을 붙이는 작업을 직접해야 했음
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>
    
  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">MemberService</span> <span class="nf">memberService</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">MemberServiceImpl</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">MemberRepository</span> <span class="nf">memberRepository</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">MemoryRepository</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>이제는 이렇게 <code class="language-plaintext highlighter-rouge">AppConfig</code>에 <code class="language-plaintext highlighter-rouge">@ComponentScan</code>을 붙이고, 각 구현체에 <code class="language-plaintext highlighter-rouge">@Component</code>만 붙여주면 됨 (리턴하는 메서드를 정의, <code class="language-plaintext highlighter-rouge">@Bean</code>의 수고가 사라짐)
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>
      
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@Component</code>이 붙은 클래스를 스캔해서 스프링 빈으로 등록해줌
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemoryMemberRepository</span> <span class="kd">implements</span> <span class="nc">MemberRepository</span> <span class="o">{}</span>
</code></pre></div>    </div>
  </li>
  <li>근데 원래 <code class="language-plaintext highlighter-rouge">AppConfig</code>내에서 의존 관계를 주입했었는데, 의존관계는 이제 어떻게 해결하나? -&gt; <code class="language-plaintext highlighter-rouge">@Autowired</code>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>
    
  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">MemberService</span> <span class="nf">memberService</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">MemberServiceImpl</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">());</span> <span class="c1">// memberService와 memberRepository간의 의존 관계가 이렇게 정의되어 있었음</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="의존관계-자동-주입">의존관계 자동 주입</h1>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@Autowired</code>가 의존관계를 자동으로 주입</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberServiceImpl</span> <span class="kd">implements</span> <span class="nc">MerberService</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">;</span>

  <span class="nd">@Autowired</span>
  <span class="kd">public</span> <span class="nf">MemberServiceImpl</span><span class="o">(</span><span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">memberRepository</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h1 id="빈-생명주기-콜백">빈 생명주기 콜백</h1>

<ul>
  <li>DB 커넥션 풀, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면 객체의 초기화와 종료 작업이 필요하다</li>
  <li>스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료되고 초기화 작업을 할 수 있다
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>객체 생성 -&gt; 의존관계 주입 -&gt; 초기화
</code></pre></div>    </div>
  </li>
  <li>의존관계 주입이 완료되는 시점에 스프링이 콜백 함수를 통해 초기화 시점을 알려준다. 또한 스프링 컨테이너가 종료되기 직전에 소멸 콜백 함수로 종료 시점을 알려준다</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>스프링 컨테이너 생성 -&gt; 빈 생성 -&gt; 의존관계 주입 -&gt; 초기화 콜백 -&gt; 사용 -&gt; 소멸전 콜백 -&gt; 스프링 종료
</code></pre></div></div>

<ul>
  <li>스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원 -&gt; 하지만 가장 많이 사용하는 방식은 <code class="language-plaintext highlighter-rouge">@PostConstruct</code>, <code class="language-plaintext highlighter-rouge">@PreDestory</code> 애노테이션</li>
  <li>의존관계가 주입되고 실행되길 원하는 초기화 함수에 <code class="language-plaintext highlighter-rouge">@PostConstruct</code> 애노테이션을 붙여준다
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@PostConstruct</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="err">"</span><span class="nc">NetworkClient</span><span class="o">.</span><span class="na">init</span><span class="o">);</span>
  <span class="n">connect</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="빈-스코프">빈 스코프</h1>

<ul>
  <li>스프링 빈은 기본적으로 싱글톤 스코프로 생성 -&gt; 스프링 컨테이너의 시작과 함께 생성되고 컨테이너가 종료될 떼까지 유지됨</li>
  <li>스프링은 다양한 스코프를 지원
    <ul>
      <li>싱글톤: 가장 넓은 범위의 스코프</li>
      <li>프로토타입: 빈의 생성과 의존관계 주입까지만 스프링 컨테이너가 관여 -&gt; 매우 짧은 범위의 스코프</li>
      <li>웹 관련 스코프
        <ul>
          <li>request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프</li>
          <li>session: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프</li>
          <li>application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Scope</span><span class="o">(</span><span class="s">"prototype"</span><span class="o">)</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloBean</span> <span class="o">{}</span>

<span class="c1">// 또는</span>

<span class="nd">@Scope</span><span class="o">(</span><span class="s">"prototype"</span><span class="o">)</span>
<span class="nd">@Bean</span>
<span class="nc">PrototypeBean</span> <span class="nf">HelloBean</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">HelloBean</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="프로토타입-스코프">프로토타입 스코프</h2>
<ul>
  <li>빈의 생성과 의존관계 주입, 초기화까지만 스프링 컨테이너가 관여 -&gt; 이 후 클라이언트에 빈을 반환하고, 스프링 컨테이너는 더이상 빈을 관리 안함</li>
  <li>이후 빈을 종료하고 싶으면 그때는 클라이언트 빈이 해줘야함</li>
  <li>프로토타입 스코프의 빈을 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환</li>
  <li>스프링은 일반적으로 싱글톤 빈을 사용 -&gt; 싱글톤 빈이 보통 프로토타입 빈을 사용</li>
  <li>근데 싱글톤 빈은 생성 시점에만 의존관계 주입을 받기 때문에, 프로토타입 빈이 새로 생성되기는 하지만, 싱글톤 빈과 함께 계속 유지되는 것이 문제</li>
  <li>어떻게 하면 사용할 때마다 항상 새로운 프로토타입 빈을 생성할 수 있을까 -&gt; 싱글톤 빈이 프로토타입을 사용할 떄마다 스프링 컨테이너에 새로 요청
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">class</span> <span class="nc">ClientBean</span> <span class="o">{</span>
    
  <span class="nd">@Autowired</span>
  <span class="kd">private</span> <span class="nc">ApplicationContext</span> <span class="n">ac</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">logic</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">PrototypeBean</span> <span class="n">prototypeBean</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">PrototypeBean</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>이렇게 의존관계를 외부에서 주입 받는게 아니라, 직접 필요한 의존관계를 찾는 것을 의존관계 조회(Dependency Lookup)라고 한다</li>
  <li>그런데 이렇게 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워진다</li>
  <li><code class="language-plaintext highlighter-rouge">ObjectProvider</code>는 딱 의존관계 조회 정도의 기능만 제공해준다
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">class</span> <span class="nc">ClientBean</span> <span class="o">{</span>

  <span class="nd">@Autowired</span>
  <span class="kd">private</span> <span class="nc">ObjectProvider</span><span class="o">&lt;</span><span class="nc">PrototypeBean</span><span class="o">&gt;</span> <span class="n">prototypeBeanProvider</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">logic</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">PrototypeBean</span> <span class="n">prototypeBean</span> <span class="o">=</span> <span class="n">prototypeBeanProvider</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="request-스코프">request 스코프</h2>

<ul>
  <li>웹 스코프의 일종</li>
  <li>웹 스코프는 웹 환경에서만 동작</li>
  <li><strong>HTTP 요청 1개</strong>가 들어오고 나갈때 까지 유지되는 스코프</li>
  <li>동시에 여러 HTTP 요청이 오면 정확히 어떤 요청이 남긴 로그인지 구분하기 어렵다 -&gt; 이럴 때 request 스코프 사용</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@Scope</span><span class="o">(</span><span class="n">value</span><span class="o">=</span><span class="err">'</span><span class="n">request</span><span class="err">'</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyLogger</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="nc">String</span> <span class="n">uuid</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">requestURL</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRequestURL</span><span class="o">(</span><span class="nc">String</span> <span class="n">requestURL</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">requestURL</span> <span class="o">=</span> <span class="n">requestURL</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">log</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="sc">'['</span> <span class="o">+</span> <span class="n">uuid</span> <span class="o">+</span> <span class="sc">']'</span> <span class="o">+</span> <span class="sc">'['</span> <span class="o">+</span> <span class="n">requestURL</span> <span class="o">+</span> <span class="sc">']'</span> <span class="o">+</span> <span class="n">message</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@PostConstruct</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">uuid</span> <span class="o">=</span> <span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="nd">@PreDestroy</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="sc">'['</span> <span class="o">+</span> <span class="n">uuid</span> <span class="o">+</span> <span class="err">'</span><span class="o">]</span> <span class="n">request</span> <span class="n">scope</span> <span class="n">bean</span> <span class="nl">close:</span><span class="err">'</span> <span class="o">+</span> <span class="k">this</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
:ET