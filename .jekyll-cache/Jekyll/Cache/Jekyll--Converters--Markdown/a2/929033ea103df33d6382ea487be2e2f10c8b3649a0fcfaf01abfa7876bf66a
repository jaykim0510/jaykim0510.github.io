I"÷W<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#heap" id="markdown-toc-heap">Heap</a>    <ul>
      <li><a href="#ìš°ì„ ìˆœìœ„-í" id="markdown-toc-ìš°ì„ ìˆœìœ„-í">ìš°ì„ ìˆœìœ„ í</a></li>
      <li><a href="#í™" id="markdown-toc-í™">í™</a></li>
    </ul>
  </li>
  <li><a href="#heap-ê´€ë ¨-ì—°ì‚°" id="markdown-toc-heap-ê´€ë ¨-ì—°ì‚°">Heap ê´€ë ¨ ì—°ì‚°</a>    <ul>
      <li><a href="#í™ì—-ì‚½ì…ì´-ë°œìƒí•œ-ê²½ìš°" id="markdown-toc-í™ì—-ì‚½ì…ì´-ë°œìƒí•œ-ê²½ìš°">í™ì— ì‚½ì…ì´ ë°œìƒí•œ ê²½ìš°</a></li>
      <li><a href="#í™ì—-ì‚­ì œê°€-ë°œìƒí•œ-ê²½ìš°" id="markdown-toc-í™ì—-ì‚­ì œê°€-ë°œìƒí•œ-ê²½ìš°">í™ì— ì‚­ì œê°€ ë°œìƒí•œ ê²½ìš°</a></li>
    </ul>
  </li>
  <li><a href="#heap-êµ¬í˜„" id="markdown-toc-heap-êµ¬í˜„">Heap êµ¬í˜„</a>    <ul>
      <li><a href="#íŒŒì´ì¬ì˜-heapq-ëª¨ë“ˆ" id="markdown-toc-íŒŒì´ì¬ì˜-heapq-ëª¨ë“ˆ">íŒŒì´ì¬ì˜ heapq ëª¨ë“ˆ</a></li>
      <li><a href="#íŒŒì´ì¬-ë¦¬ìŠ¤íŠ¸ë¥¼-ì´ìš©í•´-ì§ì ‘-êµ¬í˜„" id="markdown-toc-íŒŒì´ì¬-ë¦¬ìŠ¤íŠ¸ë¥¼-ì´ìš©í•´-ì§ì ‘-êµ¬í˜„">íŒŒì´ì¬ ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•´ ì§ì ‘ êµ¬í˜„</a></li>
    </ul>
  </li>
  <li><a href="#heap-í™œìš©" id="markdown-toc-heap-í™œìš©">Heap í™œìš©</a>    <ul>
      <li><a href="#í™-ì •ë ¬" id="markdown-toc-í™-ì •ë ¬">í™ ì •ë ¬</a></li>
      <li><a href="#top-k-ë¬¸ì œ" id="markdown-toc-top-k-ë¬¸ì œ">Top-K ë¬¸ì œ</a></li>
      <li><a href="#k-th-ìš”ì†Œ" id="markdown-toc-k-th-ìš”ì†Œ">K-th ìš”ì†Œ</a></li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="heap">Heap</h1>

<blockquote>
  <p>In many CS applications, we only need to access the largest or smallest element in the dataset. how do we efficiently access the largest or smallest element in the current dataset? The answer would be heap!</p>
</blockquote>

<h2 id="ìš°ì„ ìˆœìœ„-í">ìš°ì„ ìˆœìœ„ í</h2>

<ul>
  <li>í™ê³¼ ìš°ì„ ìˆœìœ„ íëŠ” ë‹¤ë¥¸ ì˜ë¯¸</li>
  <li>í™ì€ ë°ì´í„° êµ¬ì¡°(low-level), ìš°ì„ ìˆœìœ„ íëŠ” ì¶”ìƒ ìë£Œí˜•(high-level)</li>
  <li>í™ì€ ìš°ì„ ìˆœìœ„ íë¥¼ êµ¬í˜„í•˜ëŠ” í•œ ê°€ì§€ ë°©ë²•</li>
  <li>í™ ë§ê³ ë„ ë°°ì—´, ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ë¡œ ìš°ì„ ìˆœìœ„ íë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŒ(ë¬¼ë¡  ì‹œê°„ ë³µì¡ë„ ì°¨ì´ ìˆìŒ)</li>
</ul>

<h2 id="í™">í™</h2>

<ul>
  <li>í™ì€ <strong>ì™„ì „ ì´ì§„ íŠ¸ë¦¬</strong>ì˜ íŠ¹ë³„í•œ ì¼€ì´ìŠ¤
    <ul>
      <li>ì™„ì „ ì´ì§„ íŠ¸ë¦¬: ì´ì§„ íŠ¸ë¦¬ + ë¦¬í”„ ë…¸ë“œê°€ ì™¼ìª½ë¶€í„° ì±„ì›Œì§</li>
    </ul>
  </li>
  <li>ê° ë…¸ë“œë“¤ì€ ìì‹ ë…¸ë“œë³´ë‹¤ í¬ë‹¤ (ìµœëŒ€í™) (ìµœì†Œí™ì€ ë°˜ëŒ€)</li>
</ul>

<h1 id="heap-ê´€ë ¨-ì—°ì‚°">Heap ê´€ë ¨ ì—°ì‚°</h1>

<ul>
  <li>ì‚½ì… ì—°ì‚°: O(logN)</li>
  <li>ì‚­ì œ ì—°ì‚°: O(logN)</li>
  <li>ìµœëŒ€ê°’/ìµœì†Œê°’ ì–»ê¸°: O(1)</li>
  <li>elementê°€ í™ì—ì„œ ì‚½ì…/ì‚­ì œë˜ì–´ë„ ê³„ì† í™ ì„±ì§ˆì´ ìœ ì§€ë˜ì–´ì•¼í•¨
    <ul>
      <li>heapify ì—°ì‚°ìœ¼ë¡œ í™ ì„±ì§ˆì„ ìœ ì§€í•¨</li>
      <li>í•œ ë²ˆ ì‚½ì…/ì‚­ì œ ì—°ì‚°ì´ ì¼ì–´ë‚  ë•Œë§ˆë‹¤ heapify ì‹¤í–‰</li>
      <li>heapify: ë¶€ëª¨ ë…¸ë“œì™€ ìì‹ ë…¸ë“œì˜ ê°’ì„ ê³„ì† ë¹„êµí•˜ë©° ìŠ¤ì™‘</li>
    </ul>
  </li>
</ul>

<h2 id="í™ì—-ì‚½ì…ì´-ë°œìƒí•œ-ê²½ìš°">í™ì— ì‚½ì…ì´ ë°œìƒí•œ ê²½ìš°</h2>

<ul>
  <li>ì‚½ì…ëœ ë…¸ë“œëŠ” ë¦¬í”„ ë…¸ë“œì— ì¶”ê°€ -&gt; ì¶”ê°€ëœ ë¦¬í”„ ë…¸ë“œì—ì„œ ë¶€í„° heapify</li>
</ul>

<h2 id="í™ì—-ì‚­ì œê°€-ë°œìƒí•œ-ê²½ìš°">í™ì— ì‚­ì œê°€ ë°œìƒí•œ ê²½ìš°</h2>

<ul>
  <li>ì‚­ì œëŠ” í•­ìƒ ë£¨íŠ¸ ë…¸ë“œì—ì„œ ë°œìƒ -&gt; ë£¨íŠ¸ ë…¸ë“œì˜ ë¹ˆìë¦¬ëŠ” ë¦¬í”„ ë…¸ë“œê°€ ì±„ì›€ -&gt; ë£¨íŠ¸ ë…¸ë“œì—ì„œ ë¶€í„° heapify</li>
</ul>

<h1 id="heap-êµ¬í˜„">Heap êµ¬í˜„</h1>

<h2 id="íŒŒì´ì¬ì˜-heapq-ëª¨ë“ˆ">íŒŒì´ì¬ì˜ heapq ëª¨ë“ˆ</h2>

<ul>
  <li>í™ì„ íŒŒì´ì¬ì—ì„œ ì‚¬ìš©í•  ë•ŒëŠ” ê°„ë‹¨íˆ heapq ëª¨ë“ˆì„ ì´ìš©í•´ ì‚¬ìš© ê°€ëŠ¥
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">heapq</span>

<span class="n">heap_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Insert
</span><span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap_list</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">heap_list</span> <span class="o">==</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span>

<span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap_list</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">heap_list</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="c1"># Get
</span><span class="n">heap_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Delete
</span><span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap_list</span><span class="p">)</span>

<span class="c1"># Listë¥¼ í™ìœ¼ë¡œ ë§Œë“¤ ë–„
</span><span class="n">tmp_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">heapq</span><span class="p">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">tmp_list</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="íŒŒì´ì¬-ë¦¬ìŠ¤íŠ¸ë¥¼-ì´ìš©í•´-ì§ì ‘-êµ¬í˜„">íŒŒì´ì¬ ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•´ ì§ì ‘ êµ¬í˜„</h2>

<ul>
  <li>í™ì„ ì§ì ‘ êµ¬í˜„í•  ë•ŒëŠ” ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•¨
    <ul>
      <li>ì™„ì „ ì´ì§„ íŠ¸ë¦¬ì˜ ì„±ì§ˆì„ ê°€ì§€ë„ë¡ í•˜ê¸° ìœ„í•´ ë¶€ëª¨ ë…¸ë“œì™€ ìì‹ ë…¸ë“œì˜ ê´€ê³„ë¥¼ ì •ì˜í•´ì•¼í•¨
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root node: 1
parent node: n
left child node: 2*n
right child node: 2*n + 1
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>heapify
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># Implementing "Min Heap"
</span>  <span class="k">class</span> <span class="nc">MinHeap</span><span class="p">:</span>
      <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heapSize</span><span class="p">):</span>
          <span class="c1"># Create a complete binary tree using an array
</span>          <span class="c1"># Then use the binary tree to construct a Heap
</span>          <span class="bp">self</span><span class="p">.</span><span class="n">heapSize</span> <span class="o">=</span> <span class="n">heapSize</span>
          <span class="c1"># the number of elements is needed when instantiating an array
</span>          <span class="c1"># heapSize records the size of the array
</span>          <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">heapSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
          <span class="c1"># realSize records the number of elements in the Heap
</span>          <span class="bp">self</span><span class="p">.</span><span class="n">realSize</span> <span class="o">=</span> <span class="mi">0</span>

      <span class="c1"># Function to add an element
</span>      <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
          <span class="bp">self</span><span class="p">.</span><span class="n">realSize</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="c1"># If the number of elements in the Heap exceeds the preset heapSize
</span>          <span class="c1"># print "Added too many elements" and return
</span>          <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">realSize</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">heapSize</span><span class="p">:</span>
              <span class="k">print</span><span class="p">(</span><span class="s">"Added too many elements!"</span><span class="p">)</span>
              <span class="bp">self</span><span class="p">.</span><span class="n">realSize</span> <span class="o">-=</span> <span class="mi">1</span>
              <span class="k">return</span>
          <span class="c1"># Add the element into the array
</span>          <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">realSize</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span>
          <span class="c1"># Index of the newly added element
</span>          <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">realSize</span>
          <span class="c1"># Parent node of the newly added element
</span>          <span class="c1"># Note if we use an array to represent the complete binary tree
</span>          <span class="c1"># and store the root node at index 1
</span>          <span class="c1"># index of the parent node of any node is [index of the node / 2]
</span>          <span class="c1"># index of the left child node is [index of the node * 2]
</span>          <span class="c1"># index of the right child node is [index of the node * 2 + 1]
</span>          <span class="n">parent</span> <span class="o">=</span> <span class="n">index</span> <span class="o">//</span> <span class="mi">2</span>
          <span class="c1"># If the newly added element is smaller than its parent node,
</span>          <span class="c1"># its value will be exchanged with that of the parent node 
</span>          <span class="k">while</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
              <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">parent</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span>
              <span class="n">index</span> <span class="o">=</span> <span class="n">parent</span>
              <span class="n">parent</span> <span class="o">=</span> <span class="n">index</span> <span class="o">//</span> <span class="mi">2</span>
        
      <span class="c1"># Get the top element of the Heap
</span>      <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
      <span class="c1"># Delete the top element of the Heap
</span>      <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
          <span class="c1"># If the number of elements in the current Heap is 0,
</span>          <span class="c1"># print "Don't have any elements" and return a default value
</span>          <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">realSize</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
              <span class="k">print</span><span class="p">(</span><span class="s">"Don't have any element!"</span><span class="p">)</span>
              <span class="k">return</span> <span class="n">sys</span><span class="p">.</span><span class="n">maxsize</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="c1"># When there are still elements in the Heap
</span>              <span class="c1"># self.realSize &gt;= 1
</span>              <span class="n">removeElement</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
              <span class="c1"># Put the last element in the Heap to the top of Heap
</span>              <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">realSize</span><span class="p">]</span>
              <span class="bp">self</span><span class="p">.</span><span class="n">realSize</span> <span class="o">-=</span> <span class="mi">1</span>
              <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span>
              <span class="c1"># When the deleted element is not a leaf node
</span>              <span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">realSize</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
                  <span class="c1"># the left child of the deleted element
</span>                  <span class="n">left</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="mi">2</span>
                  <span class="c1"># the right child of the deleted element
</span>                  <span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                  <span class="c1"># If the deleted element is larger than the left or right child
</span>                  <span class="c1"># its value needs to be exchanged with the smaller value
</span>                  <span class="c1"># of the left and right child
</span>                  <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">right</span><span class="p">]):</span>
                      <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
                          <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
                          <span class="n">index</span> <span class="o">=</span> <span class="n">left</span>
                      <span class="k">else</span><span class="p">:</span>
                          <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
                          <span class="n">index</span> <span class="o">=</span> <span class="n">right</span>
                  <span class="k">else</span><span class="p">:</span>
                      <span class="k">break</span>
              <span class="k">return</span> <span class="n">removeElement</span>
        
      <span class="c1"># return the number of elements in the Heap
</span>      <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">realSize</span>
        
      <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
          <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">minheap</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">realSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            

  <span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
          <span class="c1"># Test cases
</span>          <span class="n">minHeap</span> <span class="o">=</span> <span class="n">MinHeap</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
          <span class="n">minHeap</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
          <span class="n">minHeap</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
          <span class="n">minHeap</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
          <span class="c1"># [1,3,2]
</span>          <span class="k">print</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span>
          <span class="c1"># 1
</span>          <span class="k">print</span><span class="p">(</span><span class="n">minHeap</span><span class="p">.</span><span class="n">peek</span><span class="p">())</span>
          <span class="c1"># 1
</span>          <span class="k">print</span><span class="p">(</span><span class="n">minHeap</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>
          <span class="c1"># 2
</span>          <span class="k">print</span><span class="p">(</span><span class="n">minHeap</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>
          <span class="c1"># 3
</span>          <span class="k">print</span><span class="p">(</span><span class="n">minHeap</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>
          <span class="n">minHeap</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
          <span class="n">minHeap</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
          <span class="c1"># [4,5]
</span>          <span class="k">print</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="heap-í™œìš©">Heap í™œìš©</h1>

<h2 id="í™-ì •ë ¬">í™ ì •ë ¬</h2>

<h2 id="top-k-ë¬¸ì œ">Top-K ë¬¸ì œ</h2>

<h2 id="k-th-ìš”ì†Œ">K-th ìš”ì†Œ</h2>
:ET