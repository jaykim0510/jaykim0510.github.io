I"ƒ<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#ë©”ëª¨ë¦¬-ê´€ë¦¬" id="markdown-toc-ë©”ëª¨ë¦¬-ê´€ë¦¬">ë©”ëª¨ë¦¬ ê´€ë¦¬</a>    <ul>
      <li><a href="#python-memory-manager" id="markdown-toc-python-memory-manager">Python Memory Manager</a></li>
      <li><a href="#garbage-collection" id="markdown-toc-garbage-collection">Garbage Collection</a></li>
    </ul>
  </li>
  <li><a href="#ë©”ëª¨ë¦¬-í• ë‹¹" id="markdown-toc-ë©”ëª¨ë¦¬-í• ë‹¹">ë©”ëª¨ë¦¬ í• ë‹¹</a>    <ul>
      <li><a href="#stack-ì˜ì—­" id="markdown-toc-stack-ì˜ì—­">Stack ì˜ì—­</a></li>
      <li><a href="#heap-ì˜ì—­" id="markdown-toc-heap-ì˜ì—­">Heap ì˜ì—­</a></li>
    </ul>
  </li>
  <li><a href="#ì°¸ê³ " id="markdown-toc-ì°¸ê³ ">ì°¸ê³ </a></li>
</ul>

<hr />
<p>ìš”ì¦˜ì—ëŠ” ì»´í“¨í„°, ìŠ¤ë§ˆíŠ¸í°ì„ ì‚¬ìš©í•  ë•Œ í•œê°€ì§€ í”„ë¡œê·¸ë¨/ì–´í”Œë¦¬ì¼€ì´ì…˜ë§Œ ì‹¤í–‰í•˜ëŠ” ì‚¬ëŒì€ ì—†ì„ ê²ƒì…ë‹ˆë‹¤. ê·¸ë ‡ê¸° ë•Œë¬¸ì— ë‚´ê°€ ë§Œë“  í”„ë¡œê·¸ë¨/ì–´í”Œë¦¬ì¼€ì´ì…˜ì´ ë©”ëª¨ë¦¬ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©í•˜ë„ë¡ ê°œë°œí•˜ëŠ” ê²ƒì€ ì¤‘ìš”í•©ë‹ˆë‹¤.</p>

<p>ë©”ëª¨ë¦¬ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” í”„ë¡œê·¸ë¨/ì–´í”Œë¦¬ì¼€ì´ì…˜ì„ ë§Œë“¤ê¸° ìœ„í•´ì„œëŠ” ë©”ëª¨ë¦¬ í• ë‹¹ì— ëŒ€í•´ ì´í•´í•´ì•¼í•©ë‹ˆë‹¤. ë©”ëª¨ë¦¬ í• ë‹¹ì€ ë‚´ê°€ ì‚¬ìš©í•˜ëŠ” í”„ë¡œê·¸ë˜ë° ì–¸ì–´, ìš´ì˜ì²´ì œ, ì»´í“¨í„° ì•„í‚¤í…ì²˜ì— ë”°ë¼ ì¡°ê¸ˆì”© ë‹¤ë¥´ì§€ë§Œ ì „ì²´ì ì¸ ê³¼ì •ì€ ë¹„ìŠ·í•©ë‹ˆë‹¤.</p>

<h1 id="ë©”ëª¨ë¦¬-ê´€ë¦¬">ë©”ëª¨ë¦¬ ê´€ë¦¬</h1>

<p><img src="/images/python_1.png" alt="" /></p>

<p>Memory management in Python involves a private heap containing all Python objects and data structures. The management of this private heap is ensured internally by the Python memory manager. The Python memory manager has different components which deal with various dynamic storage management aspects, like sharing, segmentation, preallocation or caching.</p>

<p>At the lowest level, a raw memory allocator ensures that there is enough room in the private heap for storing all Python-related data by interacting with the memory manager of the operating system. On top of the raw memory allocator, several object-specific allocators operate on the same heap and implement distinct memory management policies adapted to the peculiarities of every object type. For example, integer objects are managed differently within the heap than strings, tuples or dictionaries because integers imply different storage requirements and speed/space tradeoffs. The Python memory manager thus delegates some of the work to the object-specific allocators, but ensures that the latter operate within the bounds of the private heap.</p>

<p>It is important to understand that the management of the Python heap is performed by the interpreter itself and that the user has no control over it, even if they regularly manipulate object pointers to memory blocks inside that heap. The allocation of heap space for Python objects and other internal buffers is performed on demand by the Python memory manager through the Python/C API functions listed in this document.</p>

<p>To avoid memory corruption, extension writers should never try to operate on Python objects with the functions exported by the C library: malloc(), calloc(), realloc() and free(). This will result in mixed calls between the C allocator and the Python memory manager with fatal consequences, because they implement different algorithms and operate on different heaps. However, one may safely allocate and release memory blocks with the C library allocator for individual purposes, as shown in the following example:</p>

<p>In this example, the memory request for the I/O buffer is handled by the C library allocator. The Python memory manager is involved only in the allocation of the bytes object returned as a result.</p>

<p>In most situations, however, it is recommended to allocate memory from the Python heap specifically because the latter is under control of the Python memory manager. For example, this is required when the interpreter is extended with new object types written in C. Another reason for using the Python heap is the desire to inform the Python memory manager about the memory needs of the extension module. Even when the requested memory is used exclusively for internal, highly-specific purposes, delegating all memory requests to the Python memory manager causes the interpreter to have a more accurate image of its memory footprint as a whole. Consequently, under certain circumstances, the Python memory manager may or may not trigger appropriate actions, like garbage collection, memory compaction or other preventive procedures. Note that by using the C library allocator as shown in the previous example, the allocated memory for the I/O buffer escapes completely the Python memory manager.</p>

<h2 id="python-memory-manager">Python Memory Manager</h2>

<h2 id="garbage-collection">Garbage Collection</h2>

<h1 id="ë©”ëª¨ë¦¬-í• ë‹¹">ë©”ëª¨ë¦¬ í• ë‹¹</h1>

<h2 id="stack-ì˜ì—­">Stack ì˜ì—­</h2>

<h2 id="heap-ì˜ì—­">Heap ì˜ì—­</h2>

<h1 id="ì°¸ê³ ">ì°¸ê³ </h1>
<ul>
  <li><a href="https://medium.datadriveninvestor.com/how-does-memory-allocation-work-in-python-and-other-languages-d2d8a9398543" target="_blank">How does Memory Allocation work in Python (and other languages)?</a></li>
  <li><a href="https://docs.python.org/3/c-api/memory.html#tracemalloc-c-api" target="_blank">Python ê³µì‹ë¬¸ì„œ: Memory Management</a></li>
  <li><a href="https://www.programmerinterview.com/data-structures/difference-between-stack-and-heap/" target="_blank">Whatâ€™s the difference between a stack and a heap?</a></li>
  <li><a href="https://realpython.com/python-memory-management/" target="_blank">RealPython: Memory Management in Python</a></li>
  <li><a href="https://hkim-data.tistory.com/182" target="_blank">pythonì˜ ë©”ëª¨ë¦¬ í• ë‹¹ê³¼ ê´€ë¦¬ (Stack &amp; Heap Memory)</a></li>
  <li><a href="https://armontad-1202.tistory.com/entry/íŒŒì´ì¬ì˜-ë©”ëª¨ë¦¬-ì˜ì—­" target="_blank">íŒŒì´ì¬ ë©”ëª¨ë¦¬ ì˜ì—­</a></li>
</ul>

:ET