I"ï&<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#ë©”ëª¨ë¦¬-ê´€ë¦¬" id="markdown-toc-ë©”ëª¨ë¦¬-ê´€ë¦¬">ë©”ëª¨ë¦¬ ê´€ë¦¬</a>    <ul>
      <li><a href="#python-memory-manager" id="markdown-toc-python-memory-manager">Python Memory Manager</a></li>
      <li><a href="#garbage-collection" id="markdown-toc-garbage-collection">Garbage Collection</a></li>
    </ul>
  </li>
  <li><a href="#ë©”ëª¨ë¦¬-í• ë‹¹" id="markdown-toc-ë©”ëª¨ë¦¬-í• ë‹¹">ë©”ëª¨ë¦¬ í• ë‹¹</a>    <ul>
      <li><a href="#stack-ì˜ì—­" id="markdown-toc-stack-ì˜ì—­">Stack ì˜ì—­</a></li>
      <li><a href="#heap-ì˜ì—­" id="markdown-toc-heap-ì˜ì—­">Heap ì˜ì—­</a></li>
    </ul>
  </li>
  <li><a href="#ì°¸ê³ " id="markdown-toc-ì°¸ê³ ">ì°¸ê³ </a></li>
</ul>

<hr />
<p>ìš”ì¦˜ì—ëŠ” ì»´í“¨í„°, ìŠ¤ë§ˆíŠ¸í°ì„ ì‚¬ìš©í•  ë•Œ í•œê°€ì§€ í”„ë¡œê·¸ë¨/ì–´í”Œë¦¬ì¼€ì´ì…˜ë§Œ ì‹¤í–‰í•˜ëŠ” ì‚¬ëŒì€ ì—†ì„ ê²ƒì…ë‹ˆë‹¤. ê·¸ë ‡ê¸° ë•Œë¬¸ì— ë‚´ê°€ ë§Œë“  í”„ë¡œê·¸ë¨/ì–´í”Œë¦¬ì¼€ì´ì…˜ì´ ë©”ëª¨ë¦¬ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©í•˜ë„ë¡ ê°œë°œí•˜ëŠ” ê²ƒì€ ì¤‘ìš”í•©ë‹ˆë‹¤.</p>

<p>ë©”ëª¨ë¦¬ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” í”„ë¡œê·¸ë¨/ì–´í”Œë¦¬ì¼€ì´ì…˜ì„ ë§Œë“¤ê¸° ìœ„í•´ì„œëŠ” ë©”ëª¨ë¦¬ í• ë‹¹ì— ëŒ€í•´ ì´í•´í•´ì•¼í•©ë‹ˆë‹¤. ë©”ëª¨ë¦¬ í• ë‹¹ì€ ë‚´ê°€ ì‚¬ìš©í•˜ëŠ” í”„ë¡œê·¸ë˜ë° ì–¸ì–´, ìš´ì˜ì²´ì œ, ì»´í“¨í„° ì•„í‚¤í…ì²˜ì— ë”°ë¼ ì¡°ê¸ˆì”© ë‹¤ë¥´ì§€ë§Œ ì „ì²´ì ì¸ ê³¼ì •ì€ ë¹„ìŠ·í•©ë‹ˆë‹¤.</p>

<p>íŒŒì´ì¬ì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬ëŠ” ëŒ€ë¶€ë¶„ Python Memory Managerì— ì˜í•´ ìˆ˜í–‰ë˜ì§€ë§Œ, ìµœìƒì˜ ì½”ë”© ë°©ë²•ê³¼ Python Memory Manager ì‘ë™ ë°©ì‹ì— ëŒ€í•œ ì´í•´ëŠ” ë³´ë‹¤ íš¨ìœ¨ì ì´ê³  ìœ ì§€ ê´€ë¦¬ ê°€ëŠ¥í•œ ì½”ë“œë¥¼ ì‘ì„±í•˜ë„ë¡ ë„ì™€ì¤ë‹ˆë‹¤.</p>

<h1 id="ë©”ëª¨ë¦¬-ê´€ë¦¬">ë©”ëª¨ë¦¬ ê´€ë¦¬</h1>
<p>You can think of memory management on two levels. At one level, we have the operating system, which manages how much memory each running application or process can use.</p>

<p>This is one of the most important jobs for the OSâ€”making sure that the memory assigned to your running web browser is not used, say, by your email client. At another level, we have memory management within Python itself.</p>

<p>Python makes sure that any programs you have running run safely and efficiently. It makes sure that memory assigned to one variable is not simultaneously used by another. Exactly how this happens is the focus of this course.</p>

<p><img src="/images/python_1.png" alt="" /></p>

<h2 id="python-memory-manager">Python Memory Manager</h2>

<p>Memory management in Python involves a private heap containing all Python objects and data structures. The management of this private heap is ensured internally by the Python memory manager. The Python memory manager has different components which deal with various dynamic storage management aspects, like sharing, segmentation, preallocation or caching.</p>

<p>At the lowest level, a raw memory allocator ensures that there is enough room in the private heap for storing all Python-related data by interacting with the memory manager of the operating system. On top of the raw memory allocator, several object-specific allocators operate on the same heap and implement distinct memory management policies adapted to the peculiarities of every object type. For example, integer objects are managed differently within the heap than strings, tuples or dictionaries because integers imply different storage requirements and speed/space tradeoffs. The Python memory manager thus delegates some of the work to the object-specific allocators, but ensures that the latter operate within the bounds of the private heap.</p>

<p>It is important to understand that the management of the Python heap is performed by the interpreter itself and that the user has no control over it, even if they regularly manipulate object pointers to memory blocks inside that heap. The allocation of heap space for Python objects and other internal buffers is performed on demand by the Python memory manager through the Python/C API functions listed in this document.</p>

<p>To avoid memory corruption, extension writers should never try to operate on Python objects with the functions exported by the C library: malloc(), calloc(), realloc() and free(). This will result in mixed calls between the C allocator and the Python memory manager with fatal consequences, because they implement different algorithms and operate on different heaps. However, one may safely allocate and release memory blocks with the C library allocator for individual purposes, as shown in the following example:</p>

<p>In this example, the memory request for the I/O buffer is handled by the C library allocator. The Python memory manager is involved only in the allocation of the bytes object returned as a result.</p>

<p>In most situations, however, it is recommended to allocate memory from the Python heap specifically because the latter is under control of the Python memory manager. For example, this is required when the interpreter is extended with new object types written in C. Another reason for using the Python heap is the desire to inform the Python memory manager about the memory needs of the extension module. Even when the requested memory is used exclusively for internal, highly-specific purposes, delegating all memory requests to the Python memory manager causes the interpreter to have a more accurate image of its memory footprint as a whole. Consequently, under certain circumstances, the Python memory manager may or may not trigger appropriate actions, like garbage collection, memory compaction or other preventive procedures. Note that by using the C library allocator as shown in the previous example, the allocated memory for the I/O buffer escapes completely the Python memory manager.</p>

<h2 id="garbage-collection">Garbage Collection</h2>

<p>Garbage collection is when the interpreter frees memory for your programs for you when it is not being used. Python is able to do this because the developers of python implemented a garbage collector for us on the backend. This Python garbage collector uses a technique known as â€˜reference countingâ€™ in which objects are deallocated or â€œfreedâ€ when there is no longer a reference to it in the program.</p>

<h1 id="ë©”ëª¨ë¦¬-í• ë‹¹">ë©”ëª¨ë¦¬ í• ë‹¹</h1>

<p>Memory allocation is the process by which a program is assigned or allocated to a particular empty block of space in computer memory. In Python, all of this is done on the backend by the Python Memory Manager. Since Python is implemented using C programming language, this process is handled the C-way â€” where the developer allocates and frees memory (by creating a garbage collector for Python) so users do not have to do manual garbage collection. Since the C-backend handles this, Python users do not need to worry about it.</p>

<h2 id="stack-ì˜ì—­">Stack ì˜ì—­</h2>

<p>Stack allocation stores static memory, which is the memory that is only needed inside a particular function or method call. When a function is called, it is added onto the programâ€™s call stack. Any local memory assignments â€” such as variable initializations â€” inside the particular functions are stored temporarily on the function call stack, where it is deleted once the function returns, and the call stack moves on to the next task. This allocation onto a contiguous block of memory is handled by the compiler using predefined routines, and developers do not need to worry about it.</p>

<h2 id="heap-ì˜ì—­">Heap ì˜ì—­</h2>
<p>Heap allocation stores dynamic memory, which is the memory that is used in the program, at global scope. These variables are needed outside of specific method or function calls or are shared within multiple functions globally. Unlike stack allocation, heap allocation is not related to its namely counterpart: the heap data structure. It is simply a large space of memory available for allocation and freeing at somewhat random addresses, found based on the space needed by the object being stored.</p>

<p>This allocation is manually done by C developers and must be implemented carefully to prevent memory leaks. All memory allocated on the heap, such as pointers to nodes in a linked list or other objects, must be freed at the end of the program, or whenever it is no longer needed. For implementations such as linked lists and tree data structures, freeing memory must be handled with extra care when a node is deleted, and access to that address in memory â€” often with the use of pointers â€” is lost.</p>

<p>Below is an example of how a programâ€™s function variables would be allocated onto a stack and a heap. Notice how local variables are stored on the stack, however, the form object is stored on a heap. This is because the inbuilt operation â€˜newâ€™ allocates dynamic memory on the heap.</p>

<h1 id="ì°¸ê³ ">ì°¸ê³ </h1>
<ul>
  <li><a href="https://medium.datadriveninvestor.com/how-does-memory-allocation-work-in-python-and-other-languages-d2d8a9398543" target="_blank">How does Memory Allocation work in Python (and other languages)?</a></li>
  <li><a href="https://docs.python.org/3/c-api/memory.html#tracemalloc-c-api" target="_blank">Python ê³µì‹ë¬¸ì„œ: Memory Management</a></li>
  <li><a href="https://www.programmerinterview.com/data-structures/difference-between-stack-and-heap/" target="_blank">Whatâ€™s the difference between a stack and a heap?</a></li>
  <li><a href="https://realpython.com/python-memory-management/" target="_blank">RealPython: Memory Management in Python</a></li>
  <li><a href="https://velog.io/@muchogusto/íŒŒì´ì¬-ëŸ°íƒ€ì„ê³¼-ë©”ëª¨ë¦¬-ê´€ë¦¬" target="_blank">muchogusto.log: íŒŒì´ì¬ ëŸ°íƒ€ì„ê³¼ ë©”ëª¨ë¦¬ ê´€ë¦¬</a></li>
  <li><a href="https://hkim-data.tistory.com/182" target="_blank">pythonì˜ ë©”ëª¨ë¦¬ í• ë‹¹ê³¼ ê´€ë¦¬ (Stack &amp; Heap Memory)</a></li>
  <li><a href="https://armontad-1202.tistory.com/entry/íŒŒì´ì¬ì˜-ë©”ëª¨ë¦¬-ì˜ì—­" target="_blank">íŒŒì´ì¬ ë©”ëª¨ë¦¬ ì˜ì—­</a></li>
</ul>

:ET