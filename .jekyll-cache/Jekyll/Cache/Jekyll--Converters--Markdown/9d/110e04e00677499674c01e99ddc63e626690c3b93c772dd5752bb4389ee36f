I"?<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#데이터-타입" id="markdown-toc-데이터-타입">데이터 타입</a>    <ul>
      <li><a href="#숫자-타입" id="markdown-toc-숫자-타입">숫자 타입</a></li>
      <li><a href="#문자열-타입" id="markdown-toc-문자열-타입">문자열 타입</a></li>
      <li><a href="#템플릿-리터럴" id="markdown-toc-템플릿-리터럴">템플릿 리터럴</a></li>
      <li><a href="#undefined-타입" id="markdown-toc-undefined-타입">undefined 타입</a></li>
      <li><a href="#심벌-타입" id="markdown-toc-심벌-타입">심벌 타입</a></li>
    </ul>
  </li>
  <li><a href="#연산자" id="markdown-toc-연산자">연산자</a>    <ul>
      <li><a href="#산술-연산자" id="markdown-toc-산술-연산자">산술 연산자</a></li>
      <li><a href="#비교-연산자" id="markdown-toc-비교-연산자">비교 연산자</a></li>
      <li><a href="#삼항-조건-연산자" id="markdown-toc-삼항-조건-연산자">삼항 조건 연산자</a></li>
    </ul>
  </li>
  <li><a href="#논리-연산자" id="markdown-toc-논리-연산자">논리 연산자</a></li>
</ul>

<hr />

<h1 id="데이터-타입">데이터 타입</h1>

<p>ES6 기준으로 자바스크립트에서는 7개의 데이터 타입을 제공한다.</p>

<table>
  <tbody>
    <tr>
      <td><strong>구분</strong></td>
      <td><strong>데이터 타입</strong></td>
      <td><strong>설명</strong></td>
    </tr>
    <tr>
      <td>원시 타입</td>
      <td>숫자</td>
      <td>숫자, 정수와 실수의 구분 없음</td>
    </tr>
    <tr>
      <td> </td>
      <td>문자열</td>
      <td>문자열</td>
    </tr>
    <tr>
      <td> </td>
      <td>불리언</td>
      <td>논리적 참과 거짓</td>
    </tr>
    <tr>
      <td> </td>
      <td>undefined</td>
      <td>var 키워드로 선언된 변수에 암묵적으로 할당되는 값</td>
    </tr>
    <tr>
      <td> </td>
      <td>null</td>
      <td>값이 없다는 것을 의도적으로 명시할 때 사용되는 값</td>
    </tr>
    <tr>
      <td> </td>
      <td>symbol</td>
      <td>ES6에서 추가된 타입</td>
    </tr>
    <tr>
      <td>객체 타입</td>
      <td> </td>
      <td>객체, 함수, 배열 등</td>
    </tr>
  </tbody>
</table>

<h2 id="숫자-타입">숫자 타입</h2>

<p>자바스크립트는 독특하게 하나의 숫자 타입만 존재한다.</p>

<p>ECMAScript 사양에 따르면 숫자 타입의 값은 배정밀도(double precision) 64비트 부동소수점 형식을 따른다.</p>

<p>정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모둗 10진수로 해석된다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">binary</span> <span class="o">=</span> <span class="mb">0b01000001</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">octal</span> <span class="o">=</span> <span class="mo">0o101</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">hex</span> <span class="o">=</span> <span class="mh">0x41</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">binary</span><span class="p">);</span> <span class="c1">// 65</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">octal</span><span class="p">);</span> <span class="c1">// 65</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hex</span><span class="p">);</span> <span class="c1">// 65</span>
</code></pre></div></div>

<h2 id="문자열-타입">문자열 타입</h2>

<p>문자열 타입은 텍스트 데이터를 나타내는 데 사용한다. 문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 전 세계 대부분의 문자를 표현할 수 있다. 자바스크립트의 문자열은 원시타입이며, 변경 불가능한 값이다.</p>

<p>문자열은 작은따옴표(‘’), 큰따옴표(“”) 또는 백틱(``)으로 텍스트를 감싼다. 가장 일반적인 표기법은 작은따옴표를 사용하는 것이다. 따옴표로 감싸는 이유는 키워드나 식별자 같은 토큰과 구분하기 위해서다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">string</span><span class="p">;</span>
<span class="nx">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">apple</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">string</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">apple</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">string</span> <span class="o">=</span> <span class="s2">`apple`</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="템플릿-리터럴">템플릿 리터럴</h2>

<p>ES6부터 템플릿 리터럴이라고 하는 새로운 문자열 표기법이 도입되었다. 템플릿 리터럴은 멀티라인 문자열, 표현식 삽입 등 편리한 문자열 처리 기능을 제공한다. 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리된다.</p>

<p>템플릿 리터럴은 백틱(``)을 사용해 표현한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 멀티라인 문자열</span>
<span class="kd">var</span> <span class="nx">html_code</span> <span class="o">=</span> <span class="s2">`&lt;ul&gt;
    &lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;`</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 표현식 삽입</span>

<span class="kd">var</span> <span class="nx">first</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Ung-mo</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">last</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Lee</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">My name is </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">first</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">last</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">.</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// ES5</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`My name is </span><span class="p">${</span><span class="nx">first</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">last</span><span class="p">}</span><span class="s2">.`</span><span class="p">);</span> <span class="c1">// ES6</span>
</code></pre></div></div>

<h2 id="undefined-타입">undefined 타입</h2>

<p>var 키워드로 선언한 변수는 암묵적으로 <code class="language-plaintext highlighter-rouge">undefine</code>d로 초기화된다. 다시 말해, 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 자바스크립트 엔진이 <code class="language-plaintext highlighter-rouge">undeefined</code>로 초기화한다. 변수를 참조했을 때 <code class="language-plaintext highlighter-rouge">undefined</code>가 반환된다면 참조한 변수가 선언 이후 값이 할당된 적이 없는 변수라는 것을 간파할 수 있다.</p>

<p>만약 <code class="language-plaintext highlighter-rouge">undefined</code>를 개발자가 의도적으로 변수에 할당한다면 <code class="language-plaintext highlighter-rouge">undefined</code>의 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 권장하지 않는다.</p>

<p>변수에 값이 없다는 것을 명시하고 싶을 때는 <code class="language-plaintext highlighter-rouge">null</code>을 할당하는 것이 좋다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">foo</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// undefined</span>
</code></pre></div></div>

<h2 id="심벌-타입">심벌 타입</h2>

<p>심벌은 ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다.</p>

<p>다른 원시 값은 리터럴을 통해 생성하지만 심벌은 <code class="language-plaintext highlighter-rouge">Symbol</code> 함수를 호출해 생성한다. 이때 생성된 심벌 값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">key</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 심벌 생성</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// 객체 생성</span>

<span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">value</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// 유일한 값을 가지는 심벌을 프로퍼티 키로 사용한다</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span> <span class="c1">// value</span>
</code></pre></div></div>

<h1 id="연산자">연산자</h1>

<h2 id="산술-연산자">산술 연산자</h2>

<table>
  <tbody>
    <tr>
      <td>단항 산술 연산자</td>
      <td>++, –, +, -</td>
    </tr>
    <tr>
      <td>이항 산술 연산자</td>
      <td>+, -, *, /, %</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">++</code>, <code class="language-plaintext highlighter-rouge">--</code> 연산자는 위치에 의미가 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">result</span><span class="p">;</span>

<span class="nx">result</span> <span class="o">=</span> <span class="nx">x</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 선할당 후증가</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span> <span class="c1">// 5 6</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">result</span><span class="p">;</span>

<span class="nx">result</span> <span class="o">=</span> <span class="o">++</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// 선증가 후할당</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span> <span class="c1">// 6 6</span>
</code></pre></div></div>

<h2 id="비교-연산자">비교 연산자</h2>

<table>
  <tbody>
    <tr>
      <td><strong>비교 연산자</strong></td>
      <td><strong>의미</strong></td>
      <td><strong>설명</strong></td>
    </tr>
    <tr>
      <td>==</td>
      <td>동등 비교</td>
      <td>x와 y의 값이 같음</td>
    </tr>
    <tr>
      <td>===</td>
      <td>일치 비교</td>
      <td>x와 y의 값과 타입이 같음</td>
    </tr>
    <tr>
      <td>!=</td>
      <td>부동등 비교</td>
      <td>x와 y의 값이 다름</td>
    </tr>
    <tr>
      <td>!==</td>
      <td>불일치 비교</td>
      <td>x와 y의 값과 타입이 다름</td>
    </tr>
  </tbody>
</table>

<p>동등 비교 연산자(==)는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적으로 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">5</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// true</span>
<span class="mi">5</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">5</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// false</span>
</code></pre></div></div>

<p>그래서 동등 비교 연산자는 예측하기 어려운 결과를 만들어낸다. 따라서 동등 비교 연산자보다는 일치 비교 연산자를 권장한다.</p>

<h2 id="삼항-조건-연산자">삼항 조건 연산자</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">조건식</span> <span class="p">?</span> <span class="nx">조건식이</span> <span class="nx">true일</span> <span class="nx">때</span> <span class="nx">반환할</span> <span class="nx">값</span> <span class="p">:</span> <span class="nx">false일</span> <span class="nx">때</span> <span class="nx">반환할</span> <span class="nx">값</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">홀수</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">짝수</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span> <span class="c1">// 짝수</span>
</code></pre></div></div>

<p>삼항 조건 연산자 표현식은 값처럼 사용할 수 있다.</p>

<h1 id="논리-연산자">논리 연산자</h1>

<table>
  <tbody>
    <tr>
      <td><strong>논리 연산자</strong></td>
      <td><strong>의미</strong></td>
    </tr>
    <tr>
      <td>||</td>
      <td>논리합(OR)</td>
    </tr>
    <tr>
      <td>&amp;&amp;</td>
      <td>논리곱(AND)</td>
    </tr>
    <tr>
      <td>!</td>
      <td>부정(NOT)</td>
    </tr>
  </tbody>
</table>

:ET