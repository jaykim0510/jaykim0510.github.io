I"áb<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#ipc" id="markdown-toc-ipc">IPC</a>    <ul>
      <li><a href="#use-cases" id="markdown-toc-use-cases">Use Cases</a></li>
      <li><a href="#ê³µìœ -ë©”ëª¨ë¦¬" id="markdown-toc-ê³µìœ -ë©”ëª¨ë¦¬">ê³µìœ  ë©”ëª¨ë¦¬</a></li>
      <li><a href="#íŒŒì¼" id="markdown-toc-íŒŒì¼">íŒŒì¼</a></li>
      <li><a href="#íŒŒì´í”„" id="markdown-toc-íŒŒì´í”„">íŒŒì´í”„</a></li>
      <li><a href="#ì†Œì¼“" id="markdown-toc-ì†Œì¼“">ì†Œì¼“</a></li>
      <li><a href="#ë©”ì„¸ì§€-í" id="markdown-toc-ë©”ì„¸ì§€-í">ë©”ì„¸ì§€ í</a></li>
    </ul>
  </li>
  <li><a href="#rpc" id="markdown-toc-rpc">RPC</a>    <ul>
      <li><a href="#when-the-client-calls-the-server-the-rpc-system-must-take-care-of" id="markdown-toc-when-the-client-calls-the-server-the-rpc-system-must-take-care-of">When the client calls the server, the RPC system must take care of:</a></li>
      <li><a href="#the-following-steps-take-place-during-a-rpc" id="markdown-toc-the-following-steps-take-place-during-a-rpc">The following steps take place during a RPC</a></li>
      <li><a href="#ì¥ì " id="markdown-toc-ì¥ì ">ì¥ì </a></li>
      <li><a href="#ë‹¨ì " id="markdown-toc-ë‹¨ì ">ë‹¨ì </a></li>
      <li><a href="#grpc" id="markdown-toc-grpc">gRPC</a></li>
      <li><a href="#grpc-ì´ì " id="markdown-toc-grpc-ì´ì ">gRPC ì´ì </a></li>
    </ul>
  </li>
  <li><a href="#ì°¸ê³ " id="markdown-toc-ì°¸ê³ ">ì°¸ê³ </a></li>
</ul>
<hr />

<h1 id="ipc">IPC</h1>

<ul>
  <li>Inter-Process Communicationì˜ ì¤„ì„ë§ -&gt; í”„ë¡œì„¸ìŠ¤ê°„ í†µì‹ ì„ ì˜ë¯¸</li>
  <li>í”„ë¡œì„¸ìŠ¤ë¼ë¦¬ ì„œë¡œ ë°ì´í„°ë¥¼ ì£¼ê³  ë°›ëŠ” ë°©ë²•ë“¤ì„ ì¼ì»«ì–´ IPCë¼ê³  í•¨</li>
  <li>ìŠ¤ë ˆë“œë¼ë¦¬ëŠ” ë©”ëª¨ë¦¬ë¥¼ ê³µìœ í•œë‹¤ -&gt; ê³µìœ í•˜ëŠ” ê³µê°„ì´ ìˆê¸° ë•Œë¬¸ì— ë°ì´í„°ë¥¼ ì£¼ê³  ë°›ëŠ”ë° í¬ê²Œ ì–´ë ¤ì›€ì´ ì—†ë‹¤</li>
  <li>í”„ë¡œì„¸ìŠ¤ëŠ” ë³„ë„ì˜ ë©”ëª¨ë¦¬ì— ìƒì„±ëœë‹¤ -&gt; ê³µìœ í•˜ëŠ” ê³µê°„ì´ ì—†ë‹¤ -&gt; ì´ë¥¼ ìœ„í•´ ìš´ì˜ì²´ì œ ì»¤ë„ì—ì„œ IPCë¥¼ ìœ„í•œ ì—¬ëŸ¬ ë„êµ¬ë¥¼ ì œê³µ</li>
  <li>ê³µìœ  ë©”ëª¨ë¦¬, íŒŒì¼, íŒŒì´í”„, ì†Œì¼“, ë©”ì„¸ì§€ í, RPC</li>
</ul>

<h2 id="use-cases">Use Cases</h2>
<p>There are several good reasons and common use cases for IPC:</p>

<ul>
  <li><strong>Sharing information/data</strong> â€“ Share data between processes to synchronize different applications</li>
  <li><strong>Computational Speedups</strong> â€“ Sending data off site for processing</li>
  <li><strong>Modularity</strong> â€“ Google Chrome separates each tab into a separate process to help avoid crashes, as well as security.</li>
  <li><strong>Development</strong> â€“ Often it is easier to have two teams build separate programs. By building them with IPC in mind you can essentially â€œpluginâ€ to any programs which need similar functionality without any recompiling</li>
  <li><strong>Security</strong> â€“ It is often useful to separate processes to ensure system security. Each process has itâ€™s own memory and if they communicate as opposed to sharing memory the process will be modularized and possibly more secure.</li>
</ul>

<h2 id="ê³µìœ -ë©”ëª¨ë¦¬">ê³µìœ  ë©”ëª¨ë¦¬</h2>

<blockquote>
  <p>Shared memory IPCs refer to sharing a physical memory location where multiple processes read and write to. The processes do this by mapping local memory to the shared physical memory location (via pointers or some other method). The physical memory is then used throughout the processes life spawn, meaning some processes can finish and close, but the physical memory remains until it is released (and all processes detach).</p>
</blockquote>

<blockquote>
  <p>It is possible (and advised) to address the issue of mutual exclusion by building a mutex that spans processes. Programers must recognize this and program accordingly.</p>
</blockquote>

<p><img src="/images/ipc_1.png" alt="" /></p>

<ul>
  <li>í”„ë¡œì„¸ìŠ¤ê°„ read, writeë¥¼ ëª¨ë‘ í•„ìš”ë¡œ í•  ë•Œ ì‚¬ìš©</li>
  <li>ì¤‘ê°œì ì—†ì´ ë©”ëª¨ë¦¬ì— ë°”ë¡œ ì ‘ê·¼ ê°€ëŠ¥ -&gt; ëª¨ë“  IPC ë°©ë²• ì¤‘ì— ê°€ì¥ ë¹ ë¦„</li>
  <li>ê³µìœ  ë©”ëª¨ë¦¬ ëª¨ë¸ì˜ ì¥ì 
    <ul>
      <li>ì»¤ë„ì˜ ê´€ì—¬ ì—†ì´ ë©”ëª¨ë¦¬ë¥¼ ì§ì ‘ ì‚¬ìš©í•˜ì—¬ IPC ì†ë„ê°€ ë¹ ë¥´ë‹¤.</li>
      <li>í”„ë¡œê·¸ë¨ ë ˆë²¨ì—ì„œ í†µì‹  ê¸°ëŠ¥ì„ ì œê³µí•˜ì—¬, ììœ ë¡œìš´ í†µì‹ ì´ ê°€ëŠ¥í•˜ë‹¤.</li>
    </ul>
  </li>
  <li>ê³µìœ  ë©”ëª¨ë¦¬ ëª¨ë¸ì˜ ë‹¨ì 
    <ul>
      <li>êµ¬í˜„í•˜ê¸° ì–´ë µë‹¤ëŠ” ë‹¨ì ì´ ìˆë‹¤.</li>
    </ul>
  </li>
  <li>ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ ê´€ì 
    <ul>
      <li>ê³µìœ  ë©”ëª¨ë¦¬ ëª¨ë¸ì—ì„œì˜ IPCëŠ” í•´ë‹¹ í”„ë¡œì„¸ìŠ¤ê°€ CPUë¥¼ ì‚¬ìš©í•˜ëŠ” í–‰ìœ„ì´ë‹¤.</li>
      <li>ì¦‰, IPCë¥¼ ë§ì´ í•œë‹¤ê³  ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ ë§ì´ ì¼ì–´ë‚˜ì§€ ì•ŠëŠ”ë‹¤.</li>
    </ul>
  </li>
  <li>ë™ê¸°í™” ê´€ì 
    <ul>
      <li>ë©”ëª¨ë¦¬ ì˜ì—­ì— ëŒ€í•œ ë™ì‹œì ì¸ ì ‘ê·¼ì„ ì œì–´í•˜ê¸° ìœ„í•œ ë°©ë²•ì´ í•„ìš”í•˜ë‹¤.</li>
      <li>ì»¤ë„ì´ ë™ê¸°í™”ë¥¼ ì œê³µí•˜ì§€ ì•Šìœ¼ë©°, ë¶€ê°€ì ì¸ ë°©ë²•ì´ í•„ìš”í•˜ë‹¤.</li>
      <li>ì ‘ê·¼ ì œì–´ ë°©ì‹ì€ lockingì´ë‚˜ ì„¸ë§ˆí¬ì–´(semaphore) ë“±ì´ ìˆë‹¤.</li>
    </ul>
  </li>
  <li>ê³µìœ  ë©”ëª¨ë¦¬ ëª¨ë¸ì˜ í™œìš©ì˜ ì˜ˆ : ë°ì´í„°ë² ì´ìŠ¤</li>
</ul>

<h2 id="íŒŒì¼">íŒŒì¼</h2>

<ul>
  <li>íŒŒì¼ì„ ì´ìš©í•œ í†µì‹ ì€ ë¶€ëª¨-ìì‹ í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹ ì— ë§ì´ ì‚¬ìš©</li>
  <li>ìš´ì˜ì²´ì œê°€ ë³„ë‹¤ë¥¸ ë™ê¸°í™”ë¥¼ ì œê³µí•˜ì§€ ì•ŠìŒ</li>
  <li>ë™ê¸°í™”ë¥¼ ìœ„í•´ ì£¼ë¡œ ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ê°€ wait() í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ ìì‹ í”„ë¡œì„¸ìŠ¤ì˜ ì‘ì—…ì´ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë ¸ë‹¤ê°€ ì‘ì—…ì„ ì‹œì‘</li>
</ul>

<h2 id="íŒŒì´í”„">íŒŒì´í”„</h2>

<blockquote>
  <p>Pipes are relatively straight forward. Instead of using shared/mapped memory to share data among processes, instead we â€œpipeâ€ data across processes with the help of the operating system. Although this does not mean that less memory is used necessarily (by the system), but it does remove the programmers requirement to manage it. The major advantage they have over the shared or mapped memory IPCs is that the programmer does not have to worry about does not have to worry about mutual exclusion for read/writing, the operating system handles it all.</p>
</blockquote>

<p><img src="/images/ipc_2.png" alt="" /></p>

<ul>
  <li>ìµëª… íŒŒì´í”„ (Anonymous Pipe)
    <ul>
      <li>ê¸°ë³¸ íŒŒì´í”„</li>
      <li>ë¶€ëª¨-ìì‹, í˜•ì œ í”„ë¡œì„¸ìŠ¤ê°„ í†µì‹ ì— ì‚¬ìš©</li>
      <li>ê¸°ë³¸ì ìœ¼ë¡œ í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤ëŠ” read, ë‹¤ë¥¸ í•˜ë‚˜ëŠ” writeë§Œ ê°€ëŠ¥í•œ ë‹¨ë°©í–¥ í†µì‹  -&gt; ì–‘ë°©í–¥ í†µì‹ ì„ ìœ„í•´ì„œëŠ” 2ê°œì˜ íŒŒì´í”„ í•„ìš”</li>
      <li>íŒŒì´í”„ë¥¼ ì‚¬ìš©í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ê°€ ì—†ìœ¼ë©´ ìë™ìœ¼ë¡œ ì œê±°ë¨</li>
    </ul>
  </li>
  <li>ë„¤ì„ë“œ íŒŒì´í”„ (Named Pipe)
    <ul>
      <li>ë¶€ëª¨-ìì‹, í˜•ì œ í”„ë¡œì„¸ìŠ¤ê°€ ì•„ë‹Œ ì„œë¡œ ë¬´ê´€í•œ í”„ë¡œì„¸ìŠ¤ê°„ í†µì‹ ì—ë„ ì‚¬ìš© ê°€ëŠ¥</li>
      <li>FIFOë¼ ë¶ˆë¦¬ëŠ” íŠ¹ìˆ˜í•œ íŒŒì¼ ì‚¬ìš©</li>
      <li>ë„¤ì„ë“œ íŒŒì´í”„ë¡œ ì–‘ë°©í–¥ í†µì‹ ì„ ìœ„í•´ì„œëŠ” 2ê°œì˜ íŒŒì´í”„ í•„ìš”</li>
      <li>íŒŒì´í”„ë¥¼ ì‚¬ìš©í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ê°€ ì—†ì–´ë„ ì œê±°ë˜ì§€ ì•Šê³  ë‚¨ì•„ìˆìŒ</li>
    </ul>
  </li>
</ul>

<h2 id="ì†Œì¼“">ì†Œì¼“</h2>

<blockquote>
  <p>sockets are similar to pipes, but capable of network connections (i.e. communication across computers). The data then travels through the network to another computer and to the desired process. You can also use sockets locally by using the â€œlocalhostâ€ to essentially loop-back to the another process on the system.</p>
</blockquote>

<p><img src="/images/ipc_3.png" alt="" /></p>

<ul>
  <li>ì†Œì¼“ì€ ë‘ í”„ë¡œì„¸ìŠ¤ê°„ í†µì‹ ì„ ìœ„í•´ ì œê³µë˜ëŠ” ì—”ë“œí¬ì¸íŠ¸</li>
  <li>ì›ê²©ì— ìˆëŠ” í”„ë¡œì„¸ìŠ¤ê°„ í†µì‹ ì„ ì œê³µ</li>
  <li>ì–‘ë°©í–¥ í†µì‹ ì´ ê°€ëŠ¥</li>
  <li>ì„œë²„/í´ë¼ì´ì–¸íŠ¸ êµ¬ì¡°ì˜ í”„ë¡œì„¸ìŠ¤ê°„ í†µì‹ ì— ìì£¼ ì‚¬ìš©</li>
</ul>

<h2 id="ë©”ì„¸ì§€-í">ë©”ì„¸ì§€ í</h2>

<ul>
  <li>íŒŒì´í”„ì™€ ë¹„ìŠ·í•˜ê²Œ ë‹¨ë°©í–¥ í†µì‹ </li>
  <li>íŒŒì´í”„ì™€ ë‹¤ë¥¸ì ì€ ë©”ì„¸ì§€ íëŠ” ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©</li>
  <li>ë‹¤ìˆ˜ì˜ í”„ë¡œì„¸ìŠ¤ê°„ ë°ì´í„° ì „ë‹¬ ê°€ëŠ¥</li>
  <li>ë©”ì‹œì§€ íë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ”, â€œë©”ì‹œì§€ í IDâ€ë¥¼ ì•Œì•„ì•¼ í•¨ (cf.ì†Œì¼“ì€ ìƒëŒ€ë°© í”„ë¡œì„¸ìŠ¤ì˜ â€œí¬íŠ¸ ë²ˆí˜¸â€ë§Œ ì•Œë©´ ê°€ëŠ¥)</li>
</ul>

<p>ìœ„ì—ì„œ ì‚´í´ë³¸ íŒŒì´í”„, ì†Œì¼“, ë©”ì„¸ì§€ íì™€ ê°™ì€ ë°©ì‹ì„ ë©”ì„¸ì§€ ì „ë‹¬ ëª¨ë¸ì´ë¼ê³  í•œë‹¤.</p>

<ul>
  <li>ë©”ì‹œì§€ ì „ë‹¬ ëª¨ë¸ì˜ ì¥ì 
    <ul>
      <li>êµ¬í˜„í•˜ê¸°ì— ê°„ë‹¨í•˜ì—¬ ì‚¬ìš©í•˜ê¸° í¸ë¦¬í•˜ë‹¤.</li>
    </ul>
  </li>
  <li>ë©”ì‹œì§€ ì „ë‹¬ ëª¨ë¸ì˜ ë‹¨ì 
    <ul>
      <li>ì»¤ë„ì„ ê²½ìœ í•˜ë¯€ë¡œ, ì†ë„ê°€ ëŠë¦¬ë‹¤.</li>
    </ul>
  </li>
  <li>ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ ê´€ì 
    <ul>
      <li>ë©”ì‹œì§€ ì „ë‹¬ ëª¨ë¸ì—ì„œì˜ IPCëŠ” í•´ë‹¹ í”„ë¡œì„¸ìŠ¤ ì…ì¥ì—ì„œ ì¼ì¢…ì˜ ì…ì¶œë ¥(I/O)ë¡œ ë³¼ ìˆ˜ ìˆë‹¤.</li>
      <li>ì¦‰, IPCë¥¼ í•˜ë©´ í• ìˆ˜ë¡ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ì´ ë§ì´ ì¼ì–´ë‚œë‹¤.
 =&gt; ì˜ˆë¥¼ ë“¤ì–´, sendí•˜ê³  ìƒëŒ€ë°©ì´ ë°›ì„ ë•Œê¹Œì§€ ê¸°ë‹¤ë ¤ì•¼ í•˜ë©°, ì´ ë•Œ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ì´ ë°œìƒí•œë‹¤.
 =&gt; ë§ˆì°¬ê°€ì§€ë¡œ, receiveí•˜ë©´ ìƒëŒ€ë°©ì´ ë³´ë‚¼ ë•Œê¹Œì§€ ê¸°ë‹¤ë ¤ì•¼ í•˜ë©°, ì´ ë•Œ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ì´ ë°œìƒí•œë‹¤.</li>
    </ul>
  </li>
  <li>ë™ê¸°í™” ê´€ì 
    <ul>
      <li>sendì™€ receiveì™€ ê°™ì€ ì—°ì‚°ì— ëŒ€í•´ì„œëŠ” ì»¤ë„ì´ ë™ê¸°í™”ë¥¼ ì œê³µí•œë‹¤.</li>
      <li>sendì™€ receiveë¥¼ ìˆ˜í–‰í•  ë•Œì— í”„ë¡œê·¸ë¨ì€ ë™ê¸°í™”ì— ëŒ€í•œ ê³ ë ¤ ì—†ì´ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.</li>
    </ul>
  </li>
  <li>ë©”ì‹œì§€ ì „ë‹¬ ëª¨ë¸ í™œìš©ì˜ ì˜ˆ : ì„œë²„-í´ë¼ì´ì–¸íŠ¸ ë°©ì‹ì˜ í†µì‹ </li>
  <li>ë©”ì‹œì§€ ì „ë‹¬ ëª¨ë¸ì˜ êµ¬í˜„ IPC : PIPE, Message Queue, Socket</li>
</ul>

<h1 id="rpc">RPC</h1>

<blockquote>
  <p>Remote Procedure Call is a technique for building distributed systems. Basically, it allows a program on one machine to call a subroutine on another machine without knowing that it is remote</p>
</blockquote>

<ul>
  <li>IPCì˜ í•œ ì¢…ë¥˜</li>
  <li>ë¶„ì‚° ë„¤íŠ¸ì›Œí¬ì—ì„œ ë§ì´ ì‚¬ìš©í•˜ëŠ” ë°©ì‹</li>
  <li>í´ë¼ì´ì–¸íŠ¸ëŠ” ë§ˆì¹˜ ë¡œì»¬ì— ìˆëŠ” í”„ë¡œì‹œì €ë¥¼ ì‹¤í–‰í•˜ë“¯ ì‚¬ìš© -&gt; ì‹¤ì œë¡œëŠ” ì›ê²©ì˜ ì£¼ì†Œ ê³µê°„ì— ìˆëŠ” í”„ë¡œì„¸ìŠ¤ì—ê²Œ ìš”ì²­ -&gt; ì›ê²©ì—ì„œ ì‹¤í–‰í•œ ë’¤ ê²°ê³¼ë¥¼ ë¦¬í„´</li>
  <li>(í”„ë¡œì‹œì €(procedure)ëŠ” ì„œë¸Œë£¨í‹´(subroutine)ì´ ë  ìˆ˜ë„ ìˆê³ , ì„œë¹„ìŠ¤ê°€ ë  ìˆ˜ë„ ìˆê³ , í•¨ìˆ˜ê°€ ë  ìˆ˜ë„ ìˆë‹¤)</li>
  <li>MSA(Micro Service Architecture)íŒ¨í„´ìœ¼ë¡œ ì„œë¹„ìŠ¤ë¥¼ ê°œë°œí•˜ëŠ” í™˜ê²½ì—ì„œ ìœ ìš©í•˜ê²Œ í™œìš©ë¨</li>
  <li>RPCëŠ” Java, Python, Goì™€ ê°™ì€ ë‹¤ì–‘í•œ ì–¸ì–´ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŒ</li>
  <li>RPCëŠ” í”„ë¡œì„¸ìŠ¤ê°„ í†µì‹  ê³¼ì •ì„ ì¶”ìƒí™”</li>
  <li>ë„¤íŠ¸ì›Œí¬ ì¥ë¹„, í”„ë¡œí† ì½œ, ìš´ì˜ì²´ì œì— ë¬´ê´€í•˜ê²Œ ê°œë°œ ê°€ëŠ¥</li>
</ul>

<p><img src="/images/rpc_2.png" alt="" /></p>

<h2 id="when-the-client-calls-the-server-the-rpc-system-must-take-care-of">When the client calls the server, the RPC system must take care of:</h2>

<ul>
  <li>Taking all the parameters which are passed to the subroutine and transferring them to the remote node;</li>
  <li>Having the subroutine executed on the remote node; and</li>
  <li>Transferring back all the parameters which are returned to the calling routine.</li>
</ul>

<p>The most common method of doing this is by the use of <strong>stub</strong> modules. The client program is linked to a client stub module. This is a subroutine which looks (from the outside) in every respect like the remote subroutine. On the inside, it is almost empty: all it does is take the values of the parameters which are passed to it, and put them in a message. This is known as <strong>marshalling</strong>.</p>

<p>The client stub then uses a routine in the RPC <strong>Run-Time System (RTS)</strong> to send the message off and wait for a reply message. When the reply arrives, the stub unmarshals the parameters that were returned in the reply message, putting their values into the variables of the calling program. The client stub then returns to the calling program just like a normal subroutine.</p>

<p>The server stub is located on the remote machine. It is called by the RPC run-time system when the message arrives from the client. The server stub performs the operations complementary to those of the the client stub: unmarshalling the parameters passed to the subroutine, calling the subroutine, and marshalling the return parameters.</p>

<p>All the communication details are handled by the RPC run-time system, so the stubs contain only the code which is specific to the application involved. Each stub handles a specific set of procedures known as a package.</p>

<p>In order to produce stub modules, one needs to know</p>

<ul>
  <li>The names of the procedures in the package</li>
  <li>The number of parameters which they take</li>
  <li>The data type of each parameter</li>
  <li>The direction in which each parameter is transferred.</li>
</ul>

<h2 id="the-following-steps-take-place-during-a-rpc">The following steps take place during a RPC</h2>

<p><img src="/images/rpc_1.png" alt="" /></p>

<ul>
  <li>A client invokes a client stub procedure, passing parameters in the usual way. The client stub resides within the clientâ€™s own address space.</li>
  <li>The client stub marshalls(pack) the parameters into a message. Marshalling includes converting the representation of the parameters into a standard format, and copying each parameter into the message.</li>
  <li>The client stub passes the message to the transport layer, which sends it to the remote server machine.</li>
  <li>On the server, the transport layer passes the message to a server stub, which demarshalls(unpack) the parameters and calls the desired server routine using the regular procedure call mechanism.</li>
  <li>When the server procedure completes, it returns to the server stub (e.g., via a normal procedure call return), which marshalls the return values into a message. The server stub then hands the message to the transport layer.</li>
  <li>The transport layer sends the result message back to the client transport layer, which hands the message back to the client stub.</li>
  <li>The client stub demarshalls the return parameters and execution returns to the caller.</li>
</ul>

<h2 id="ì¥ì ">ì¥ì </h2>

<ul>
  <li>The technique of using procedure calls in RPC permits high-level languages to provide communication between clients and servers.</li>
  <li>This method is like a local procedure call but with the difference that the called procedure is executed on another process and a different computer.</li>
  <li>The thread-oriented model is also supported by RPC in addition to the process model.</li>
  <li>The RPC mechanism is employed to conceal the core message passing method.</li>
  <li>The amount of time and effort required to rewrite and develop the code is minimal.</li>
  <li>The distributed and local environments can both benefit from remote procedure calls.</li>
  <li>To increase performance, it omits several of the protocol layers.</li>
  <li>Abstraction is provided via RPC.  To exemplify, the user is not known about the nature of message-passing in network communication.</li>
  <li>RPC empowers the utilization of applications in a distributed environment.</li>
</ul>

<h2 id="ë‹¨ì ">ë‹¨ì </h2>

<ul>
  <li>In Remote Procedure Calls parameters are only passed by values as pointer values are not allowed.</li>
  <li>It involves a communication system with another machine and another process, so this mechanism is extremely prone to failure.</li>
  <li>The RPC concept can be implemented in a variety of ways, hence there is no standard.</li>
  <li>Due to the interaction-based nature, there is no flexibility for hardware architecture in RPC.</li>
  <li>Due to a remote procedure call, the processâ€™s cost has increased.</li>
</ul>

<h2 id="grpc">gRPC</h2>

<blockquote>
  <p>gRPCëŠ” Google ì—ì„œ ë§Œë“  RPC(Remote Procedure Call) í”„ë¡œí† ì½œì´ë‹¤. ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì„ ì†Œí”„íŠ¸ì›¨ì–´ ë‚´ë¶€ì— ìˆëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë“¯ì´ ì‚¬ìš©í•˜ê²Œ ë„ì™€ì£¼ëŠ” í”„ë¡œí† ì½œì´ë‹¤.</p>
</blockquote>

<p><img src="/images/grpc_1.png" alt="" /></p>

<p>Monolithic êµ¬ì¡°ì—ì„œëŠ” í•˜ë‚˜ì˜ í”„ë¡œê·¸ë¨ìœ¼ë¡œ ë™ì‘í•˜ê¸° ë•Œë¬¸ì— ê·¸ ì•ˆì—ì„œ êµ¬ì¡°ì ì¸ 2ê°œì˜ ì„œë¹„ìŠ¤ê°„ì˜ ë°ì´í„°ëŠ” ê³µìœ  ë©”ëª¨ë¦¬ë¥¼ í†µí•´ì„œ ì£¼ê³ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ì´ ê²½ìš° ì„œë¹„ìŠ¤ê°„ ë©”ì‹œì§€ ì „ì†¡ ì„±ëŠ¥ì€ í° ì´ìŠˆê°€ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë°˜ë©´ MSAì—ì„œëŠ” ì—¬ëŸ¬ ëª¨ë“ˆë¡œ ë¶„ë¦¬ë˜ì–´ìˆê³  ë™ì¼ ë¨¸ì‹ ì— ì¡´ì¬í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ì¼ë°˜ì ìœ¼ë¡œëŠ” ë³´í¸í™”ëœ ë°©ì‹ì¸ REST í†µì‹ ì„ í†µí•´ ë©”ì‹œì§€ë¥¼ ì£¼ê³  ë°›ìŠµë‹ˆë‹¤. ë¬¸ì œëŠ” Frontend ìš”ì²­ì— ëŒ€í•œ ì‘ë‹µì„ ë§Œë“¤ì–´ë‚´ê¸° ìœ„í•´ ì—¬ëŸ¬ ë§ˆì´í¬ë¡œ ì„œë¹„ìŠ¤ê°„ì˜ í˜‘ë ¥ì´ í•„ìš”í•˜ë‹¤ë©´, êµ¬ê°„ë³„ REST í†µì‹ ì— ë”°ë¥¸ ë¹„íš¨ìœ¨ë¡œ ì¸í•´ ì‘ë‹µì†ë„ê°€ ì €í•˜ëœë‹¤ëŠ” ì ì…ë‹ˆë‹¤.</p>

<ul>
  <li>3 way handshake</li>
  <li>HTTP í—¤ë”</li>
</ul>

<p>gRPCëŠ” HTTP 2.0 ê¸°ë°˜ìœ„ì—ì„œ ë™ì‘í•˜ê¸° ë•Œë¬¸ì— ì§€ê¸ˆê¹Œì§€ HTTP 2.0ì˜ íŠ¹ì§•ì— ëŒ€í•´ì„œ ì‚´í´ë´¤ìŠµë‹ˆë‹¤. ì§§ê²Œ ì •ë¦¬í•˜ìë©´, Header ì••ì¶•, Multiplexed Stream ì²˜ë¦¬ ì§€ì› ë“±ìœ¼ë¡œ ì¸í•´ ë„¤íŠ¸ì›Œí¬ ë¹„ìš©ì„ ë§ì´ ê°ì†Œì‹œì¼°ìŠµë‹ˆë‹¤. ê·¸ë ‡ë‹¤ë©´ HTTP 2.0 íŠ¹ì§•ì„ ì œì™¸í•œ gRPCë§Œì˜ íŠ¹ì§•ì€ ë¬´ì—‡ì´ ìˆì„ê¹Œìš”? ë¨¼ì € REST API í†µì‹ ì˜ ë¬¸ì œì ì— ëŒ€í•´ì„œ ë¨¼ì € ì‚´í´ë³¸ ë‹¤ìŒ gRPCì˜ íŠ¹ì§•ì— ëŒ€í•´ì„œ ì‚´í´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤. REST êµ¬ì¡°ì—ì„œëŠ” JSON í˜•íƒœë¡œ ë°ì´í„°ë¥¼ ì£¼ê³  ë°›ìŠµë‹ˆë‹¤. JSONì€ ë°ì´í„° êµ¬ì¡°ë¥¼ ì‰½ê²Œ í‘œí˜„í•  ìˆ˜ ìˆìœ¼ë©°, ì‚¬ëŒì´ ì½ê¸° ì¢‹ì€ í‘œí˜„ ë°©ì‹ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ì‚¬ëŒì´ ì½ê¸° ì¢‹ì€ ë°©ì‹ì´ë¼ëŠ” ì˜ë¯¸ëŠ” ë¨¸ì‹  ì…ì¥ì—ì„œëŠ” ìì‹ ì´ ì½ì„ ìˆ˜ ìˆëŠ” í˜•íƒœë¡œ ë³€í™˜ì´ í•„ìš”í•˜ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ë”°ë¼ì„œ Clientì™€ Serverê°„ì˜ ë°ì´í„° ì†¡ìˆ˜ì‹ ê°„ì— JSON í˜•íƒœë¡œ Serialization ê·¸ë¦¬ê³  Deserialization ê³¼ì •ì´ ìˆ˜ë°˜ë˜ì–´ì•¼í•©ë‹ˆë‹¤. JSON ë³€í™˜ì€ ì»´í“¨í„° CPU ë° ë©”ëª¨ë¦¬ ë¦¬ì†ŒìŠ¤ë¥¼ ì†Œëª¨í•˜ë¯€ë¡œ ìˆ˜ë§ì€ ë°ì´í„°ë¥¼ ë¹ ë¥´ê²Œ ì²˜ë¦¬í•˜ëŠ” ê³¼ì •ì—ì„œëŠ” íš¨ìœ¨ì´ ë–¨ì–´ì§ˆ ìˆ˜ ë°–ì— ì—†ìŠµë‹ˆë‹¤.</p>

<p>ë‘ ë²ˆì§¸ ì´ìŠˆëŠ” JSON êµ¬ì¡°ëŠ” ê°’ì€ Stringìœ¼ë¡œ í‘œí˜„ë©ë‹ˆë‹¤. ë”°ë¼ì„œ ì‚¬ì „ì— íƒ€ì… ì œì•½ ì¡°ê±´ì— ëŒ€í•œ ëª…í™•í•œ í•©ì˜ê°€ ì—†ê±°ë‚˜ ë¬¸ì„œë¥¼ ë³´ê³  ê°œë°œìê°€ ì¸ì§€í•˜ì§€ ëª»í•œë‹¤ë©´, Serverì— ì „ë‹¬ì „ì— ì´ë¥¼ ê²€ì¦í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê°€ë ¹ ìœ„ ì˜ˆì‹œì™€ ê°™ì´ Serverì—ì„œ zipCodeëŠ” ìˆ«ì íƒ€ì…ìœ¼ë¡œ ì²˜ë¦¬ë˜ì–´ì•¼í•˜ì§€ë§Œ Clientì—ì„œëŠ” ì´ì— ëŒ€í•œ ì œì•½ ì—†ì´ ë¬¸ìì—´ì„ í¬í•¨ì‹œì¼œ ì „ë‹¬í•  ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.</p>

<p>ê·¸ë ‡ë‹¤ë©´ gRPC ê¸°ìˆ ì€ ìœ„ ë‘ ê°€ì§€ ì´ìŠˆë¥¼ ì–´ë–»ê²Œ í’€ì–´ë‚´ì—ˆì„ê¹Œìš”?</p>

<p>Clientì—ì„œ Serverì¸¡ì˜ APIë¥¼ í˜¸ì¶œí•˜ê¸° ìœ„í•´ì„œ ê¸°ì¡´ì—ëŠ” ì–´ë–¤ Endpointë¡œ í˜¸ì¶œí•´ì•¼í•  ì§€ ê·¸ë¦¬ê³  ì „ë‹¬ Specì— ëŒ€í•´ì„œ API ë¬¸ì„œ ì‘ì„± í˜¹ì€ Clientì™€ Server ê°œë°œìê°„ì˜ ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ì„ í†µí•´ ì •ì˜í•´ì•¼í–ˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  ì´ëŠ” ë³„ë„ì˜ ë¬¸ì„œ ìƒì„±ì´ë‚˜ ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ ë¹„ìš©ì´ ì¶”ê°€ë¡œ ë°œìƒí•©ë‹ˆë‹¤.</p>

<p>ì´ëŸ¬í•œ ë¬¸ì œë¥¼ ê°ì†Œì‹œí‚¤ê¸° ìœ„í•´ ë‹¤ì–‘í•œ ë°©ë²•ì´ ì¡´ì¬í•©ë‹ˆë‹¤. ê·¸ ì¤‘ í•œê°€ì§€ëŠ” Serverì˜ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì „ìš© Libraryë¥¼ Clientì—ê²Œ ì œê³µí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ê·¸ëŸ¬ë©´ ClientëŠ” í•´ë‹¹ Libraryì—ì„œ ì œê³µí•˜ëŠ” Util ë©”ì†Œë“œë¥¼ í™œìš©í•´ì„œ í˜¸ì¶œí•˜ë©´ ë‚´ë¶€ì ìœ¼ë¡œëŠ” Serverì™€ í†µì‹ í•˜ì—¬ ì˜¬ë°”ë¥¸ ê²°ê³¼ë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë˜í•œ í•´ë‹¹ ë°©ë²•ì€ Serverì—ì„œ ìš”êµ¬í•˜ëŠ” Specì— ë¶€í•©ë˜ëŠ” ë°ì´í„°ë§Œ ë³´ë‚¼ ìˆ˜ ìˆê²Œ ê°•ì œí™” í•  ìˆ˜ ìˆë‹¤ëŠ” ì¸¡ë©´ì—ì„œ ìŠ¤í‚¤ë§ˆì— ëŒ€í•œ ì œì•½ì„ ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>

<p>gRPCì—ì„œëŠ” ìœ„ ê·¸ë¦¼ê³¼ ê°™ì´ ì´ì™€ ìœ ì‚¬í•œ í˜•íƒœì¸ Stub í´ë˜ìŠ¤ë¥¼ Clientì—ê²Œ ì œê³µí•˜ì—¬ ClientëŠ” Stubì„ í†µí•´ì„œë§Œ gRPC ì„œë²„ì™€ í†µì‹ ì„ ìˆ˜í–‰í•˜ë„ë¡ ê°•ì œí™” í–ˆìŠµë‹ˆë‹¤.</p>

<p>ê·¸ë ‡ë‹¤ë©´ Stub í´ë˜ìŠ¤ëŠ” ë¬´ì—‡ì´ê³  ìœ„ ê·¸ë¦¼ì—ì„œ ë³´ì´ëŠ” ProtoëŠ” ë¬´ì—‡ì¼ê¹Œìš”?</p>

<p>Protocol BufferëŠ” Googleì´ ê³µê°œí•œ ë°ì´í„° êµ¬ì¡°ë¡œì¨, íŠ¹ì • ì–¸ì–´ í˜¹ì€ íŠ¹ì • í”Œë«í¼ì— ì¢…ì†ì ì´ì§€ ì•Šì€ ë°ì´í„° í‘œí˜„ ë°©ì‹ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ Protocol BufferëŠ” íŠ¹ì • ì–¸ì–´ì— ì†í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ Javaë‚˜ Kotlin, Golang ì–¸ì–´ì—ì„œ ì§ì ‘ì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>

<p>ë”°ë¼ì„œ Protocol Bufferë¥¼ ì–¸ì–´ì—ì„œ ë…ë¦½ì ìœ¼ë¡œ í™œìš©í•˜ê¸° ìœ„í•´ì„œëŠ” ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ Client í˜¹ì€ Serverì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” Stub í´ë˜ìŠ¤ë¥¼ ìƒì„±í•´ì•¼í•©ë‹ˆë‹¤. ì´ë•Œ protoc í”„ë¡œê·¸ë¨ì„ í™œìš©í•´ì„œ ë‹¤ì–‘í•œ ì–¸ì–´ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” Stub í´ë˜ìŠ¤ë¥¼ ìë™ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>

<p>Stub í´ë˜ìŠ¤ë¥¼ ìƒì„±í•˜ë©´, í•´ë‹¹ í´ë˜ìŠ¤ ì •ë³´ë¥¼ Serverì™€ Clientì— ê³µìœ í•œ ë‹¤ìŒ Stub í´ë˜ìŠ¤ë¥¼ í™œìš©í•˜ì—¬ ì„œë¡œ ì–‘ë°©í–¥ í†µì‹ ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>

<p>ì§€ê¸ˆê¹Œì§€ í•™ìŠµí•œ Protocol Buffer ë‚´ìš©ì„ ì •ë¦¬í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ì¥ì ì„ ì§€ë‹Œ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>

<ol>
  <li>ìŠ¤í‚¤ë§ˆ íƒ€ì… ì œì•½ì´ ê°€ëŠ¥í•˜ë‹¤</li>
  <li>Protocol bufferê°€ API ë¬¸ì„œë¥¼ ëŒ€ì²´í•  ìˆ˜ ìˆë‹¤.</li>
</ol>

<p>ìœ„ ë‘ê°€ì§€ íŠ¹ì§•ì€ ì´ì „ì— RESTì—ì„œ ë‹¤ë£¬ ì´ìŠˆ ì¤‘ í•˜ë‚˜ì¸ API Spec ì •ì˜ ë° ë¬¸ì„œ í‘œì¤€í™” ë¶€ì¬ì˜ ë¬¸ì œë¥¼ ì–´ëŠì •ë„ í•´ì†Œí•´ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë ‡ë‹¤ë©´ ë˜ í•˜ë‚˜ì˜ ì´ìŠˆì¸ JSON Payload ë¹„íš¨ìœ¨ ë¬¸ì œì™€ ëŒ€ë¹„í•˜ì—¬ gRPCëŠ” ì–´ë– í•œ ì´ì ì„ ì§€ë‹ˆê³  ìˆì„ê¹Œìš”?</p>

<p>JSON íƒ€ì…ì€ ìœ„ì™€ê°™ì´ ì‚¬ëŒì´ ì½ê¸°ëŠ” ì¢‹ì§€ë§Œ ë°ì´í„° ì „ì†¡ ë¹„ìš©ì´ ë†’ìœ¼ë©°, í•´ë‹¹ ë°ì´í„° êµ¬ì¡°ë¡œ Serialization, Deserialization í•˜ëŠ” ë¹„ìš©ì´ ë†’ìŒì„ ì•ì„œ ì§€ì í–ˆìŠµë‹ˆë‹¤.</p>

<p>gRPCì˜ í†µì‹ ì—ì„œëŠ” ë°ì´í„°ë¥¼ ì†¡ìˆ˜ì‹ í•  ë•Œ Binaryë¡œ ë°ì´í„°ë¥¼ encoding í•´ì„œ ë³´ë‚´ê³  ì´ë¥¼ decoding í•´ì„œ ë§¤í•‘í•©ë‹ˆë‹¤. ë”°ë¼ì„œ JSONì— ë¹„í•´ payload í¬ê¸°ê°€ ìƒë‹¹íˆ ì ìŠµë‹ˆë‹¤.</p>

<p>ë˜í•œ JSONì—ì„œëŠ” í•„ë“œì— ê°’ì„ ì…ë ¥í•˜ì§€ ì•Šì•„ë„ êµ¬ì¡°ìƒì— í•´ë‹¹ í•„ë“œê°€ í¬í•¨ë˜ì–´ì•¼í•˜ê¸° ë•Œë¬¸ì— í¬ê¸°ê°€ ì»¤ì§‘ë‹ˆë‹¤.  ë°˜ë©´ gRPCì—ì„œëŠ” ì…ë ¥ëœ ê°’ì— ëŒ€í•´ì„œë§Œ Binary ë°ì´í„°ì— í¬í•¨ì‹œí‚¤ê¸° ë•Œë¬¸ì— ì••ì¶• íš¨ìœ¨ì´ JSONì— ë¹„í•´ ìƒë‹¹íˆ ì¢‹ìŠµë‹ˆë‹¤.</p>

<p>ê²°ë¡ ì ìœ¼ë¡œ ì´ëŸ¬í•œ ì ì€ ë°ì´í„° í¬ê¸° ë° Serialization, Deserialization ê³¼ì •ì˜ ì ì€ ë¹„ìš©ì€ ëŒ€ê·œëª¨ íŠ¸ë˜í”½ í™˜ê²½ì—ì„œ ì„±ëŠ¥ìƒ ìœ ë¦¬í•©ë‹ˆë‹¤.</p>

<h2 id="grpc-ì´ì ">gRPC ì´ì </h2>

<ul>
  <li>ì„±ëŠ¥
    <ul>
      <li>ë„¤íŠ¸ì›Œí¬ ìš”ì²­ìœ¼ë¡œ ë³´ë‚´ê¸° ìœ„í•´ Protobufë¥¼ ì§ë ¬í™”(Serialization) ë° ì—­ì§ë ¬í™”(Deserialization)í•˜ëŠ” ì‘ì—…ì€ JSON í˜•íƒœì˜ ì§ë ¬í™”/ì—­ì§ë ¬í™” ë³´ë‹¤ ë¹ ë¥´ë‹¤. ë˜í•œ gRPCì˜ ë„¤íŠ¸ì›Œí¬ ì†ë„ê°€ HTTP POST/GET ì†ë„ë³´ë‹¤ ë¹ ë¥´ë‹¤. íŠ¹íˆ POST ìš”ì²­ ì‹œ ë§ì€ ì°¨ì´ë¥¼ ë³´ì¸ë‹¤. ìì„¸í•œ ë‚´ìš©ì€ Mobile gRPC Benchmarks ë¬¸ì„œë¥¼ ì°¸ê³ í•œë‹¤.</li>
    </ul>
  </li>
  <li>API-ìš°ì„  ë°©ì‹
    <ul>
      <li>Protobufë¥¼ í†µí•´ ê¸°ëŠ¥ì„ ê°œë°œí•˜ê¸° ì „ì— APIë¥¼ ë¨¼ì € ì •ì˜í•  ìˆ˜ ìˆë‹¤. APIê°€ ë¨¼ì € ì •ì˜ë  ê²½ìš° ê°œë°œíŒ€ì´ ë³‘ë ¬ì ìœ¼ë¡œ ì¼ì„ ì§„í–‰í•  ìˆ˜ ìˆê³ , ê°œë°œ ì†ë„ê°€ ë¹¨ë¼ì§€ë©°, APIë¥¼ ì¢€ ë” ì•ˆì •ì ìœ¼ë¡œ ì œê³µí•  ìˆ˜ ìˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ Understanding the API-First Approach to Building Products ë¬¸ì„œë¥¼ ì°¸ê³ í•œë‹¤.</li>
    </ul>
  </li>
  <li>REST API ì§€ì›
    <ul>
      <li>Protobufë¡œ ì •ì˜ëœ APIëŠ” envoyproxyë‚˜ grpc-gateway ê°™ì€ gateway ë¥¼ í†µí•´ REST APIë¡œ ì œê³µ ê°€ëŠ¥í•˜ë‹¤. gRPCë¡œ ì •ì˜ëœ APIë¥¼ OpenAPI í”„ë¡œí† ì½œë¡œ ë³€í™˜í•˜ì—¬ REST APIë¥¼ ì‚¬ìš©í•˜ëŠ” í´ë¼ì´ì–¸íŠ¸ì—ë„ API-ìš°ì„  ë°©ì‹ì„ ì ìš©í•  ìˆ˜ ìˆë‹¤.</li>
    </ul>
  </li>
</ul>

<h1 id="ì°¸ê³ ">ì°¸ê³ </h1>

<ul>
  <li><a href="https://austingwalters.com/introduction-to-ipc-interprocess-communication/">Austin G. Walters, Intro to IPC</a></li>
  <li><a href="https://dar0m.tistory.com/233" target="_blank">DR-kim, í”„ë¡œì„¸ìŠ¤ê°„ í†µì‹  ë°©ë²•</a></li>
  <li><a href="https://heeonii.tistory.com/13" target="_blank">ìš°ë‹¹íƒ•íƒ• íˆì˜¨ì´ë„¤, [ìš´ì˜ì²´ì œ] IPC í”„ë¡œì„¸ìŠ¤ê°„ í†µì‹ </a></li>
  <li><a href="https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&amp;blogId=bycho211&amp;logNo=220985701140" target="_blank">bycho211, í”„ë¡œì„¸ìŠ¤ê°„ í†µì‹ (IPC)</a></li>
  <li><a href="https://frozenpond.tistory.com/126" target="_blank">ì–¼ìŒì—°ëª», [ê°œë°œìƒì‹] í”„ë¡œì„¸ìŠ¤ê°„ í†µì‹ (IPC)</a></li>
  <li><a href="https://nesoy.github.io/articles/2019-07/RPC" target="_blank">nesoy, RPCë€?</a></li>
  <li><a href="https://velog.io/@jakeseo_me/RPC%EB%9E%80" target="_blank">jakeseo, RPCë€?</a></li>
  <li><a href="https://www.w3.org/History/1992/nfs_dxcern_mirror/rpc/doc/Introduction/WhatIs.html" target="_blank">w3, What is Remote Procedure Call?</a></li>
  <li><a href="https://grpc.io/docs/what-is-grpc/" target="_blank">grpcê³µì‹ë¬¸ì„œ, What is gRPC?</a></li>
  <li><a href="https://medium.com/naver-cloud-platform/nbp-%EA%B8%B0%EC%88%A0-%EA%B2%BD%ED%97%98-%EC%8B%9C%EB%8C%80%EC%9D%98-%ED%9D%90%EB%A6%84-grpc-%EA%B9%8A%EA%B2%8C-%ED%8C%8C%EA%B3%A0%EB%93%A4%EA%B8%B0-1-39e97cb3460" target="_blank">navercloud, [ë„¤ì´ë²„í´ë¼ìš°ë“œ ê¸°ìˆ &amp;ê²½í—˜] ì‹œëŒ€ì˜ íë¦„, gRPC ê¹Šê²Œ íŒŒê³ ë“¤ê¸° #1</a></li>
  <li><a href="https://cla9.tistory.com/175?category=993774" target="_blank">cla9, 1. gRPC ê°œìš”</a></li>
  <li><a href="https://tech.buzzvil.com/handbook/grpc/" target="_blank">buzzvil Tech, gRPC</a></li>
</ul>
:ET