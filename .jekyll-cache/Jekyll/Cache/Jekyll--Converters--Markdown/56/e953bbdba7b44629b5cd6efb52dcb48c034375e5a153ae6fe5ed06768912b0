I"<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#elk-소개" id="markdown-toc-elk-소개">ELK 소개</a>    <ul>
      <li><a href="#엘라스틱서치" id="markdown-toc-엘라스틱서치">엘라스틱서치</a></li>
      <li><a href="#로그스태시" id="markdown-toc-로그스태시">로그스태시</a></li>
      <li><a href="#비츠" id="markdown-toc-비츠">비츠</a></li>
      <li><a href="#elk-용도" id="markdown-toc-elk-용도">ELK 용도</a></li>
    </ul>
  </li>
  <li><a href="#엘라스틱서치-1" id="markdown-toc-엘라스틱서치-1">엘라스틱서치</a>    <ul>
      <li><a href="#인덱스" id="markdown-toc-인덱스">인덱스</a></li>
      <li><a href="#도큐먼트" id="markdown-toc-도큐먼트">도큐먼트</a></li>
      <li><a href="#매핑" id="markdown-toc-매핑">매핑</a></li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="elk-소개">ELK 소개</h1>

<ul>
  <li>엘라스틱서치가 처음 등장했을 때 누구도 빅데이터 파이프라인을 구성하는 플랫폼 형태로 성장하리라 예상하지 못했을 것이다</li>
  <li>엘라스틱이 등장했을 무렵 사용자의 요구 사항은 너무나 명확했다. 빠른 전문 검색(Full text search) 기능</li>
  <li>1999년 하둡으로 유명해진 더그 커팅은 자신의 부인의 이름을 딴 루씬(Lucene)라는 검색엔진 라이브러리를 만들었다</li>
  <li>데이터와 관련한 작업의 중요성이 커짐에 따라 검색 엔진만 제공하는 서비스는 쉽게 주목받기 힘들었다</li>
  <li>엘라스틱은 검색엔진을 뛰어넘는 하나의 플랫폼으로 성장하는 길을 택했다</li>
  <li>데이터를 수집, 가공, 저장, 분석, 시각화하는 일련의 파이프라인을 제공해줄 수 있는 플랫폼을 만들기로 했다</li>
  <li>그렇게 등장한 것이 Elasticsearch, Logstash, Kibana 그리고 Beats이다</li>
  <li>초창기에는 스택간의 버전을 따로 관리해 버전간의 충돌이 잦았지만, 이제는 스택간의 버전을 모두 통일시켜서 이런 문제를 해결했다</li>
</ul>

<h2 id="엘라스틱서치">엘라스틱서치</h2>

<ul>
  <li>엘라스틱서치는 텍스트나 도큐먼트의 경우 인덱싱 시점에 분석을 거쳐 용어(term) 단위로 분해되고 역인덱스 사전을 구축한다.</li>
  <li>엘락스틱서치의 중요한 특징 중 하나는 스코어링, 즉 연관도에 따른 정렬이다</li>
  <li>분산 시스템으로서 엘라스틱서치는 복수의 루씬 인스턴스를 병렬로 배치하고 분산 처리해 검색 속도를 무한히 확장할 수 있게 한다</li>
  <li>인덱스가 불변의 자료구조이기 때문에 도큐먼트를 수정하거나 삭제할 경우에 비용이 저렴하지 않다</li>
  <li>하지만 이런 단점은 검색 성능을 끌어올리기 위한 트레이드 오프로 일반적으로 용인되는 제약이다</li>
  <li>엘라스틱서치는 검색 엔진에 초점을 맞추고 설계되었기 때문에 다른 범용 DBMS와 비교해 더 많은 리소스를 사용</li>
</ul>

<h2 id="로그스태시">로그스태시</h2>

<ul>
  <li>배치 처리와 병렬 처리가 가능하며, 영속적인 큐를 사용해 현재 처리중인 이벤트의 최소 1회 전송을 보장</li>
  <li>데이터량이 급증하는 부하 상황에서도 안정성을 보장해준다</li>
</ul>

<h2 id="비츠">비츠</h2>

<ul>
  <li>실제 서비스에 로그스태시와 같은 무거운 툴은 활용도가 떨어질 수 있다</li>
  <li>비츠는 파일비트, 메트릭비트 등 비츠라고 부르는 경량 수집기가 포함되어 있다</li>
  <li>각 비트는 로그 수집, 시스템 메트릭 수집 등 특정 목적에 최적화된 에이전트</li>
  <li>가볍기로 유명한 고(Go) 언어로 작성</li>
</ul>

<h2 id="elk-용도">ELK 용도</h2>

<ul>
  <li>전문 검색 엔진</li>
  <li>로그 통합 분석</li>
  <li>애플리케이션 성능 분석</li>
</ul>

<h1 id="엘라스틱서치-1">엘라스틱서치</h1>

<ul>
  <li>엘라스틱서치에서 도큐먼트를 인덱스에 포함시키는 것을 인덱싱이라고 한다</li>
  <li>엘라스틱서치는 우리가 데이터 타입을 지정하지 않아도 도큐먼트의 필드와 값을 보고 자동으로 매핑해주는데 이를 다이내믹 매핑</li>
  <li>다이내믹 매핑은 데이터 타입이 잘못된 도큐먼트가 들어올 때, 어느 정도 변환 가능한 경우는 자동으로 변환 (“20” -&gt; 20)</li>
  <li>도큐먼트의 R 은 도큐먼트의 id 값으로 가져올 수 있지만 실무에서 이렇게 가져오는 경우는 잘 없다. 대부분 검색 API 이용</li>
  <li>도큐먼트 수정은 전체를 덮어쓰기할 수도 있고, 특정 필드의 값만 수정할 수도 있다</li>
  <li>엘라스틱서치는 도큐먼트 수정 작업은 비용이 많이 들어간다. 그래서 더더욱 로그 수집 용도로 많이 사용되는 것</li>
  <li>도큐먼트를 삭제할 때는 인덱스명과 도큐먼트 아이디를 알면 된다</li>
  <li>bulk API를 통해 생성/수정/삭제를 한 번에 요청할 수도 있다 (HTTP 요청을 한 번만 보내면 된다) (읽기는 불가)</li>
  <li>현업에서는 벌크 데이터를 파일 형태로 만들어서 적용하는 방법을 많이 사용한다</li>
  <li>bulk API의 요청 데이터 포맷은 JSON 문법이 아닌 NDJSON 문법이다
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"index"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"_index"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index2"</span><span class="p">,</span><span class="w"> </span><span class="nl">"_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"6"</span><span class="p">}}</span><span class="w">
</span><span class="p">{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"hong"</span><span class="p">,</span><span class="w"> </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="nl">"gender"</span><span class="p">:</span><span class="w"> </span><span class="s2">"female"</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="nl">"index"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"_index"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index2"</span><span class="p">,</span><span class="w"> </span><span class="nl">"_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"7"</span><span class="p">}}</span><span class="w">
</span><span class="p">{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"choi"</span><span class="p">,</span><span class="w"> </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="nl">"gender"</span><span class="p">:</span><span class="w"> </span><span class="s2">"male"</span><span class="p">}</span><span class="w">  
</span></code></pre></div>    </div>
  </li>
</ul>

<h2 id="인덱스">인덱스</h2>

<h2 id="도큐먼트">도큐먼트</h2>

<h2 id="매핑">매핑</h2>

<ul>
  <li>엘라스틱서치가 검색 엔진으로 전문 검색과 대용량 데이터를 빠르게 실시간 검색할 수 있는 이유는 매핑이 있기 때문</li>
  <li>자동으로 하면 다이내믹 매핑, 직접 설정하면 명시적 매핑</li>
  <li>어떤 데이터가 들어올지 명시할 수 없다면 다이내믹 매핑을 써도 되지만,</li>
  <li>성능 최적화와 데이터의 정확성을 위해서는 명시적으로 매핑을 하는 것이 좋다</li>
  <li></li>
</ul>

:ET