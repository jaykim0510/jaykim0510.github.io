I"i<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#http" id="markdown-toc-http">HTTP</a>    <ul>
      <li><a href="#http-버전-차이" id="markdown-toc-http-버전-차이">HTTP 버전 차이</a></li>
      <li><a href="#http의-특징" id="markdown-toc-http의-특징">HTTP의 특징</a></li>
    </ul>
  </li>
  <li><a href="#url" id="markdown-toc-url">URL</a></li>
  <li><a href="#http-method" id="markdown-toc-http-method">HTTP Method</a></li>
  <li><a href="#http-메세지" id="markdown-toc-http-메세지">HTTP 메세지</a>    <ul>
      <li><a href="#시작-라인" id="markdown-toc-시작-라인">시작 라인</a>        <ul>
          <li><a href="#요청-메세지" id="markdown-toc-요청-메세지">요청 메세지</a></li>
          <li><a href="#응답-메세지" id="markdown-toc-응답-메세지">응답 메세지</a></li>
        </ul>
      </li>
      <li><a href="#http-헤더" id="markdown-toc-http-헤더">HTTP 헤더</a>        <ul>
          <li><a href="#요청-메세지-1" id="markdown-toc-요청-메세지-1">요청 메세지</a></li>
          <li><a href="#응답-메세지-1" id="markdown-toc-응답-메세지-1">응답 메세지</a></li>
        </ul>
      </li>
      <li><a href="#http-바디" id="markdown-toc-http-바디">HTTP 바디</a></li>
      <li><a href="#예시" id="markdown-toc-예시">예시</a>        <ul>
          <li><a href="#요청-메세지-2" id="markdown-toc-요청-메세지-2">요청 메세지</a></li>
          <li><a href="#응답-메세지-2" id="markdown-toc-응답-메세지-2">응답 메세지</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#http-상태코드" id="markdown-toc-http-상태코드">HTTP 상태코드</a></li>
  <li><a href="#쿠키-캐시-프록시-세션" id="markdown-toc-쿠키-캐시-프록시-세션">쿠키, 캐시, 프록시, 세션</a>    <ul>
      <li><a href="#쿠키" id="markdown-toc-쿠키">쿠키</a></li>
      <li><a href="#캐시" id="markdown-toc-캐시">캐시</a></li>
    </ul>
  </li>
  <li><a href="#웹-브라우저의-동작원리" id="markdown-toc-웹-브라우저의-동작원리">웹 브라우저의 동작원리</a>    <ul>
      <li><a href="#http-리퀘스트-작성" id="markdown-toc-http-리퀘스트-작성">HTTP 리퀘스트 작성</a>        <ul>
          <li><a href="#url-입력" id="markdown-toc-url-입력">URL 입력</a></li>
          <li><a href="#http-리퀘스트-작성-1" id="markdown-toc-http-리퀘스트-작성-1">HTTP 리퀘스트 작성</a></li>
        </ul>
      </li>
      <li><a href="#dns-서버에-웹-서버의-ip주소-조회" id="markdown-toc-dns-서버에-웹-서버의-ip주소-조회">DNS 서버에 웹 서버의 IP주소 조회</a>        <ul>
          <li><a href="#dns-resolver를-이용해-dns-서버-조회" id="markdown-toc-dns-resolver를-이용해-dns-서버-조회">DNS Resolver를 이용해 DNS 서버 조회</a></li>
        </ul>
      </li>
      <li><a href="#프로토콜-스택에-메시지-송신-요청" id="markdown-toc-프로토콜-스택에-메시지-송신-요청">프로토콜 스택에 메시지 송신 요청</a></li>
    </ul>
  </li>
  <li><a href="#https" id="markdown-toc-https">HTTPS</a></li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>
<hr />

<h1 id="http">HTTP</h1>

<p><strong>HTTP(HyperText Transfer Protocol)는 응용 계층(Application layer)에서 압도적으로 많이 사용되는 프로토콜</strong>입니다. 요즘에는 모든 데이터(텍스트, 이미지, 음성, 영상, 파일, JSON 등)를 HTTP 메시지에 담아서 전송합니다.</p>

<p>HTTP가 하는 역할은 무엇일까요? 저희는 응용 계층에서 데이터를 주고받기 위해(크롬, 사파리와 같은 웹 브라우저에서 뉴스, 사진, 동영상을 보고 물건을 주문하는 것과 같은 행위) 클라이언트는 요청(request), 서버는 응답(response)하는 방식을 사용합니다.  이 때 응용 계층에 있는 단말기(우리의 핸드폰, 노트북 그리고 구글이 가지고 있는 웹 서버와 같은 것들)들이 서로 일관된 방법으로 데이터를 주고받기 위해 규약이 필요했는데 이때 생긴 규약이 바로 HTTP입니다.</p>

<p>이 때 클라이언트는 <strong>HTTP 메세지를 작성하기 위해 두 가지를 사용</strong>합니다. 바로 <strong>URL</strong>과 <strong>HTTP 메소드</strong>입니다.</p>

<h2 id="http-버전-차이">HTTP 버전 차이</h2>

<ul>
  <li>HTTP/1.1: 1997년에 등장해서 현재까지 가장 많이 사용하는 버전</li>
  <li>HTTP/2:</li>
  <li>HTTP/3: UDP기반으로 개발됨</li>
</ul>

<h2 id="http의-특징">HTTP의 특징</h2>

<ul>
  <li>클라이언트/서버 구조로 동작
    <ul>
      <li>클라이언트가 request를 보내면 서버가 response를 돌려주는 구조 -&gt; 단방향 통신</li>
    </ul>
  </li>
  <li>무상태(Stateless) 프로토콜
    <ul>
      <li>서버가 클라이언트의 상태를 보존하지 않음 (그래서 클라이언트가 알아서 자신의 상태를 잘 업데이트해서 서버에 전달하게 됨)</li>
      <li>장점: 서버 확장성 높음(서버가 중간에 바뀌어도 된다. 어차피 클라이언트가 부담하게 되므로)</li>
      <li>장점: 특정 서버에 의존하지 않게 되므로 서버 장애에 강인하다</li>
      <li>단점: 클라이언트가 추가 데이터 전송해야함</li>
      <li>로그인이 필요한 서비스의 경우 로그인 상태를 서버에 유지해야하므로 이 때는 브라우저의 쿠키와 서버의 세션을 조합해서 보완해야함</li>
    </ul>
  </li>
  <li>비연결성
    <ul>
      <li>서버와 클라이언트가 계속 연결을 유지하게 된다면 클라이언트가 늘어날때마다 서버의 리소스 부담 계속 커지게 됨</li>
      <li>클라이언트가 request를 보내고 서버가 response를 보낸 후 요청을 끊는다 -&gt; 서버는 최소한의 자원만 사용하게 됨</li>
      <li>HTTP는 기본적으로 연결을 유지하지 않는 모델</li>
      <li>연결하는데 시간이 별로 소요되지 않나? -&gt; TCP/IP 연결 새로 맺어야함 -&gt; 3-way handshake 시간이 추가된다</li>
      <li>그리고 네이버 검색을 예로 들때, 우리가 HTTP 메세지를 보내고 response를 돌려줄 때 검색 결과만 돌려주는게 아니라 그안에 포함된 HTML, CSS, 이미지 등을 함께 돌려줘야 한다 -&gt; 이런 문제를 HTTP Persistent Connection으로 해결</li>
      <li>Persistent Connection은 내부 메커니즘에 의해 보통 하나의 웹 페이지를 띄울 동안 연결을 계속 지속시킨다</li>
      <li>HTTP/2, HTTP/3 오면서는 HTTP Persistent Connection이 더욱 발전됨
<img src="/images/network_30.png" alt="" /></li>
    </ul>
  </li>
  <li>HTTP 메시지</li>
</ul>

<h1 id="url">URL</h1>

<p><img src="/images/network_34.png" alt="" /></p>

<p>URL은 Uniform Resource Locator의 약자입니다. URL은 URI(Uniform Resource Identifier)를 표현하기 위한 방법 중 하나입니다. URL말고도 URN이라는 것이 있지만 지금은 거의 URL만 사용하기 때문에 URN은 생략하도록 하겠습니다.</p>

<p>인터넷에서 어떤 <strong>자원(회원 정보, 주문서, 사진, 동영상 등)을 유일하게 표현하기 위해 URI라는 개념이 등장</strong>했고 이를 위한 방법으로 URL을 사용하는 것입니다. <strong>URL은 이러한 자원들에게 부여된 고유한 주소</strong>를 말합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>인터넷에서는 모든 자원에 URL이라는 고유한 주소를 부여해 이들을 식별한다
</code></pre></div></div>

<p>URL의 예시를 보겠습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://google.co.kr/search?q=hello&amp;hl=ko

https://order.kyobobook.co.kr/order/orderStepOne
</code></pre></div></div>

<p>URL 문법은 아래와 같습니다.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># URL 문법</span>
scheme://[userinfo@]host[:port][/path][?query][#fragment]

예: https://www.google.com/search?q<span class="o">=</span>hello&amp;hl<span class="o">=</span>ko


<span class="c"># scheme</span>
예: https
- 주로 프로토콜이 사용됩니다.
- 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙 <span class="o">(</span>https, http, ftp<span class="o">)</span>
- 포트가 생략되어 있을 때 https가 사용되면 443포트, http가 사용되면 80포트가 디폴트
- https는 http에 보안 추가 <span class="o">(</span>HTTP Secure<span class="o">)</span>

<span class="c"># host</span>
예: www.google.com
- 도메인명 또는 IP주소

<span class="c"># port</span>
예: 8888
- 접속 포트

<span class="c"># path</span>
예: /search
- 리소스 경로 <span class="o">(</span>계층적 구조<span class="o">)</span>
- 디렉토리명/파일명

<span class="c"># query</span>
예: ?q<span class="o">=</span>hello&amp;hl<span class="o">=</span>ko
- <span class="nv">key</span><span class="o">=</span>value 형태
- ?로 시작, &amp;로 추가 가능
- query parameter 또는 query string으로 보통 불림

<span class="c"># fragment</span>
예: <span class="c">#getting-started-introducing-spring-boot</span>
- html 내부 북마크 등에 사용
- 서버에 전송하는 정보는 아님
</code></pre></div></div>

<p>URL에서 유의할 점은 <strong>URL은 자원을 식별하는 용도로만 써야 한다</strong>는 것입니다. 예를 들어 어떤 물건을 주문할 때는 주문(order)만을 URL로 표현해야지 주문 확인(order-check), 주문 취소(order-cancel) 이런 <strong>행위까지를 포함시키면 안됩니다</strong>.</p>

<h1 id="http-method">HTTP Method</h1>
<p>이러한 <strong>행위를 나타내기 위해 사용하는 것이 바로 HTTP 메소드</strong>입니다.</p>

<p><img src="/images/network_28.png" alt="" /></p>

<p>인터넷에서 발생하는 행위는 크게 CRUD(Create-Read-Update-Delete)로 나눌 수 있습니다. CRUD를 HTTP에서 제공하는 메소드로 구현할 수 있습니다.</p>

<table>
  <tbody>
    <tr>
      <td><strong>HTTP Method</strong></td>
      <td><strong>설명</strong></td>
    </tr>
    <tr>
      <td>GET</td>
      <td>읽기(리소스 조회)</td>
    </tr>
    <tr>
      <td>POST</td>
      <td>쓰기(리소스 등록)</td>
    </tr>
    <tr>
      <td>PUT</td>
      <td>업데이트(리소스 완전 대체)</td>
    </tr>
    <tr>
      <td>PATCH</td>
      <td>부분 업데이트(리소스 부분 대체)</td>
    </tr>
    <tr>
      <td>DELETE</td>
      <td>삭제(리소스 삭제)</td>
    </tr>
  </tbody>
</table>

<p><img src="/images/network_29.png" alt="" /></p>

<h1 id="http-메세지">HTTP 메세지</h1>
<p>클라이언트와 서버는 URL과 HTTP 메소드를 이용해서 HTTP 메세지를 만들어 통신한다고 했습니다. HTTP 메세지는 바이너리로 표현할 수 있는 모든 데이터를 전송할 수 있습니다. (<strong>HTML, TEXT, JSON, XML, 이미지, 영상 파일</strong> 등)</p>

<p>서버간에 데이터를 주고받을 때에도 대부분 HTTP를 사용한다고 합니다.</p>

<p>HTTP 메세지의 구조는 다음과 같습니다.</p>

<p><img src="/images/network_21.png" alt="" width="70%" /></p>

<h2 id="시작-라인">시작 라인</h2>

<h3 id="요청-메세지">요청 메세지</h3>

<ul>
  <li>HTTP 메소드
    <ul>
      <li>종류: GET, POST, PUT, DELETE …</li>
      <li>서버가 수행해야 할 동작 지정
        <ul>
          <li>GET: 리소스 조회</li>
          <li>POST: 요청 내역 처리</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>요청 대상
    <ul>
      <li>절대경로[?쿼리]</li>
      <li>절대경로=”/”로 시작하는 경로</li>
    </ul>
  </li>
  <li>HTTP 버전</li>
  <li>ex. <code class="language-plaintext highlighter-rouge">GET /search?q=hello&amp;hl=ko HTTP/1.1</code></li>
</ul>

<h3 id="응답-메세지">응답 메세지</h3>

<ul>
  <li>HTTP 버전</li>
  <li>HTTP 상태 코드
    <ul>
      <li>200: 성공</li>
      <li>400: 클라이언트 요청 오류</li>
      <li>500: 서버 내부 오류</li>
    </ul>
  </li>
  <li>ex. HTTP/1.1 200 OK</li>
</ul>

<h2 id="http-헤더">HTTP 헤더</h2>

<ul>
  <li>용도
    <ul>
      <li>HTTP 전송에 필요한 모든 부가정보</li>
      <li>메세지 바디의 내용, 메세지 바디의 크기, 압축, 클라이언트 정보, ..</li>
    </ul>
  </li>
  <li>표현(Representation) 헤더
    <ul>
      <li>요청/응답 공통 항목</li>
      <li><strong>Content-Type</strong>: 표현 데이터의 형식
        <ul>
          <li>리소스를 어떤 형식으로 표현할 것인가</li>
          <li>ex. <code class="language-plaintext highlighter-rouge">text/html; charset=utf-8</code>, <code class="language-plaintext highlighter-rouge">application/json</code>, <code class="language-plaintext highlighter-rouge">image/png</code></li>
        </ul>
      </li>
      <li><strong>Content-Encoding</strong>: 표현 데이터의 압축 방식
        <ul>
          <li>표현 데이터를 압축하기 위해 사용</li>
          <li>데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가</li>
          <li>데이터를 읽는 곳에서 헤더 정보를 보고 압축 해제</li>
          <li>ex. <code class="language-plaintext highlighter-rouge">gzip</code>, <code class="language-plaintext highlighter-rouge">deflate</code>, <code class="language-plaintext highlighter-rouge">identity</code></li>
        </ul>
      </li>
      <li><strong>Content-Language</strong>: 표현 데이터의 자연 언어
        <ul>
          <li>ex. ko, en, en-US</li>
        </ul>
      </li>
      <li><strong>Content-length</strong>: 표현 데이터의 길이
        <ul>
          <li>바이트 단위</li>
        </ul>
      </li>
      <li><strong>Last-Modified</strong>: 리소스를 마지막으로 갱신한 일시</li>
      <li><strong>Location</strong>: 페이지 리다이렉션(redirect)
        <ul>
          <li>리소스가 리다이렉트(redirect)된 때에 이동된 주소, 또는 새로 생성된 리소스 주소</li>
          <li>3xx 응답이나 201 Created 응답일 때 어느 페이지로 이동할지를 알려주는 헤더</li>
          <li>201: 요청에 의해 생성된 리소스 URL</li>
          <li>3xx: 요청을 자동으로 리다이렉션하기 위한 대상 리소스 URL</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="요청-메세지-1">요청 메세지</h3>

<ul>
  <li>요청(Request) 헤더
    <ul>
      <li><strong>Host</strong>: 요청하는 호스트에 대한 호스트명 및 포트번호 (필수값)
        <ul>
          <li>하나의 서버가 여러 도메인을 처리해야 할 때</li>
          <li>하나의 IP 주소에 여러 도메인이 적용되어 있을 때</li>
        </ul>
      </li>
      <li><strong>User-Agent</strong>: 클라이언트의 웹/애플리케이션 정보
        <ul>
          <li>어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능</li>
        </ul>
      </li>
      <li><strong>Referer</strong>: 현재 요청된 페이지의 이전 페이지 주소
        <ul>
          <li>이를 이용해 유입 경로 분석 가능</li>
        </ul>
      </li>
      <li><strong>Authorization</strong>: 클라이언트 인증 정보를 서버에 전달
        <ul>
          <li>인증 토큰(JWT/Bearer 토큰)을 서버로 보낼 때 사용하는 헤더</li>
          <li>토큰의 종류(Basic, Bearer 등) + 실제 토큰 문자를 전송</li>
        </ul>
      </li>
      <li><strong>Cookie</strong>: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달
        <ul>
          <li>서버에 의해 Set-Cookie로 클라이언트에게 설정된 쿠키 정보</li>
        </ul>
      </li>
      <li><strong>If-Modified-Since</strong>: 캐시 데이터의 유효성을 검증하기 위한 헤더
        <ul>
          <li>이 값보다 더 큰 값을 가지는 데이터만 서버로부터 받아옴</li>
          <li>이 값과 같으면 서버 데이터가 캐시와 비교해 업데이트 되지 않았으므로 캐시 데이터 사용</li>
        </ul>
      </li>
      <li><strong>If-None-Match</strong>: ETag 값을 전달해 캐시 데이터를 사용할지, 서버로 부터 새로 받아올지 결정</li>
    </ul>
  </li>
  <li>ex. Host: www.google.com</li>
</ul>

<p><img src="/images/http_header_1.png" alt="" /></p>

<h3 id="응답-메세지-1">응답 메세지</h3>

<ul>
  <li>응답(Response) 헤더
    <ul>
      <li><strong>Server</strong>: 요청을 처리하는 Origin 서버의 소프트웨어 정보
        <ul>
          <li>캐시, 프록시 서버 아닌 Origin 서버</li>
        </ul>
      </li>
      <li><strong>Set-Cookie</strong>: 서버에서 클라이언트로 쿠키 전달
        <ul>
          <li>서버측에서 클라이언트에게 세션 쿠키 정보를 설정</li>
          <li><code class="language-plaintext highlighter-rouge">max-age</code>, <code class="language-plaintext highlighter-rouge">expires</code>와 같은 옵션 있음</li>
        </ul>
      </li>
      <li><strong>Age</strong>: 캐시 응답. <code class="language-plaintext highlighter-rouge">max-age</code> 시간 내에서 얼마나 흘렀는지 알려줌(초 단위)</li>
      <li><strong>ETag</strong>: 리소스에 붙은 고유한 태그
        <ul>
          <li>이를 이용해 캐시 데이터의 유효성을 검사할 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>ex. Content-type: ‘text/plain;charset=UTF-8’, Content-length: 3423</li>
</ul>

<h2 id="http-바디">HTTP 바디</h2>

<ul>
  <li>실제 전송할 데이터</li>
  <li>HTML, 이미지, 영상, JSON 등 byte로 표현 가능한 모든 데이터 전송 가능</li>
</ul>

<p>이렇게 HTTP 메세지를 통해서 두 단말기가 응용계층에서 쉽게 통신할 수 있도록 하는 API(Application Program Interface)를 <strong>REST(Representational State Transfer) API</strong>라고 합니다.</p>

<h2 id="예시">예시</h2>

<h3 id="요청-메세지-2">요청 메세지</h3>

<p><img src="/images/network_22.png" alt="" width="70%" /></p>

<h3 id="응답-메세지-2">응답 메세지</h3>

<p><img src="/images/network_23.png" alt="" width="70%" /></p>

<h1 id="http-상태코드">HTTP 상태코드</h1>

<h1 id="쿠키-캐시-프록시-세션">쿠키, 캐시, 프록시, 세션</h1>

<h2 id="쿠키">쿠키</h2>

<ul>
  <li>HTTP는 무상태 프로토콜</li>
  <li>클라이언트와 서버가 요청과 응답을 주고 받고나면 연결이 끊어짐</li>
  <li>클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못함</li>
  <li>클라이언트와 서버는 서로 상태를 유지하지 않음</li>
  <li>(사실은 Persistent Connection 덕분에 이렇게 매정하진 않음)</li>
  <li>이 문제를 해결하기 위해 매 요청마다 필요한 정보를 누적 전송하게 되면? -&gt; 성능도 떨어지고 개발도 힘들어짐</li>
  <li>이 때 사용하는 것이 쿠키</li>
  <li>쿠키는 사용자 로그인 세션 관리, 광고 정보 트래킹과 같은 곳에 많이 사용</li>
  <li>쿠키 정보는 항상 서버에 전달 -&gt; 네트워크 트래픽량 증가 -&gt; 최소한만 사용(세션id, 인증 토큰)</li>
  <li>쿠키 생명 주기는 <code class="language-plaintext highlighter-rouge">Set-Cookie</code>의 <code class="language-plaintext highlighter-rouge">expires</code> 또는 <code class="language-plaintext highlighter-rouge">max-age</code> 옵션으로 관리</li>
</ul>

<p><img src="/images/cookie_1.png" alt="" /></p>

<h2 id="캐시">캐시</h2>

<ul>
  <li>캐시가 없다면, 같은 데이터를 요청하더라도 매번 서버에서 데이터를 응답 받아야 하기 때문에 네트워크 비용이 아깝게 느껴짐</li>
  <li>이러한 네트워크 비용을 줄이고자 캐시가 등장</li>
  <li>응답 메세지의 <code class="language-plaintext highlighter-rouge">cache-control</code>의 <code class="language-plaintext highlighter-rouge">max-age</code> 옵션으로 캐시 생명주기 관리 -&gt; <code class="language-plaintext highlighter-rouge">max-age</code> 초과시 캐시만료</li>
  <li>(캐시만료는 캐시가 삭제되었다는 뜻이 아니라, 캐시된 데이터가 더 이상 유효하지 않다는 의미)</li>
  <li>캐시가 만료되면 다시 전체 데이터를 서버에서 받을 수도 있지만, 데이터에 변경 사항이 있는 경우에만 서버에서 받는 최적화 가능</li>
  <li>-&gt; 검증 헤더와 조건부 요청 -&gt; 캐시 데이터와 서버 데이터의 최종 수정일이 같은지</li>
  <li>요청 메세지 보낼 때, 헤더에 <code class="language-plaintext highlighter-rouge">if-modified-since</code>의 값으로, 캐시에 저장할 때 서버가 보낸 <code class="language-plaintext highlighter-rouge">Last-Modified</code> 값을 사용해,</li>
  <li>서버에 <code class="language-plaintext highlighter-rouge">Last-Modified</code> 값 이후로 데이터가 수정된 적이 있는지 물어봄
    <ul>
      <li>변경된 적 없다면(304 Not Modified) -&gt; 응답 메세지에 헤더만 있고 메세지 바디는 x -&gt; 네트워크 비용 감소</li>
      <li>데이터가 변경되었다면(200 OK) -&gt; 모든 데이터 전송</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Last-Modified</code>와 <code class="language-plaintext highlighter-rouge">if-modified-since</code> 조합의 한계점: A-&gt;B-&gt;A로 변경되도 변경된 데이터로 인식</li>
  <li><code class="language-plaintext highlighter-rouge">ETag</code>와 <code class="language-plaintext highlighter-rouge">If-None-Match</code> 조합 사용
    <ul>
      <li>데이터마다 고유한 <code class="language-plaintext highlighter-rouge">ETag</code> 부여해서 캐시에 저장</li>
      <li>클라이언트가 요청한 데이터가 캐시 만료된 경우 데이터의 <code class="language-plaintext highlighter-rouge">ETag</code> 값을 헤더에 담아 전송 (If-None-Match: “ETag값”)</li>
      <li>만약 매칭되는 경우, 캐시에서 데이터 가져옴 (캐시만료는 캐시에서 삭제되었다는 의미 아님. 데이터 유효성 검증이 필요하다는 의미)</li>
      <li>매칭되는 <code class="language-plaintext highlighter-rouge">ETag</code> 값이 없으면 서버는 <code class="language-plaintext highlighter-rouge">ETag</code> 값 말고 메세지의 시작 라인의 URL에 기반해 데이터를 클라이언트에 전달</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cache-Control 옵션
- max-age: 캐시 유효 시간. 초단위
- no-cache: 캐시를 사용하지만, 그 전에 항상 Origin 서버에 검증하고 사용 (ETag, Last-Modified 이런 것들 써서)
- no-store: 메모리에서만 사용하고 삭제
</code></pre></div></div>

<ul>
  <li>클라이언트가 보낸 요청 메세지는 보통 프록시 캐시 서버로 먼저 전달되고 없으면 Origin 서버로 전달</li>
</ul>

<p><img src="/images/cache_1.png" alt="" /></p>

<h1 id="웹-브라우저의-동작원리">웹 브라우저의 동작원리</h1>
<p>우리가 웹 브라우저(크롬, 사파리 등)에서 뉴스 보기를 클릭하거나 유튜브 비디오를 시청할 때 내부적으로 어떤 일들이 일어나는지 한 번 알아보겠습니다.</p>

<h2 id="http-리퀘스트-작성">HTTP 리퀘스트 작성</h2>
<p>우리는 보통 웹 브라우저에서 URL을 입력하거나 어떤 버튼을 클릭하는 식으로 웹 서버와 상호작용 하게 되는데 이 때 <strong>웹 브라우저는 내부에서 HTTP 리퀘스트라는 것을 웹 서버에 전송</strong>합니다.</p>

<h3 id="url-입력">URL 입력</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://www.google.com/search?q=hello&amp;hl=ko
</code></pre></div></div>

<h3 id="http-리퀘스트-작성-1">HTTP 리퀘스트 작성</h3>
<p>URL을 입력하고 나면 웹 브라우저는 URL을 바탕으로 HTTP 리퀘스트 메시지를 만듭니다.<br />
HTTP 리퀘스트 메시지의 형태는 다음과 같습니다.<br />
<img src="../../images/network_1.jpeg" alt="" /><br />
<a href="https://joie-kim.github.io/HTTP/" target="_blank">(joie-kim님 블로그 참고)</a></p>

<h2 id="dns-서버에-웹-서버의-ip주소-조회">DNS 서버에 웹 서버의 IP주소 조회</h2>
<p>HTTP 리퀘스트를 작성하고 나면 이제 OS에게 이것을 웹 서버로 전송해달라고 요청합니다. (웹 브라우저가 직접 전송하지 않는 이유는 메시지를 송신하는 기능은 하나의 애플리케이션에만 종속되는 기능이 아니므로 OS에서 전송 기능을 담당하는 것이 더 좋다고 합니다.)</p>

<p>OS에서는 리퀘스트 메시지를 전송하기 전에 먼저 <strong>도메인 네임을 IP 주소로 변환</strong>하는 과정을 거칩니다. 이를 <strong>네임 레졸루션(name resolution)</strong>이라고 합니다.</p>

<h3 id="dns-resolver를-이용해-dns-서버-조회">DNS Resolver를 이용해 DNS 서버 조회</h3>
<p>네임 레졸루션을 시행하는 것이 <strong>DNS 리졸버(DNS Resolver)</strong>입니다.</p>

<p><img src="/images/dns-resolver_1.webp" alt="" /></p>

<h2 id="프로토콜-스택에-메시지-송신-요청">프로토콜 스택에 메시지 송신 요청</h2>
<p>DNS Resolver가 IP주소를 찾아오면 이제 진짜 웹 서버로 보낼 준비가 완료되었습니다. 이렇게 준비된 HTTP Request 메시지는 OS의 내부에 포함된 프로토콜 스택을 호출하여 실행을 요청합니다.</p>

<p><img src="../../images/network_3.png" alt="" /></p>

<h1 id="https">HTTPS</h1>

<ul>
  <li>SSL(Secure Socket Layer)</li>
</ul>

<p><img src="/images/https_1.png" alt="" /></p>

<h1 id="참고">참고</h1>
<ul>
  <li><a href="https://www.inflearn.com/course/http-웹-네트워크/dashboard" target="_blank">인프런에서 제공하는 이영한님의 모든 개발자를 위한 HTTP 웹 기본 지식 강의</a></li>
  <li><a href="https://www.cloudflare.com/ko-kr/learning/dns/what-is-dns/" target="_blank">CLOUDFLARE, What is DNS?</a></li>
  <li><a href="https://restfulapi.net/resource-naming/" target="_blank">REST 논문을 정리한 자료</a></li>
  <li><a href="https://sabarada.tistory.com/27" target="_blank">사바라다는 차곡차곡: [REST API] REST에서의 Resource</a></li>
</ul>
:ET