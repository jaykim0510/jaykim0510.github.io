I"<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#graph" id="markdown-toc-graph">Graph</a>    <ul>
      <li><a href="#그래프의-정의" id="markdown-toc-그래프의-정의">그래프의 정의</a></li>
      <li><a href="#트리와-그래프의-차이" id="markdown-toc-트리와-그래프의-차이">트리와 그래프의 차이</a>        <ul>
          <li><a href="#트리" id="markdown-toc-트리">트리</a></li>
          <li><a href="#그래프" id="markdown-toc-그래프">그래프</a></li>
          <li><a href="#신장-트리spanning-tree" id="markdown-toc-신장-트리spanning-tree">신장 트리(Spanning Tree)</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#graph와-관련한-문제-유형" id="markdown-toc-graph와-관련한-문제-유형">Graph와 관련한 문제 유형</a>    <ul>
      <li><a href="#그래프-탐색모든-정점-방문" id="markdown-toc-그래프-탐색모든-정점-방문">그래프 탐색(모든 정점 방문)</a></li>
      <li><a href="#그래프-최단-거리두-정점간-가능한-모든-경로-찾기" id="markdown-toc-그래프-최단-거리두-정점간-가능한-모든-경로-찾기">그래프 최단 거리(두 정점간 가능한 모든 경로 찾기)</a></li>
      <li><a href="#모든-정점에서-다른-모든-정점까지의-최단-경로" id="markdown-toc-모든-정점에서-다른-모든-정점까지의-최단-경로">모든 정점에서 다른 모든 정점까지의 최단 경로</a></li>
      <li><a href="#그래프-분석" id="markdown-toc-그래프-분석">그래프 분석</a></li>
      <li><a href="#최소-신장-트리" id="markdown-toc-최소-신장-트리">최소 신장 트리</a></li>
    </ul>
  </li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<h1 id="graph">Graph</h1>

<h2 id="그래프의-정의">그래프의 정의</h2>

<ul>
  <li>노드(Node)와 노드를 연결하는 간선(Edge)으로 구성된 자료구조</li>
  <li>노드간의 관계를 표현하는데 사용되는 자료구조</li>
</ul>

<h2 id="트리와-그래프의-차이">트리와 그래프의 차이</h2>

<h3 id="트리">트리</h3>

<ul>
  <li>트리는 그래프의 특별한 케이스</li>
  <li>그래프의 정의 + 몇 가지 조건
    <ul>
      <li>그래프의 정의: 노드(Node)와 노드를 연결하는 간선(Edge)으로 구성된 자료구조</li>
      <li>몇 가지 조건
        <ul>
          <li>노드 사이를 연결하는 간선은 모두 1개씩만 존재한다 (노드의 수가 V개 이면, <strong>간선의 수는 V-1</strong>개)</li>
          <li><strong>루트 노드</strong>가 있다 (부모-자식이라는 계층적 관계가 있다, 부모 노드에서 자식 노드라는 방향이 있다)</li>
          <li><strong>비순환</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>위의 내용을 종합해 <strong>트리를 DAG(Directed Acyclic Graph)이라고도 한다</strong></li>
  <li>트리의 종류: 이진트리, 이진탐색트리, 힙트리, B-트리 등</li>
  <li>트리 예시: 회사 조직도</li>
</ul>

<h3 id="그래프">그래프</h3>

<ul>
  <li>트리에는 없는 그래프만의 특징
    <ul>
      <li>순환/비순환으로 구분된다</li>
      <li>방향/무방향으로 구분된다</li>
      <li>간선에 가중치가 있는 경우도 있다</li>
      <li>노드를 잇는 간선이 2개 이상인 경우도 있다</li>
    </ul>
  </li>
  <li>그래프 예시: SNS, 지하철 노선, 지도</li>
  <li>순환/비순환 + 방향/무방향 + 가중치/비가중치 그래프</li>
</ul>

<h3 id="신장-트리spanning-tree">신장 트리(Spanning Tree)</h3>

<ul>
  <li>신장 트리는 그냥 그래프에서 유래된 ‘트리’</li>
  <li>그래프가 주어졌을 떄 V-1개의 간선만 남기고 다른 간선들은 제거한다</li>
  <li>남은 V-1개의 간선으로 이루어진 그래프가 비순환하다면 트리가 된다 -&gt; 이렇게 만들어진 트리를 ‘신장 트리’라고 한다</li>
  <li>1개의 그래프에 1개 이상의 신장 트리가 만들어진다</li>
  <li>가중치 그래프인 경우 남은 간선들의 가중치 합을 최소로 하는 신장 트리를 ‘최소 신장 트리’라고 한다</li>
  <li>신장 트리의 예시: 통신 네트워크 구축</li>
</ul>

<p><img src="/images/graph_1.png" alt="" /></p>

<h1 id="graph와-관련한-문제-유형">Graph와 관련한 문제 유형</h1>

<h2 id="그래프-탐색모든-정점-방문">그래프 탐색(모든 정점 방문)</h2>

<ul>
  <li>그래프에서 사용하는 탐색 알고리즘
    <ul>
      <li><strong>DFS(Depth First Search)</strong>
        <ul>
          <li>재귀함수 또는 반복문으로 구현</li>
          <li>연관 키워드: Preorder, Top-Down</li>
        </ul>
      </li>
      <li><strong>BFS(Breadth First Search)</strong>
        <ul>
          <li>반복문으로 구현</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>트리에서 사용하는 탐색 알고리즘
    <ul>
      <li>Preorder</li>
      <li>Inorder</li>
      <li>Postorder</li>
      <li>3가지 모두 재귀함수, 반복문으로 구현</li>
      <li>재귀함수로 구현할 때 Top-Down과 Bottom-Up approach 있음</li>
    </ul>
  </li>
</ul>

<h2 id="그래프-최단-거리두-정점간-가능한-모든-경로-찾기">그래프 최단 거리(두 정점간 가능한 모든 경로 찾기)</h2>

<ul>
  <li>최단 경로에서 사용하는 알고리즘
    <ul>
      <li>그래프 탐색 알고리즘와 마찬가지로 <strong>DFS</strong>, <strong>BFS</strong></li>
      <li>시간 복잡도 낮추기 위해 백트래킹(<strong>Backtracking</strong>) 추가 가능
        <ul>
          <li>(특별한 것 아니고 그냥 가지치기)</li>
          <li>(중간에 조건을 만족하지 않게 되면 탐색 중단)</li>
        </ul>
      </li>
      <li>가중치 있는 그래프의 최단 경로 알고리즘
        <ul>
          <li><strong>Dijkstra</strong> 알고리즘</li>
          <li>음의 가중치 가지는 경우: <strong>Bellman-Ford</strong> 알고리즘</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="모든-정점에서-다른-모든-정점까지의-최단-경로">모든 정점에서 다른 모든 정점까지의 최단 경로</h2>

<ul>
  <li>모든 정점들간의 경로중 최단 경로 찾는 알고리즘
    <ul>
      <li><strong>Floyd-Warshall</strong> 알고리즘 (DP와 연관)</li>
    </ul>
  </li>
</ul>

<h2 id="그래프-분석">그래프 분석</h2>

<ul>
  <li>Disjoint Set (or Union-FInd)
    <ul>
      <li>Union-Find라고도 불리는 이유는 Disjoint Set 자료구조가 가지는 가장 중요한 메소드가 union과 find</li>
      <li>용도
        <ul>
          <li>두 노드가 서로 연결되어 있는가</li>
          <li>Detect Cycle: 그래프가 순환 그래프인가
            <ul>
              <li>현재 선택된 엣지로 연결된 두 노드가, 하나의 집합이라면(서로 연결되어 있다면)</li>
              <li>이 엣지를 선택하게 되면 그래프는 순환 그래프가 된다</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>구현 방법
        <ul>
          <li>Quick Union</li>
          <li>Quick Find</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="최소-신장-트리">최소 신장 트리</h2>
<ul>
  <li>최소 신장 트리에서 사용하는 알고리즘
    <ul>
      <li><strong>Kruskal</strong> 알고리즘 (Union-Find와 관련)</li>
    </ul>
  </li>
</ul>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="https://gusrb3164.github.io/computer-science/2021/04/16/graph,tree/" target="_blank">HyeonGyu, 그래프와 트리의 정의 및 차이점</a></li>
  <li><a href="https://www.geeksforgeeks.org/union-find/" target="_blank">GeeksforGeeks, Disjoint Set</a></li>
</ul>
:ET