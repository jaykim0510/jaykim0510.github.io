I" 7<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#분산-시스템이란" id="markdown-toc-분산-시스템이란">분산 시스템이란</a></li>
  <li><a href="#장점" id="markdown-toc-장점">장점</a>    <ul>
      <li><a href="#performance" id="markdown-toc-performance">Performance</a></li>
      <li><a href="#scalability" id="markdown-toc-scalability">Scalability</a></li>
      <li><a href="#availability" id="markdown-toc-availability">Availability</a></li>
    </ul>
  </li>
  <li><a href="#필요한-것" id="markdown-toc-필요한-것">필요한 것</a>    <ul>
      <li><a href="#partitioning" id="markdown-toc-partitioning">Partitioning</a></li>
      <li><a href="#replication" id="markdown-toc-replication">Replication</a></li>
    </ul>
  </li>
  <li><a href="#어려운-점" id="markdown-toc-어려운-점">어려운 점</a>    <ul>
      <li><a href="#synchronization" id="markdown-toc-synchronization">Synchronization</a>        <ul>
          <li><a href="#clock-synchronization" id="markdown-toc-clock-synchronization">Clock Synchronization</a></li>
          <li><a href="#data-synchronization" id="markdown-toc-data-synchronization">Data Synchronization</a></li>
        </ul>
      </li>
      <li><a href="#network-asynchrony" id="markdown-toc-network-asynchrony">Network Asynchrony</a></li>
      <li><a href="#partial-failures" id="markdown-toc-partial-failures">Partial Failures</a></li>
    </ul>
  </li>
  <li><a href="#극복" id="markdown-toc-극복">극복</a></li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<h1 id="분산-시스템이란">분산 시스템이란</h1>

<blockquote>
  <p>A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another</p>
</blockquote>

<p><img src="/images/dis_sys_2.png" alt="" /></p>

<p>나는 분산 시스템을 다음과 같은 맥락으로 정리하려고 한다.</p>

<p><img src="/images/dis_sys_1.png" alt="" /></p>

<h1 id="장점">장점</h1>

<h2 id="performance">Performance</h2>

<p>여기서 Performance는 단일 시스템에서의 Performance와 비교해 가격대비 더 낫다는 의미이다. Performance의 절대적인 수치 자체가 더 오를 이유는 없다. 오히려 네트워크 비용으로 감소할 가능성은 있다. 그럼에도 분산 시스템을 쓰는 이유는 가격적인 측면에서 그만큼 값싼 장비를 여러 대 사용하는 것이 낫고, 성능적인 측면 이외에도 분산 시스템이 주는 장점이 있기 때문이다.</p>

<h2 id="scalability">Scalability</h2>

<p>분산 시스템은 서비스 규모, 트래픽량, 작업량에 따라 시스템의 크기를 조절해 이를 핸들링할 능력이 있다. 물론 단일 시스템에서도 Vertical-scaling이 가능하다. 하지만 Horizontal-scaling이 가격적인 측면과 확장이 용이하다는 점에서 이점이 있다.</p>

<h2 id="availability">Availability</h2>

<p>분산 시스템은 노드 일부에 장애가 발생하더라도 계속 같은 기능을 유지할 수 있다. 이는 24시간 내내 장애없는 서비스가 가능하다는 말이다. 물론 이를 위해 요구되는 조건들이 있는데 이 부분은 뒤에서 더 자세히 다룰 것이다.</p>

<p>지금까지 분산 시스템의 장점에 대해서 얘기했다. 이러한 장점을 얻기위해 해야할 일이 있다. 우선 High-level에서 이에 대해 알아보겠다.</p>

<h1 id="필요한-것">필요한 것</h1>

<h2 id="partitioning">Partitioning</h2>

<p>파티셔닝은 분산 시스템의 장점 중에서도 Scalability, Performance를 얻기 위해 필요한 핵심이다. 파티셔닝은 처리(또는 저장)해야 할 데이터를 작게 나누어서 이를 처리(또는 저장)해야 할 노드에게 할당해주는 작업이다.</p>

<p>하지만 오히려 하나의 작업을 위해 네트워크를 거쳐 여러 노드에 접근해야 한다는 점에서 단점이 되는 경우도 있다. 그래서 데이터를 처리할 때는 최대한 네트워크 비용을 줄이는 것이 관건이다.</p>

<p>파티셔닝은 크게 range partitioning, hash partitioning, consistent hashing가 있다. Apache HBase는 range partitioning을 쓰고, Apache Cassandra는 consistent hasing을 쓴다.</p>

<h2 id="replication">Replication</h2>

<p>복제(Replication)는 Availability를 위해 필요한 핵심이다. 복제는 같은 데이터를 여러 노드에 복수 저장함으로써, 노드 중 일부에 장애가 발생하더라도 계속 역할을 유지할 수 있게 한다.</p>

<p>복제하는 것이 단순한 일은 아니다. 우선 복제 수 만큼 더 많은 저장용량이 필요하다. 또한 복사된 후에도 원본 데이터가 업데이트 될 때마다 동기화해야 한다.</p>

<p>복제 방법 중 하나인 primary-backup replication에 대해 알아보자.</p>

<p>We commonly refer to the remaining replicas as followers or secondaries. These can only handle read requests. Every time the leader receives an update, it executes it locally and also propagates the update to the other nodes. This ensures that all the replicas maintain a consistent view of the data.</p>

<p><img src="/images/dis_sys_4.png" alt="" /></p>

<p>리더는 업데이트를 어떻게 팔로워들에게 전파할까</p>

<p>There are two ways to propagate the updates: synchronously and asynchronously.</p>

<p>Synchronous replication</p>

<p>In synchronous replication, the node replies to the client to indicate the update is complete—only after receiving acknowledgments from the other replicas that they’ve also performed the update on their local storage. This guarantees that the client is able to view the update in a subsequent read after acknowledging it, no matter which replica the client reads from.</p>

<p>Furthermore, synchronous replication provides increased durability. This is because the update is not lost even if the leader crashes right after it acknowledges the update.</p>

<p>However, this technique can make writing requests slower. This is because the leader has to wait until it receives responses from all the replicas.</p>

<p><img src="/images/dis_sys_3.png" alt="" /></p>

<p>Asynchronous replication</p>

<p>In asynchronous replication, the node replies to the client as soon as it performs the update in its local storage, without waiting for responses from the other replicas.</p>

<p>This technique increases performance significantly for write requests. This is because the client no longer pays the penalty of the network requests to the other replicas.</p>

<p>However, this comes at the cost of reduced consistency and decreased durability. After a client receives a response for an update request, the client might read older (stale) values in a subsequent read. This is only possible if the operation happens in one of the replicas that have not yet performed the update. Moreover, if the leader node crashes right after it acknowledges an update, and the propagation requests to the other replicas are lost, any acknowledged update is eventually lost.</p>

<p><img src="/images/dis_sys_5.png" alt="" /></p>

<p>Most widely used databases, such as PostgreSQL or MySQL, use a primary-backup replication technique that supports both asynchronous and synchronous replication.</p>

<p>primary-backup replication에는 장점과 단점이 있습니다.</p>

<p>장점</p>

<ul>
  <li>It is simple to understand and implement</li>
  <li>Concurrent operations serialized in the leader node, remove the need for more complicated, distributed concurrency protocols. In general, this property also makes it easier to support transactional operations</li>
  <li>It is scalable for read-heavy workloads, because the capacity for reading requests can be increased by adding more read replicas</li>
</ul>

<p>단점</p>

<ul>
  <li>It is not very scalable for write-heavy workloads, because a single node (the leader)’s capacity determines the capacity for writes</li>
  <li>It imposes an obvious trade-off between performance, durability, and consistency</li>
  <li>Scaling the read capacity by adding more follower nodes can create a bottleneck in the network bandwidth of the leader node, if there’s a large number of followers listening for updates</li>
  <li>The process of failing over to a follower node when the leader node crashes, is not instant. This may create some downtime and also introduce the risk of errors</li>
</ul>

<p>또한 primary-backup replication은 항상 리더가 존재해야 한다. 따라서 리더가 잘 살아있는지 체크하고, 리더가 죽었다면 리더를 새로 선출하는 Leader election 문제도 고려해야 한다.</p>

<h1 id="어려운-점">어려운 점</h1>

<h2 id="synchronization">Synchronization</h2>

<h3 id="clock-synchronization">Clock Synchronization</h3>

<p>Distributed System is a collection of computers connected via the high speed communication network. In the distributed system, the hardware and software components communicate and coordinate their actions by message passing. Each node in distributed systems can share their resources with other nodes. So, there is need of proper allocation of resources to preserve the state of resources and help coordinate between the several processes. To resolve such conflicts, synchronization is used. Synchronization in distributed systems is achieved via clocks.</p>

<p>The physical clocks are used to adjust the time of nodes.Each node in the system can share its local time with other nodes in the system. The time is set based on UTC (Universal Time Coordination). UTC is used as a reference time clock for the nodes in the system.</p>

<p>The clock synchronization can be achieved by 2 ways: External and Internal Clock Synchronization.</p>

<ul>
  <li>External clock synchronization is the one in which an external reference clock is present. It is used as a reference and the nodes in the system can set and adjust their time accordingly.</li>
  <li>Internal clock synchronization is the one in which each node shares its time with other nodes and all the nodes set and adjust their times accordingly.</li>
</ul>

<p>There are 2 types of clock synchronization algorithms: Centralized and Distributed.</p>

<ul>
  <li>Centralized is the one in which a time server is used as a reference. The single time server propagates its time to the nodes and all the nodes adjust the time accordingly. It is dependent on single time server so if that node fails, the whole system will lose synchronization. Examples of centralized are- Berkeley Algorithm, Passive Time Server, Active Time Server etc.</li>
  <li>Distributed is the one in which there is no centralized time server present. Instead the nodes adjust their time by using their local time and then, taking the average of the differences of time with other nodes. Distributed algorithms overcome the issue of centralized algorithms like the scalability and single point failure. Examples of Distributed algorithms are – Global Averaging Algorithm, Localized Averaging Algorithm, NTP (Network time protocol) etc.</li>
</ul>

<h3 id="data-synchronization">Data Synchronization</h3>

<p>데이터 동기화 문제는 위에서 말했던 데이터 복제 과정에서, 그리고 업데이트시 복제된 데이터들간의 동기화를 말한다. 또한 트랜잭션과 같이 ACID 특성이 요구될 때, 데이터들이 Atomic하게 처리되는지와도 관련된다.</p>

<h2 id="network-asynchrony">Network Asynchrony</h2>

<p>Network asynchrony is a property of communication networks that cannot provide strong guarantees around delivering events, e.g., a maximum amount of time a message requires for delivery. This can create a lot of counter-intuitive behaviors that are not present in non-distributed systems. This contrasts to memory operations that provide much stricter guarantees. For instance, messages might take extremely long to deliver in a distributed system. They may even deliver out of order—or not at all.</p>

<ul>
  <li>분산 시스템을 이용한 인터넷 서비스에서 사용하는 어플리케이션의 아키텍처는 대부분 비공유 아키텍처(Shared-nothing)
    <ul>
      <li>각 노드는 CPU, RAM, 디스크를 독립적으로 사용(디스크도 독립된다는 점에서 Shared Disk Architecture와 다름)</li>
    </ul>
  </li>
  <li>비공유 시스템에서 장비들이 통신하는 유일한 수단은 네트워크</li>
  <li>전송 측은 패킷이 전송 된건지, 네트워크 문제인지, 수신 측 서버 문제인지 알 수 없으며 심지어 전달이 실패한건지 아니면 지연된건지 조차 알 수 없음</li>
</ul>

<p><img src="/images/dist_3.png" alt="" /></p>

<h2 id="partial-failures">Partial Failures</h2>

<p>Partial failures are the cases where only some components of a distributed system fail. This behavior can contrast with certain kinds of applications a single server deploys. These applications work under the assumption that either everything is working fine, or there has been a server crash. It introduces significant complexity when it requires atomicity across components in a distributed system. Thus, we must ensure that we either apply an operation to all the nodes of a system, or to none of them.</p>

<p><img src="/images/dis_sys_7.png" alt="" /></p>

<h1 id="극복">극복</h1>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="http://thesecretlivesofdata.com/raft/" target="_blank">Video Demo,  Raft: Understandable Distributed Consensus</a></li>
  <li><a href="https://www.freecodecamp.org/news/in-search-of-an-understandable-consensus-algorithm-a-summary-4bc294c97e0d/" target="_blank">Understanding the Raft consensus algorithm: an academic article summary</a></li>
  <li><a href="https://bravenewgeek.com/building-a-distributed-log-from-scratch-part-2-data-replication/" target="_blank">Building a Distributed Log from Scratch, Part 2: Data Replication</a></li>
</ul>
:ET