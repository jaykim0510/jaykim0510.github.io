I"<h1 id="fault-tolerance-in-kafka">Fault tolerance in Kafka</h1>
<p>카프카는 데이터 파이프라인의 중앙에 위치하는 메인 허브 역할을 합니다. 그래서 만약 하드웨어의 문제나 네트워크의 장애로 인해 정상적으로 동작하지 못한다면, 카프카에 연결된 모든 파이프라인에 심각한 영향을 미치게 됩니다. 이러한 이유로 카프카는 초기 설계 단계에서부터 장애가 발생하더라도 안정적인 서비스를 제공할 수 있도록 구상됐습니다.</p>

<h2 id="카프카-리플리케이션replication">카프카 리플리케이션(Replication)</h2>
<p>카프카는 데이터를 저장할 때 하나의 브로커에만 저장하지 않고, <code class="language-plaintext highlighter-rouge">다른 브로커에 파티션을 복제</code>해놓음으로써 임의의 브로커 장애에 대비할 수 있습니다. 만약 N개의 리플리케이션이 있을 경우, N-1개의 브로커에 장애가 발생하더라도 손실되지 않고 데이터를 주고 받을 수 있습니다.</p>

<p>그런데 만약 같은 데이터를 여러 브로커에서 읽게되면 어떻게 될까요? 아마 불필요한 데이터 전송으로 처리량이 낮아지고, 중복 처리를 해야하는 불필요한 오버헤드가 생길 것입니다. 이런 문제를 해결하고자 카프카에는 <code class="language-plaintext highlighter-rouge">리더와 팔로워</code>가 있습니다.</p>

<p><img src="/images/kafka_14.png" alt="" />
<a href="https://medium.com/@anchan.ashwithabg95/fault-tolerance-in-apache-kafka-d1f0444260cf">(shwitha B G 블로그 참고)</a></p>

<h2 id="리더leader와-팔로워follower">리더(Leader)와 팔로워(Follower)</h2>
<p>카프카는 내부적으로 리플리케이션들을 리더와 팔로워로 구분하고, 파티션에 대한 쓰기와 읽기는 모두 리더 파티션을 통해서만 가능합니다. 다시 말해, 프로듀서는 리더 파티션에만 메시지를 전송하고, 컨슈머도 리더를 통해서만 메시지를 가져옵니다.</p>

<p><img src="/images/kafka_15.png" alt="" /></p>

<p>그렇다면 팔로워는 어떤 역할을 할까요? 팔로워는 리더에 문제가 발생할 경우를 대비해 언제든지 새로운 리더가 될 수 있도록 준비를 하고 있어야합니다. 그러기 위해 팔로워들은 리더에게 새로운 메시지가 있는지 요청하고 있다면 메시지를 리더로부터 복제합니다.</p>

<h2 id="컨트롤러controller">컨트롤러(Controller)</h2>
<p>리더를 뽑기 위해서는 리더 선정을 담당하는 무엇인가가 카프카 클러스터에 있어야 합니다. 여기서 <code class="language-plaintext highlighter-rouge">컨트롤러</code>라는 개념이 등장합니다. 컨트롤러는 카프카 클러스터 중 하나의 브로커가 컨트롤러 역할을 하게됩니다. 그래서 이러한 역할을 하는 브로커를 컨트롤러 브로커라고도 합니다.</p>

<p><img src="/images/kafka_16.png" alt="" /><br />
<a href="https://medium.com/@anchan.ashwithabg95/fault-tolerance-in-apache-kafka-d1f0444260cf">(shwitha B G 블로그 참고)</a></p>

<p>컨트롤러가 새로운 리더를 임명하는 과정을 살펴보겠습니다. <code class="language-plaintext highlighter-rouge">주키퍼(Zookeeper)</code> 개념이 잠깐 등장합니다.<br />
(<code class="language-plaintext highlighter-rouge">Zookeeper</code> is the centralized service for storing metadata of topic, partition, and broker)</p>
<ul>
  <li>주키퍼는 카프카의 모든 브로커들과 하트비트(Heartbeat)를 주고 받으며 브로커가 살아있는지 체크합니다.</li>
  <li>브로커와 관련하여 어떤 이벤트가 발생하면 주키퍼는 이를 감지하고 자신을 subscribe하고 있는 브로커들에게 알립니다</li>
  <li>컨트롤러는 알림을 받고 어떤 파티션을 새로운 리더로 임명할지 결정합니다.</li>
  <li>컨트롤러는 어떤 브로커가 새로운 리더를 할당받을지 결정하고, 파티션을 리밸런싱합니다.</li>
</ul>

<h2 id="리플리케이션-과정">리플리케이션 과정</h2>
<p>마지막으로 리더와 팔로워간의 리플리케이션 과정을 살펴보고 포스트를 마치도록 하겠습니다.<br />
먼저 리더와 팔로워에 대해 조금 더 알아보겠습니다. 리더와 몇몇의 팔로워는 <code class="language-plaintext highlighter-rouge">ISR(InSyncReplica)</code>이라는 논리적 그룹으로 묶여 있습니다. 이렇게 ISR 그룹안에 속하는 팔로워만이 리더가 될 수 있는 후보입니다.<br />
ISR 내의 팔로워들은 리더와의 데이터를 일치시키기 위해 지속적으로 리더의 데이터를 따라가게 되고, 리더는 ISR내의 팔로워가 모두 메세지를 받을 때까지 기다립니다.</p>

<p>그러나 만약 팔로워를 가지는 브로커가 장애로 데이터를 리플리케이션하지 못하게 되면 더이상 리더와의 데이터가 일치하지 않게되므로 해당 파티션은 ISR 그룹에서 제외되게 됩니다. (리더 파티션을 가지는 브로커에 장애가 발생하면 리더 재선출 및 파티션 재할당, 팔로워의 경우 ISR그룹에서 제외)</p>

<h1 id="참고자료">참고자료</h1>
<ul>
  <li><a href="https://hackernoon.com/apache-kafkas-distributed-system-firefighter-the-controller-broker-1afca1eae302">Hackernoon 블로그</a></li>
  <li><a href="https://medium.com/@anchan.ashwithabg95/fault-tolerance-in-apache-kafka-d1f0444260cf">Ashwitha B G 블로그</a></li>
</ul>
:ET