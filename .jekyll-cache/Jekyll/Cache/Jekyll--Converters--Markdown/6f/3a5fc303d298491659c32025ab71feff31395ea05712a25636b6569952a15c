I"L3<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#connection-client-to-broker" id="markdown-toc-connection-client-to-broker">Connection Client To Broker</a>    <ul>
      <li><a href="#scenario-0-client-and-kafka-running-on-the-same-local-machine" id="markdown-toc-scenario-0-client-and-kafka-running-on-the-same-local-machine">Scenario 0: Client and Kafka running on the same local machine</a></li>
      <li><a href="#scenario-1-client-and-kafka-running-on-the-different-machines" id="markdown-toc-scenario-1-client-and-kafka-running-on-the-different-machines">Scenario 1: Client and Kafka running on the different machines</a></li>
      <li><a href="#scenario-2-kafka-and-client-running-in-docker" id="markdown-toc-scenario-2-kafka-and-client-running-in-docker">Scenario 2: Kafka and client running in Docker</a></li>
      <li><a href="#scenario-3-kafka-in-docker-container-with-a-client-running-locally" id="markdown-toc-scenario-3-kafka-in-docker-container-with-a-client-running-locally">Scenario 3: Kafka in Docker container with a client running locally</a>        <ul>
          <li><a href="#adding-a-new-listener-to-the-broker" id="markdown-toc-adding-a-new-listener-to-the-broker">Adding a new listener to the broker</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<p><a href="https://www.confluent.io/blog/kafka-client-cannot-connect-to-broker-on-aws-on-docker-etc/?utm_source=github&amp;utm_medium=rmoff&amp;utm_campaign=ty.community.con.rmoff-listeners&amp;utm_term=rmoff-devx" target="_blank">원문: Confluent블로그</a></p>

<h1 id="connection-client-to-broker">Connection Client To Broker</h1>

<p>클라이언트와 카프카간의 메세지를 주고받기 위해서는 두 가지의 연결이 반드시 선행되어야 한다.</p>

<ol>
  <li>브로커와의 초기 연결. 연결이 되면 브로커는 클라이언트에게 연결 가능(resolvable and accessible from client machine)한 브로커의 엔드포인트 제공(<code class="language-plaintext highlighter-rouge">advertised.listeners</code>)</li>
  <li>클라이언트와 연결 가능한 브로커와의 연결</li>
</ol>

<p>초기 연결은 <code class="language-plaintext highlighter-rouge">producer = KafkaProducer(bootstrap_servers=["localhost:9092"])</code> 와 같이 bootstrap_servers 중 하나의 서버와 초기 연결된다. 그러면 연결된 서버는 클라이언트에게 <code class="language-plaintext highlighter-rouge">advertised.listeners</code>를 노출해 연결되도록 한다.</p>

<p>예시로 클라이언트와 카프카가 서로 다른 머신에 있는 경우를 보자.</p>

<p>연결이 성공되는 경우는 다음과 같다.</p>

<p><img src="/images/kafka_39.png" alt="" /></p>

<p>연결이 실패되는 경우는 다음과 같다.</p>

<p><img src="/images/kafka_40.png" alt="" /></p>

<p>이러한 경우에는 <code class="language-plaintext highlighter-rouge">advertised.listeners</code>를 <code class="language-plaintext highlighter-rouge">localhost:9092</code>로 설정하면 안된다.</p>

<h2 id="scenario-0-client-and-kafka-running-on-the-same-local-machine">Scenario 0: Client and Kafka running on the same local machine</h2>

<p><img src="/images/kafka_41.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bootstrap_servers = 'localhost:9092'
advertised_listeners = 'localhost:9092'  
</code></pre></div></div>
<p>잘 동작한다.</p>

<p>클라이언트에 전달되는 메타데이터는 192.168.10.83이다. 이 값은 로컬 머신의 IP 주소이다.</p>

<h2 id="scenario-1-client-and-kafka-running-on-the-different-machines">Scenario 1: Client and Kafka running on the different machines</h2>

<p>카프카 브로커가 다른 머신에서 동작하는 경우를 살펴보자. 예를 들면 AWS, GCP와 같은 클라우드에서 생성한 머신</p>

<p><img src="/images/kafka_42.png" alt="" /></p>

<p>여기 예제에서 클라이언트는 나의 노트북이고 카프카 브로커가 동작하고 있는 머신의 LAN은 <code class="language-plaintext highlighter-rouge">asgard03</code>이라고 해보자.</p>

<p>초기 연결은 성공한다. 하지만 메타데이터에서 돌려주는 노출된 리스너는 <code class="language-plaintext highlighter-rouge">localhost</code>이다. 하지만 클라이언트의 <code class="language-plaintext highlighter-rouge">localhost</code>에는 카프카 브로커가 없으므로 연결은 실패한다.<br />
<img src="/images/kafka_43.png" alt="" /></p>

<p>이 문제를 해결하기 위해서는 <code class="language-plaintext highlighter-rouge">server.properties</code>에서 <code class="language-plaintext highlighter-rouge">advertised.listeners</code> 값을 수정해 <strong>클라이언트에서 접근 가능한 올바른 호스트네임과 포트를 제공</strong>해주어야 한다.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># advertised.listeners 수정 전</span>
advertised.listeners<span class="o">=</span>PLAINTEXT://localhost:9092
<span class="nv">listeners</span><span class="o">=</span>PLAINTEXT://0.0.0.0:9092
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># advertised.listeners 수정 후</span>
advertised.listeners<span class="o">=</span>PLAINTEXT://asgard03.moffatt.me:9092
<span class="nv">listeners</span><span class="o">=</span>PLAINTEXT://0.0.0.0:9092
</code></pre></div></div>

<p><img src="/images/kafka_44.png" alt="" /></p>

<h2 id="scenario-2-kafka-and-client-running-in-docker">Scenario 2: Kafka and client running in Docker</h2>

<p>도커를 이용할 때 기억해야할 점은 도커는 컨테이너를 통해 그들만의 작은 세상을 만든다는 것이다. 컨테이너는 자체적인 호스트네임, 네트워크 주소, 파일 시스템을 가지고 있다. 따라서 컨테이너를 기준으로 localhost는 더이상 나의 노트북이 아니다. 도커 컨테이너에서 localhost는 컨테이너 자기 자신이다.</p>

<p><img src="/images/kafka_46.png" alt="" /></p>

<p>여기서는 카프카와 클라이언트를 모두 각각 도커 호스트 위에 컨테이너로 만들어 본다.</p>

<p>클라이언트를 컨테이너로 만들어주는 Dockerfile이다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">FROM python:3</span>

<span class="c1"># We'll add netcat cos it's a really useful</span>
<span class="c1"># network troubleshooting tool</span>
<span class="s">RUN apt-get update</span>
<span class="s">RUN apt-get install -y netcat</span>

<span class="c1"># Install the Confluent Kafka python library</span>
<span class="s">RUN pip install confluent_kafka</span>

<span class="c1"># Add our script</span>
<span class="s">ADD python_kafka_test_client.py /</span>
<span class="s">ENTRYPOINT [ "python", "/python_kafka_test_client.py"]</span>
</code></pre></div></div>

<p>위의 메니페스트를 이용해 클라이언트 이미지를 만든다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build -t python_kafka_test_client .
</code></pre></div></div>

<p>카프카 브로커를 생성하자.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network create rmoff_kafka
docker run <span class="nt">--network</span><span class="o">=</span>rmoff_kafka <span class="nt">--rm</span> <span class="nt">--detach</span> <span class="nt">--name</span> zookeeper <span class="nt">-e</span> <span class="nv">ZOOKEEPER_CLIENT_PORT</span><span class="o">=</span>2181 confluentinc/cp-zookeeper:5.5.0
docker run <span class="nt">--network</span><span class="o">=</span>rmoff_kafka <span class="nt">--rm</span> <span class="nt">--detach</span> <span class="nt">--name</span> broker <span class="se">\</span>
           <span class="nt">-p</span> 9092:9092 <span class="se">\</span>
           <span class="nt">-e</span> <span class="nv">KAFKA_BROKER_ID</span><span class="o">=</span>1 <span class="se">\</span>
           <span class="nt">-e</span> <span class="nv">KAFKA_ZOOKEEPER_CONNECT</span><span class="o">=</span>zookeeper:2181 <span class="se">\</span>
           <span class="nt">-e</span> <span class="nv">KAFKA_ADVERTISED_LISTENERS</span><span class="o">=</span>PLAINTEXT://localhost:9092 <span class="se">\</span>
           <span class="nt">-e</span> <span class="nv">KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR</span><span class="o">=</span>1 <span class="se">\</span>
           confluentinc/cp-kafka:5.5.0

</code></pre></div></div>

<p>쥬키퍼와 카프카 브로커가 컨테이너로 돌아가고 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker ps
IMAGE                              STATUS              PORTS                          NAMES
confluentinc/cp-kafka:5.5.0        Up 32 seconds       0.0.0.0:9092-&gt;9092/tcp         broker
confluentinc/cp-zookeeper:5.5.0    Up 33 seconds       2181/tcp, 2888/tcp, 3888/tcp   zookeeper
</code></pre></div></div>

<p>위에서 우리는 우리만의 도커 네트워크를 만들었고 이제 이 네트워크를 통해 클라이언트와 브로커가 통신하도록 해보자</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run --network=rmoff_kafka --rm --name python_kafka_test_client \
        --tty python_kafka_test_client broker:9092
</code></pre></div></div>

<p>결과를 보면 초기 연결은 성공하지만, 메타데이터로 <code class="language-plaintext highlighter-rouge">localhost</code>를 돌려주기 때문에 프로듀서와 클라이언트의 연결은 실패된다.</p>

<p><img src="/images/kafka_47.png" alt="" /></p>

<p>이를 해결하려면 advertise.listeners의 호스트네임을 컨테이너 이름으로 바꿔줘야 한다.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 수정 전</span>
<span class="nt">-e</span> <span class="nv">KAFKA_ADVERTISED_LISTENERS</span><span class="o">=</span>PLAINTEXT://localhost:9092 <span class="se">\</span>
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 수정 후 </span>
<span class="nt">-e</span> <span class="nv">KAFKA_ADVERTISED_LISTENERS</span><span class="o">=</span>PLAINTEXT://broker:9092 <span class="se">\</span>
</code></pre></div></div>

<p><img src="/images/kafka_48.png" alt="" /></p>

<p>최종적으로 브로커 설정을 다음과 같이 고칠 수 있다.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker stop broker
docker run <span class="nt">--network</span><span class="o">=</span>rmoff_kafka <span class="nt">--rm</span> <span class="nt">--detach</span> <span class="nt">--name</span> broker <span class="se">\</span>
           <span class="nt">-p</span> 9092:9092 <span class="se">\</span>
           <span class="nt">-e</span> <span class="nv">KAFKA_BROKER_ID</span><span class="o">=</span>1 <span class="se">\</span>
           <span class="nt">-e</span> <span class="nv">KAFKA_ZOOKEEPER_CONNECT</span><span class="o">=</span>zookeeper:2181 <span class="se">\</span>
           <span class="nt">-e</span> <span class="nv">KAFKA_ADVERTISED_LISTENERS</span><span class="o">=</span>PLAINTEXT://broker:9092 <span class="se">\</span>
           <span class="nt">-e</span> <span class="nv">KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR</span><span class="o">=</span>1 <span class="se">\</span>
           confluentinc/cp-kafka:5.5.0

</code></pre></div></div>

<h2 id="scenario-3-kafka-in-docker-container-with-a-client-running-locally">Scenario 3: Kafka in Docker container with a client running locally</h2>

<p><img src="/images/kafka_49.png" alt="" /></p>

<p>위의 Scenario 2와 비교하여 클라이언트가 컨테이너화 되어 있다가 여기서는 따로 컨테이너화 되지 않고 로컬 머신 위에 있다. (이러한 차이로 위에서 하던 방식이 왜 안되는 건지 모르겠다…)</p>

<p>로컬에 실행하는 클라이언트는 따로 네트워크가 구성되어 있지 않다. 그렇기 때문에 따로 특정 트래픽을 받기 위해서는 로컬의 포트를 열어 이를 통해 통신해야 한다. 아래 그림과 같이 9092:9092 포트를 열었다고 해보자. 클라이언트가 로컬의 9092포트 엔드포인트로 접근하기 위해서는 bootstrap_servers=’localhost:9092’로 해야 한다. advertised.listeners는 broker:9092로 해야 한다(클라이언트와 localhost관계가 아니므로).</p>

<p>문제는 클라이언트 입장에서 ‘broker:9092’는 resolvable하지 않다.</p>

<h3 id="adding-a-new-listener-to-the-broker">Adding a new listener to the broker</h3>
:ET