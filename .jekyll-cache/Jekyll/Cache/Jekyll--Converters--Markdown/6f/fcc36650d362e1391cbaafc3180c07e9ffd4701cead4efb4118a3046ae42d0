I"Z0<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#스프링-역사" id="markdown-toc-스프링-역사">스프링 역사</a></li>
  <li><a href="#스프링" id="markdown-toc-스프링">스프링</a>    <ul>
      <li><a href="#스프링-프레임워크" id="markdown-toc-스프링-프레임워크">스프링 프레임워크</a></li>
      <li><a href="#스프링-부트" id="markdown-toc-스프링-부트">스프링 부트</a></li>
      <li><a href="#스프링의-핵심-컨셉" id="markdown-toc-스프링의-핵심-컨셉">스프링의 핵심 컨셉</a></li>
    </ul>
  </li>
  <li><a href="#객체-지향" id="markdown-toc-객체-지향">객체 지향</a>    <ul>
      <li><a href="#다형성" id="markdown-toc-다형성">다형성</a></li>
      <li><a href="#제어의-역전-의존-관계-주입" id="markdown-toc-제어의-역전-의존-관계-주입">제어의 역전, 의존 관계 주입</a></li>
      <li><a href="#서버와-클라이언트" id="markdown-toc-서버와-클라이언트">서버와 클라이언트</a></li>
      <li><a href="#solid" id="markdown-toc-solid">SOLID</a></li>
      <li><a href="#스프링과-객체-지향" id="markdown-toc-스프링과-객체-지향">스프링과 객체 지향</a></li>
    </ul>
  </li>
  <li><a href="#스프링-컨테이너와-빈" id="markdown-toc-스프링-컨테이너와-빈">스프링 컨테이너와 빈</a>    <ul>
      <li><a href="#appconfig" id="markdown-toc-appconfig">AppConfig</a></li>
      <li><a href="#applicationcontext" id="markdown-toc-applicationcontext">ApplicationContext</a></li>
    </ul>
  </li>
  <li><a href="#싱글톤-컨테이너" id="markdown-toc-싱글톤-컨테이너">싱글톤 컨테이너</a></li>
  <li><a href="#컴포넌트-스캔" id="markdown-toc-컴포넌트-스캔">컴포넌트 스캔</a></li>
  <li><a href="#의존관계-자동-주입" id="markdown-toc-의존관계-자동-주입">의존관계 자동 주입</a></li>
  <li><a href="#빈-스코프" id="markdown-toc-빈-스코프">빈 스코프</a></li>
</ul>

<hr />

<h1 id="스프링-역사">스프링 역사</h1>

<ul>
  <li><strong>EJB(Enterprise Java Beans)</strong>:
    <ul>
      <li>기업환경의 시스템을 구현하기 위한 서버측 컴포넌트 모델 (서버를 구현하기 위해 필요한 각종 기능들을 제공)</li>
      <li>서버 구현에 필요한 거의 모든 기능(ORM, 서버 애플리케이션 프레임워크 등)을 제공했지만 어렵고 느리고 비싸다</li>
    </ul>
  </li>
  <li><strong>하이버네이트(Hybernate)</strong>:
    <ul>
      <li>EJB에서 JPA 기능을 담당하던 엔티티 빈을 훨씬 사용하기 편하도록 구현</li>
      <li>하이버네이트를 조금 더 일반화 시켜 JPA를 표준화(용어를 통일시키고 기능을 일반화)시킴</li>
      <li>하이버네이트는 JPA의 구현체중 하나
<img src="/images/jpa_1.png" alt="" /></li>
    </ul>
  </li>
  <li><strong>스프링(Spring)</strong>:
    <ul>
      <li>EJB의 서버 애플리케이션 프레임워크를 훨씬 사용하기 편하게 만듬</li>
      <li>EJB의 시대가 끝나고 봄(Spring)이 왔다 -&gt; 스프링</li>
    </ul>
  </li>
  <li><strong>스프링 부트(Spring Boot)</strong>:
    <ul>
      <li>스프링은 다 좋은데 설정하기가 힘들다</li>
      <li>스프링은 별도의 웹 서버도 있어야 하고, 서버 애플리케이션을 띄우기 위해 빌드도 해야한다</li>
      <li>스프링 부트가 이 모든 것들을 해결해준다</li>
    </ul>
  </li>
</ul>

<p><strong>JPA(Java Persistence API)</strong></p>

<ul>
  <li>자바 진영의 ORM 표준 기술</li>
  <li>SQL 작성없이 객체를 DB에 직접 저장</li>
</ul>

<p><strong>ORM(Object Relational Mapping)</strong></p>

<ul>
  <li>메모리 상의 객체를 DB에 데이터로 저장시켜주는 기술</li>
</ul>

<h1 id="스프링">스프링</h1>

<ul>
  <li>스프링은 하둡(Hadoop)이 HDFS와 MapReduce와 같은 기술들을 일컫는 생태계를 나타내는 것처럼 스프링도 스프링 생태계를 나타냄</li>
  <li>각각의 기술들은 <a href="https://spring.io/projects"><strong>공식문서 참고</strong></a></li>
</ul>

<p><img src="/images/spring_1.png" alt="" /></p>

<h2 id="스프링-프레임워크">스프링 프레임워크</h2>

<ul>
  <li><strong>핵심 기술</strong>: 스프링 DI 컨테이너, AOP, 이벤트 등 (디자인 패턴 같은 느낌)</li>
  <li><strong>웹 기술</strong>: 스프링 MVC (백엔드 설계 패턴(아키텍처) 같은 느낌)</li>
  <li><strong>데이터 접근</strong> 기술: 트랜잭션, JDBC, JPA</li>
  <li><strong>기술 통합</strong>: 캐시, 이메일, 원격접근, 스케줄링</li>
  <li><strong>테스트</strong>: 스프링 기반 테스트 지원</li>
</ul>

<h2 id="스프링-부트">스프링 부트</h2>

<ul>
  <li>스프링을 편리하게 사용할 수 있도록 지원</li>
  <li>Tomcat 같은 웹 서버 내장</li>
  <li>스프링과 외부 라이브러리 자동 구성</li>
</ul>

<h2 id="스프링의-핵심-컨셉">스프링의 핵심 컨셉</h2>
<ul>
  <li>웹 애플리케이션을 만들어주는 프레임워크</li>
  <li>데이터베이스에 접근을 편리하게 함</li>
  <li><strong>객체 지향 설계를 지원하는 프레임워크</strong></li>
</ul>

<h1 id="객체-지향">객체 지향</h1>

<h2 id="다형성">다형성</h2>
<ul>
  <li>객체 지향 코드를 작성할 때 얻을 수 있는 가장 큰 특징은 <strong>다형성</strong></li>
  <li>다형성은 <strong>역할(인터페이스)과 구현(클래스)으로 나누어</strong> 코드를 설계</li>
  <li>코드 설계시 역할만 알아도 됨</li>
  <li>빠른 설계와 유연한 확장 가능</li>
</ul>

<h2 id="제어의-역전-의존-관계-주입">제어의 역전, 의존 관계 주입</h2>
<ul>
  <li>스프링은 <strong>다형성을 위해 제어의 역전(IoC), 의존관계 주입(DI) 방식으로 개발</strong>하도록 지원</li>
  <li>스프링 컨테이너(<code class="language-plaintext highlighter-rouge">ApplicationContext</code>)가 위 방식을 가능하게 함</li>
  <li>서비스를 공연에 비유하면 스프링 컨테이너는 공연 기획자에 해당</li>
</ul>

<h2 id="서버와-클라이언트">서버와 클라이언트</h2>
<ul>
  <li>서버와 클라이언트를 각각 객체로 구현</li>
  <li>클라이언트는 요청하는 객체, 서버는 응답하는 객체</li>
  <li>수 많은 클라이언트 객체와 서버 객체는 서로 협력 관계를 가짐</li>
  <li>서버와 클라이언트 구조에 다형성을 적용하면, 클라이언트를 변경하지 않고, 서버의 기능을 유연하게 변경할 수 있음</li>
  <li>(인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있음)</li>
  <li>인터페이스를 안정적으로 잘 설계하는 것이 중요</li>
</ul>

<h2 id="solid">SOLID</h2>

<ul>
  <li>좋은 객체 지향 설계를 위한 5가지 원칙</li>
  <li><strong>S</strong>(Single Responsibility Principle): 단일 책임 원칙
    <ul>
      <li>하나의 클래스는 하나의 책임만 가진다</li>
      <li>하나의 책임? -&gt; 모호하다</li>
      <li>핵심 의미는 변경이 생겼을 때 파급 효과가 적냐이다 -&gt; 책임을 적절히 잘 분리해야 한다</li>
    </ul>
  </li>
  <li><strong>O</strong>(Open/Closed Principle): <strong>개방/폐쇄 원칙</strong>
    <ul>
      <li>확장이 되더라도 변경은 일어나면 안된다</li>
      <li>이런 마법같은 일이?</li>
      <li>확장은 구현하는 객체에만 반영하고, 인터페이스에 대한 변경은 막자 -&gt; <strong>다른 구현체에 영향을 끼치지 말자</strong></li>
      <li>객체 지향의 특성중 다형성과 관련 -&gt; 제어의 역전, 의존관계 주입 방식 필요 -&gt; OCP를 지키기 위해서는 IoC와 DI가 있어야됨</li>
    </ul>
  </li>
  <li><strong>L</strong>(Liskov Substitution Principle): 리스코프 치환 원칙
    <ul>
      <li>인터페이스를 구현하는 모든 객체 인스턴스는 인터페이스의 규약을 잘 지켜야함</li>
      <li>그래야 구현한 객체들중 어떤 것들로 치환하더라도 일관되게 동작할 수 있음</li>
    </ul>
  </li>
  <li><strong>I</strong>(Interface Segregation Principle): 인터페이스 분리 원칙
    <ul>
      <li>하나의 범용적인 인터페이스보다 역할에 맞게 인터페이스를 분리하여 정의하는 것이 좋음</li>
      <li>단일 책임 원칙과 비슷한 철학</li>
    </ul>
  </li>
  <li><strong>D</strong>(Dependency Inversion Principle): <strong>의존관계 역전 원칙</strong>
    <ul>
      <li>컴포넌트들이 구현 클래스가 아니라 <strong>인터페이스에 의존</strong>하도록 해야함</li>
      <li>DIP도 다형성과 관련 -&gt; <strong>OCP와 DIP 모두 제어의 역전(IoC), 의존관계 주입(DI)을 필요로함</strong></li>
    </ul>
  </li>
</ul>

<h2 id="스프링과-객체-지향">스프링과 객체 지향</h2>

<ul>
  <li>스프링은 <strong>DI(Dependency Injection) 컨테이너</strong> 기술을 통해 객체지향의 OCP, DIP 원칙을 지키도록 해줌</li>
  <li>DI 컨테이너 기술 덕분에 <strong>기능의 확장을 부품 교체하듯</strong> 할 수 있게 됨</li>
</ul>

<h1 id="스프링-컨테이너와-빈">스프링 컨테이너와 빈</h1>

<ul>
  <li>구현체에는 의존관계가 없어야함 -&gt; 의존관계는 인터페이스간에 있어야함 (DIP 원칙)
    <ul>
      <li>구현체에 의존관계가 있으면 (DIP 원칙 위배) -&gt; 기능 확장시 구현체간에 영향 끼침 (OCP 원칙 위배)</li>
    </ul>
  </li>
  <li>근데 인터페이스간에 의존관계만 정의하게 되면 구현 객체를 상황에 맞게 생성할 수가 없음
    <ul>
      <li>그래서 런타임 단계에서 적절히 구현 객체를 생성하고 연결해 줄 존재가 필요 -&gt; 이를 담당하는 설정 클래스를 만들자 -&gt; <code class="language-plaintext highlighter-rouge">AppConfig</code> 클래스</li>
    </ul>
  </li>
</ul>

<h2 id="appconfig">AppConfig</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">AppConfig</code>는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성</li>
  <li><code class="language-plaintext highlighter-rouge">AppConfig</code>는 생성한 객체 인스턴스의 참조를 생성자를 통해 주입(연결)</li>
  <li><code class="language-plaintext highlighter-rouge">AppConfig</code>가 바로 <strong>의존관계 주입해주는 존재</strong>였음</li>
  <li>기능 변경으로 인한 코드 변경은 <code class="language-plaintext highlighter-rouge">AppConfig</code>에서만 일어난다</li>
  <li><code class="language-plaintext highlighter-rouge">AppConfig</code>는 의존관계 주입뿐만 아니라, <strong>제어의 흐름</strong>까지 담당 -&gt; 구현 객체는 자신의 로직을 실행하는 역할만 담당</li>
  <li>이러한 <code class="language-plaintext highlighter-rouge">AppConfig</code> 클래스를 IoC 컨테이너 또는 <strong>DI 컨테이너</strong>라고 함</li>
  <li>스프링에서는 이러한 <code class="language-plaintext highlighter-rouge">AppConfig</code>를 담당하는 클래스에 <code class="language-plaintext highlighter-rouge">@Configuration</code>을 붙여줌</li>
  <li>그리고 <code class="language-plaintext highlighter-rouge">AppConfig</code>에서 각 구현체를 리턴하는 메서드에는 <code class="language-plaintext highlighter-rouge">@Bean</code>을 붙여줌 -&gt; 스프링 컨테이너에 스프링 빈으로 등록됨 -&gt; 스프링 컨테이너의 관리 대상이됨</li>
</ul>

<h2 id="applicationcontext">ApplicationContext</h2>
<ul>
  <li><strong>ApplicationContext</strong>를 스프링 컨테이너라 함</li>
  <li>스프링 컨테이너는 AppConfig 내의 구현 객체를 스프링 컨테이너에 빈으로 알아서 등록하고 알아서 의존관계를 주입해줌</li>
</ul>

<h1 id="싱글톤-컨테이너">싱글톤 컨테이너</h1>

<h1 id="컴포넌트-스캔">컴포넌트 스캔</h1>

<h1 id="의존관계-자동-주입">의존관계 자동 주입</h1>

<h1 id="빈-스코프">빈 스코프</h1>

:ET