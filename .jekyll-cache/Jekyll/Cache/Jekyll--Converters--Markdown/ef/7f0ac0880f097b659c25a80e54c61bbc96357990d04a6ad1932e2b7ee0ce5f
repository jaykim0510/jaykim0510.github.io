I">O<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#함수" id="markdown-toc-함수">함수</a>    <ul>
      <li><a href="#함수-정의" id="markdown-toc-함수-정의">함수 정의</a>        <ul>
          <li><a href="#함수-리터럴" id="markdown-toc-함수-리터럴">함수 리터럴</a></li>
          <li><a href="#함수-선언문" id="markdown-toc-함수-선언문">함수 선언문</a></li>
          <li><a href="#함수-표현식" id="markdown-toc-함수-표현식">함수 표현식</a></li>
          <li><a href="#함수-생성-시점과-함수-호이스팅" id="markdown-toc-함수-생성-시점과-함수-호이스팅">함수 생성 시점과 함수 호이스팅</a></li>
          <li><a href="#화살표-함수" id="markdown-toc-화살표-함수">화살표 함수</a></li>
        </ul>
      </li>
      <li><a href="#참조에-의한-전달과-외부-상태의-변경" id="markdown-toc-참조에-의한-전달과-외부-상태의-변경">참조에 의한 전달과 외부 상태의 변경</a></li>
      <li><a href="#다양한-함수의-형태" id="markdown-toc-다양한-함수의-형태">다양한 함수의 형태</a>        <ul>
          <li><a href="#즉시-실행-함수" id="markdown-toc-즉시-실행-함수">즉시 실행 함수</a></li>
          <li><a href="#중첩-함수" id="markdown-toc-중첩-함수">중첩 함수</a></li>
          <li><a href="#콜백-함수" id="markdown-toc-콜백-함수">콜백 함수</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="함수">함수</h1>

<ul>
  <li>프로그래밍에서 함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다</li>
  <li>함수를 이용하면 코드의 재사용성을 높이고 가독성을 향상시킨다</li>
  <li>자바스크립트에서 함수는 <span class="very__important">호출할 수 있는 객체</span>다</li>
</ul>

<h2 id="함수-정의">함수 정의</h2>

<ul>
  <li>자바스크립트에서 함수를 정의하는 방법에는 <strong>함수 선언문</strong>, <strong>함수 표현식</strong>, <strong>Function 생성자 함수</strong> 그리고 <strong>화살표 함수</strong>가 있다
    <ul>
      <li>함수 선언문과 함수 표현식은 함수 리터럴을 통해 정의한다</li>
      <li>Function 생성자 함수는 거의 사용하지 않는다 (권장하는 방식이 아니다)</li>
      <li>화살표 함수는 ES6에서 도입된 것으로 위의 방식들을 간략화한 방법이다</li>
    </ul>
  </li>
</ul>

<h3 id="함수-리터럴">함수 리터럴</h3>

<ul>
  <li>함수라는 객체를 표현하는 방식을 의미한다</li>
  <li>숫자 리터럴은 숫자 값으로 표기해야 하고, 문자열 리터럴도 따옴표로 묶어야 되듯이, 함수 리터럴도 함수 리터럴로 인식되려면 규칙이 필요하다</li>
  <li>함수 리터럴은 function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성된다</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기본 방식</span>
<span class="c1">// function 키워드, 함수 이름, 매개변수 목록, 함수 몸체</span>
<span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>

<span class="c1">// 매개변수 없어도 된다</span>
<span class="kd">function</span> <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span>
<span class="p">}</span>

<span class="c1">// 함수 이름 없어도 된다</span>
<span class="c1">// 하지만, 식별자에 할당해야 한다</span>
<span class="kd">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>함수 리터럴은 함수 선언문 또는 함수 표현식, 이 두 가지 함수 정의에 사용된다</li>
  <li>만약 함수 이름이 없다면, 무조건 함수 표현식으로 정의하는데만 사용되야 한다
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="c1">// 식별자가 필요합니다</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="c1">// 함수 표현식</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>함수 이름이 있다면,
    <ul>
      <li>값으로 평가되는 문맥인 경우, 예를 들어 변수에 할당하거나 피연산자로 사용하면 이는 <strong>함수 표현식</strong>으로 정의한 것이다</li>
      <li>단독으로 사용하면 이는 <strong>함수 선언문</strong>으로 정의한 것이다</li>
    </ul>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 함수 선언문</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 함수 표현식</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="함수-선언문">함수 선언문</h3>

<ul>
  <li>함수 선언문은 함수 리터럴의 이름을 생략할 수 없다</li>
  <li>(변수에 할당도 못하는데 함수 이름까지 없으면 함수를 식별할 수가 없으니까)</li>
  <li><strong>함수 호출은 함수 이름에 의해서가 아니라 함수 객체를 가리키는 식별자로 호출한다</strong></li>
  <li>그래서 함수 선언문도 암묵적으로는 함수 이름과 똑같은 식별자를 자바스크립트 엔진이 생성하고, 거기에 함수 객체를 할당한다</li>
  <li>이렇게 자바스크립트 엔진이 식별자를 생성해 함수 객체를 할당한 후부터 함수를 값처럼 사용할 수 있다 (일급 객체)</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 함수 선언문</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>

<span class="c1">// 자바스크립트 엔진이 암묵적으로 아래와 같이 변경한다</span>
<span class="kd">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="함수-표현식">함수 표현식</h3>

<ul>
  <li>함수 표현식으로 함수를 정의하면, 자바스크립트 엔진이 별다른 과정을 거치지 않아도 값으로 사용할 수 있다</li>
  <li>함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다 (재귀 함수의 경우에는 함수 이름 필요)</li>
</ul>

<h3 id="함수-생성-시점과-함수-호이스팅">함수 생성 시점과 함수 호이스팅</h3>

<ul>
  <li>함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성된다. 그리고 자바스크립트 엔진은 함수 이름과 동일한 이름으로 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다</li>
  <li>이렇게 런타임 이전에 이미 함수 객체가 생성되어 있기 때문에, 런타임에 함수 선언문 이전부터 함수를 참조하고 호출할 수 있다</li>
  <li>
    <p>이를 함수 호이스팅이라고 한다</p>
  </li>
  <li>반면 함수 표현식은 런타임 이전에는 함수를 할당한 변수의 선언문 까지만 실행되고, 해당 변수에는 <code class="language-plaintext highlighter-rouge">undefined</code>가 할당되어 있다. 그리고 런타임에 비로소 함수 객체가 생성되어 변수에 할당된다</li>
  <li>함수 표현식은 런타임에서 함수 표현식을 만났을 때 비로소 함수 객체가 할당되기 때문에 표현식 이전에 함수를 참조하고 호출할 수 없다</li>
  <li>
    <p>이렇게 변수 선언문만 런타임 전에 실행되고, 할당문은 런타임에 실행되는 방식을 변수 호이스팅이라 한다</p>
  </li>
  <li>결론적으로 함수 호이스팅은 함수를 호출하기 전에 함수를 선언해야 한다는 당연한 규칙을 위배하기 때문에 권장되지 않고, <span class="very__important">변수 호이스팅 되는 함수 표현식으로 함수를 정의할 것을 권장한다</span></li>
</ul>

<h3 id="화살표-함수">화살표 함수</h3>

<ul>
  <li>화살표 함수는 ES6에서 도입되었으며 함수를 정의할 때 <code class="language-plaintext highlighter-rouge">function</code> 키워드 대신 화살표 <code class="language-plaintext highlighter-rouge">=&gt;</code>를 사용한다</li>
  <li>화살표 함수는 항상 익명 함수로 정의한다</li>
  <li>
    <p>화살표 함수는 단순히 위의 정의 방법들을 단순화하기 위한 용도가 아니라, <strong>화살표 함수만의 특징과 용도가 있다</strong></p>
  </li>
  <li>화살표 함수는 생성자 함수로 사용할 수 없다</li>
  <li>기존 함수와 <code class="language-plaintext highlighter-rouge">this</code> 바인딩 방식이 다르다</li>
  <li><code class="language-plaintext highlighter-rouge">prototype</code> 프로퍼티가 없다</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">arguments</code> 객체를 생성하지 않는다</p>
  </li>
  <li>(중요한 부분이기 때문에 나중에 26장 공부한 후 보충한다)</li>
</ul>

<h2 id="참조에-의한-전달과-외부-상태의-변경">참조에 의한 전달과 외부 상태의 변경</h2>

<ul>
  <li>함수의 매개변수로 전달한 인자를 함수 안에서 조작하면 어떻게 될까?
    <ul>
      <li>원시값은 원본이 훼손되지 않는다</li>
      <li>객체는 원본이 훼손된다</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">var</code>, <code class="language-plaintext highlighter-rouge">let</code> 으로 정의한 원시값을 변경하면, 값을 새로운 메모리에 할당하고 해당 메모리에 저장된 값을 수정한다. 그래서 원본 값은 보존된다</li>
  <li>객체는 변경 가능한 타입이기 때문에, 원시값을 변경하면, 해당 메모리에 있는 원시값이 그대로 수정된다. 그래서 원본 값이 훼손된다</li>
  <li>이렇게 함수가 외부 상태를 변경하는 것은 변화의 추적을 어렵게 하기 때문에 지양되는 방식이다. 그래서 깊은 복사를 통해 매개변수에 전달하면 이러한 부수 효과를 피할 수 있다</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">changeVal</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prim</span><span class="p">,</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 외부 상태를 건드리는 비순수 함수</span>
    <span class="nx">prim</span> <span class="o">+=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Kim</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 외부 상태</span>
<span class="kd">let</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Lee</span><span class="dl">'</span> <span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="c1">// 100</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="c1">// { name: 'Lee' }</span>

<span class="nx">changeVal</span><span class="p">(</span><span class="nx">num</span><span class="p">,</span> <span class="nx">person</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="c1">// 100 --&gt; 원시값은 원본이 보존</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="c1">// { name: 'Kim' } --&gt; 객체는 원본이 훼손</span>

</code></pre></div></div>

<h2 id="다양한-함수의-형태">다양한 함수의 형태</h2>

<h3 id="즉시-실행-함수">즉시 실행 함수</h3>

<ul>
  <li>함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 한다</li>
  <li>즉시 실행 함수는 단 한 번만 호출되며 다시 호출할 수 없다</li>
  <li>즉시 실행 함수는 그룹 연산자 <code class="language-plaintext highlighter-rouge">(...)</code>로 먼저 함수 리터럴 + 호출 연산자를 감싸줘야 한다
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{}())</span>
</code></pre></div>    </div>
  </li>
  <li>그룹 연산자가 없으면 함수 선언문으로 여겨지고 함수 선언문은 함수 객체가 아니기 때문에 뒤의 함수 호출 연산자를 붙일 수 없다</li>
  <li>그룹 연산자로 감싸줘야 함수 리터럴, 즉 함수 객체로 평가되고 뒤에 호출 연산자를 붙일 수 있다</li>
  <li>즉시 실행 함수도 일반 함수처럼 인수를 전달할 수 있고 값을 반환할 수도 있다
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">(</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="p">}(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="p">)</span> <span class="c1">// 8</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="중첩-함수">중첩 함수</h3>

<ul>
  <li>함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라 한다</li>
  <li>그리고 중첩 함수를 포함하는 함수를 외부 함수라 한다</li>
  <li>중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">inner</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">inner</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">outer</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="콜백-함수">콜백 함수</h3>

<ul>
  <li>반복되는 부분을 함수로 만들어 <strong>다른 함수 매개변수에 인자로 전달되는 함수를 콜백 함수</strong>라 한다</li>
  <li><strong>콜백 함수를 인자로 받는 함수를 고차 함수</strong>라 한다</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">callBackFunc</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">higherOrderFunc</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">cb</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">higherOrderFunc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nx">callBackFunc</span><span class="p">);</span>
</code></pre></div></div>
:ET