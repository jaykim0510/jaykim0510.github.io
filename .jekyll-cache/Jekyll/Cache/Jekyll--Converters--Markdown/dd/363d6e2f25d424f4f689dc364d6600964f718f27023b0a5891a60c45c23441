I"hJ<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#ipc" id="markdown-toc-ipc">IPC</a>    <ul>
      <li><a href="#use-cases" id="markdown-toc-use-cases">Use Cases</a></li>
      <li><a href="#공유-메모리" id="markdown-toc-공유-메모리">공유 메모리</a></li>
      <li><a href="#파일" id="markdown-toc-파일">파일</a></li>
      <li><a href="#파이프" id="markdown-toc-파이프">파이프</a></li>
      <li><a href="#소켓" id="markdown-toc-소켓">소켓</a></li>
      <li><a href="#메세지-큐" id="markdown-toc-메세지-큐">메세지 큐</a></li>
    </ul>
  </li>
  <li><a href="#rpc" id="markdown-toc-rpc">RPC</a>    <ul>
      <li><a href="#when-the-client-calls-the-server-the-rpc-system-must-take-care-of" id="markdown-toc-when-the-client-calls-the-server-the-rpc-system-must-take-care-of">When the client calls the server, the RPC system must take care of:</a></li>
      <li><a href="#the-following-steps-take-place-during-a-rpc" id="markdown-toc-the-following-steps-take-place-during-a-rpc">The following steps take place during a RPC</a></li>
      <li><a href="#장점" id="markdown-toc-장점">장점</a></li>
      <li><a href="#단점" id="markdown-toc-단점">단점</a></li>
      <li><a href="#grpc" id="markdown-toc-grpc">gRPC</a></li>
    </ul>
  </li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>
<hr />

<h1 id="ipc">IPC</h1>

<ul>
  <li>Inter-Process Communication의 줄임말 -&gt; 프로세스간 통신을 의미</li>
  <li>프로세스끼리 서로 데이터를 주고 받는 방법들을 일컫어 IPC라고 함</li>
  <li>스레드끼리는 메모리를 공유한다 -&gt; 공유하는 공간이 있기 때문에 데이터를 주고 받는데 크게 어려움이 없다</li>
  <li>프로세스는 별도의 메모리에 생성된다 -&gt; 공유하는 공간이 없다 -&gt; 이를 위해 운영체제 커널에서 IPC를 위한 여러 도구를 제공</li>
  <li>공유 메모리, 파일, 파이프, 소켓, 메세지 큐, RPC</li>
</ul>

<h2 id="use-cases">Use Cases</h2>
<p>There are several good reasons and common use cases for IPC:</p>

<ul>
  <li><strong>Sharing information/data</strong> – Share data between processes to synchronize different applications</li>
  <li><strong>Computational Speedups</strong> – Sending data off site for processing</li>
  <li><strong>Modularity</strong> – Google Chrome separates each tab into a separate process to help avoid crashes, as well as security.</li>
  <li><strong>Development</strong> – Often it is easier to have two teams build separate programs. By building them with IPC in mind you can essentially “plugin” to any programs which need similar functionality without any recompiling</li>
  <li><strong>Security</strong> – It is often useful to separate processes to ensure system security. Each process has it’s own memory and if they communicate as opposed to sharing memory the process will be modularized and possibly more secure.</li>
</ul>

<h2 id="공유-메모리">공유 메모리</h2>

<blockquote>
  <p>Shared memory IPCs refer to sharing a physical memory location where multiple processes read and write to. The processes do this by mapping local memory to the shared physical memory location (via pointers or some other method). The physical memory is then used throughout the processes life spawn, meaning some processes can finish and close, but the physical memory remains until it is released (and all processes detach).</p>
</blockquote>

<blockquote>
  <p>It is possible (and advised) to address the issue of mutual exclusion by building a mutex that spans processes. Programers must recognize this and program accordingly.</p>
</blockquote>

<p><img src="/images/ipc_1.png" alt="" /></p>

<ul>
  <li>프로세스간 read, write를 모두 필요로 할 때 사용</li>
  <li>중개자 없이 메모리에 바로 접근 가능 -&gt; 모든 IPC 방법 중에 가장 빠름</li>
  <li>공유 메모리 모델의 장점
    <ul>
      <li>커널의 관여 없이 메모리를 직접 사용하여 IPC 속도가 빠르다.</li>
      <li>프로그램 레벨에서 통신 기능을 제공하여, 자유로운 통신이 가능하다.</li>
    </ul>
  </li>
  <li>공유 메모리 모델의 단점
    <ul>
      <li>구현하기 어렵다는 단점이 있다.</li>
    </ul>
  </li>
  <li>컨텍스트 스위칭 관점
    <ul>
      <li>공유 메모리 모델에서의 IPC는 해당 프로세스가 CPU를 사용하는 행위이다.</li>
      <li>즉, IPC를 많이 한다고 컨텍스트 스위칭 많이 일어나지 않는다.</li>
    </ul>
  </li>
  <li>동기화 관점
    <ul>
      <li>메모리 영역에 대한 동시적인 접근을 제어하기 위한 방법이 필요하다.</li>
      <li>커널이 동기화를 제공하지 않으며, 부가적인 방법이 필요하다.</li>
      <li>접근 제어 방식은 locking이나 세마포어(semaphore) 등이 있다.</li>
    </ul>
  </li>
  <li>공유 메모리 모델의 활용의 예 : 데이터베이스</li>
</ul>

<h2 id="파일">파일</h2>

<ul>
  <li>파일을 이용한 통신은 부모-자식 프로세스 간 통신에 많이 사용</li>
  <li>운영체제가 별다른 동기화를 제공하지 않음</li>
  <li>동기화를 위해 주로 부모 프로세스가 wait() 함수를 이용하여 자식 프로세스의 작업이 끝날 때까지 기다렸다가 작업을 시작</li>
</ul>

<h2 id="파이프">파이프</h2>

<blockquote>
  <p>Pipes are relatively straight forward. Instead of using shared/mapped memory to share data among processes, instead we “pipe” data across processes with the help of the operating system. Although this does not mean that less memory is used necessarily (by the system), but it does remove the programmers requirement to manage it. The major advantage they have over the shared or mapped memory IPCs is that the programmer does not have to worry about does not have to worry about mutual exclusion for read/writing, the operating system handles it all.</p>
</blockquote>

<p><img src="/images/ipc_2.png" alt="" /></p>

<ul>
  <li>익명 파이프 (Anonymous Pipe)
    <ul>
      <li>기본 파이프</li>
      <li>부모-자식, 형제 프로세스간 통신에 사용</li>
      <li>기본적으로 하나의 프로세스는 read, 다른 하나는 write만 가능한 단방향 통신 -&gt; 양방향 통신을 위해서는 2개의 파이프 필요</li>
      <li>파이프를 사용하는 프로세스가 없으면 자동으로 제거됨</li>
    </ul>
  </li>
  <li>네임드 파이프 (Named Pipe)
    <ul>
      <li>부모-자식, 형제 프로세스가 아닌 서로 무관한 프로세스간 통신에도 사용 가능</li>
      <li>FIFO라 불리는 특수한 파일 사용</li>
      <li>네임드 파이프로 양방향 통신을 위해서는 2개의 파이프 필요</li>
      <li>파이프를 사용하는 프로세스가 없어도 제거되지 않고 남아있음</li>
    </ul>
  </li>
</ul>

<h2 id="소켓">소켓</h2>

<blockquote>
  <p>sockets are similar to pipes, but capable of network connections (i.e. communication across computers). The data then travels through the network to another computer and to the desired process. You can also use sockets locally by using the “localhost” to essentially loop-back to the another process on the system.</p>
</blockquote>

<p><img src="/images/ipc_3.png" alt="" /></p>

<ul>
  <li>소켓은 두 프로세스간 통신을 위해 제공되는 엔드포인트</li>
  <li>원격에 있는 프로세스간 통신을 제공</li>
  <li>양방향 통신이 가능</li>
  <li>서버/클라이언트 구조의 프로세스간 통신에 자주 사용</li>
</ul>

<h2 id="메세지-큐">메세지 큐</h2>

<ul>
  <li>파이프와 비슷하게 단방향 통신</li>
  <li>파이프와 다른점은 메세지 큐는 메모리를 사용</li>
  <li>다수의 프로세스간 데이터 전달 가능</li>
  <li>메시지 큐를 사용하기 위해서는, “메시지 큐 ID”를 알아야 함 (cf.소켓은 상대방 프로세스의 “포트 번호”만 알면 가능)</li>
</ul>

<p>위에서 살펴본 파이프, 소켓, 메세지 큐와 같은 방식을 메세지 전달 모델이라고 한다.</p>

<ul>
  <li>메시지 전달 모델의 장점
    <ul>
      <li>구현하기에 간단하여 사용하기 편리하다.</li>
    </ul>
  </li>
  <li>메시지 전달 모델의 단점
    <ul>
      <li>커널을 경유하므로, 속도가 느리다.</li>
    </ul>
  </li>
  <li>컨텍스트 스위칭 관점
    <ul>
      <li>메시지 전달 모델에서의 IPC는 해당 프로세스 입장에서 일종의 입출력(I/O)로 볼 수 있다.</li>
      <li>즉, IPC를 하면 할수록 컨텍스트 스위칭이 많이 일어난다.
 =&gt; 예를 들어, send하고 상대방이 받을 때까지 기다려야 하며, 이 때 컨텍스트 스위칭이 발생한다.
 =&gt; 마찬가지로, receive하면 상대방이 보낼 때까지 기다려야 하며, 이 때 컨텍스트 스위칭이 발생한다.</li>
    </ul>
  </li>
  <li>동기화 관점
    <ul>
      <li>send와 receive와 같은 연산에 대해서는 커널이 동기화를 제공한다.</li>
      <li>send와 receive를 수행할 때에 프로그램은 동기화에 대한 고려 없이 사용할 수 있다.</li>
    </ul>
  </li>
  <li>메시지 전달 모델 활용의 예 : 서버-클라이언트 방식의 통신</li>
  <li>메시지 전달 모델의 구현 IPC : PIPE, Message Queue, Socket</li>
</ul>

<h1 id="rpc">RPC</h1>

<blockquote>
  <p>Remote Procedure Call is a technique for building distributed systems. Basically, it allows a program on one machine to call a subroutine on another machine without knowing that it is remote</p>
</blockquote>

<ul>
  <li>IPC의 한 종류</li>
  <li>분산 네트워크에서 많이 사용하는 방식</li>
  <li>클라이언트는 마치 로컬에 있는 프로시저를 실행하듯 사용 -&gt; 실제로는 원격의 주소 공간에 있는 프로세스에게 요청 -&gt; 원격에서 실행한 뒤 결과를 리턴</li>
  <li>(프로시저(procedure)는 서브루틴(subroutine)이 될 수도 있고, 서비스가 될 수도 있고, 함수가 될 수도 있다)</li>
  <li>MSA(Micro Service Architecture)패턴으로 서비스를 개발하는 환경에서 유용하게 활용됨</li>
  <li>RPC는 Java, Python, Go와 같은 다양한 언어로 구현할 수 있음</li>
  <li>RPC는 프로세스간 통신 과정을 추상화</li>
  <li>네트워크 장비, 프로토콜, 운영체제에 무관하게 개발 가능</li>
</ul>

<p><img src="/images/rpc_2.png" alt="" /></p>

<h2 id="when-the-client-calls-the-server-the-rpc-system-must-take-care-of">When the client calls the server, the RPC system must take care of:</h2>

<ul>
  <li>Taking all the parameters which are passed to the subroutine and transferring them to the remote node;</li>
  <li>Having the subroutine executed on the remote node; and</li>
  <li>Transferring back all the parameters which are returned to the calling routine.</li>
</ul>

<p>The most common method of doing this is by the use of <strong>stub</strong> modules. The client program is linked to a client stub module. This is a subroutine which looks (from the outside) in every respect like the remote subroutine. On the inside, it is almost empty: all it does is take the values of the parameters which are passed to it, and put them in a message. This is known as <strong>marshalling</strong>.</p>

<p>The client stub then uses a routine in the RPC <strong>Run-Time System (RTS)</strong> to send the message off and wait for a reply message. When the reply arrives, the stub unmarshals the parameters that were returned in the reply message, putting their values into the variables of the calling program. The client stub then returns to the calling program just like a normal subroutine.</p>

<p>The server stub is located on the remote machine. It is called by the RPC run-time system when the message arrives from the client. The server stub performs the operations complementary to those of the the client stub: unmarshalling the parameters passed to the subroutine, calling the subroutine, and marshalling the return parameters.</p>

<p>All the communication details are handled by the RPC run-time system, so the stubs contain only the code which is specific to the application involved. Each stub handles a specific set of procedures known as a package.</p>

<p>In order to produce stub modules, one needs to know</p>

<ul>
  <li>The names of the procedures in the package</li>
  <li>The number of parameters which they take</li>
  <li>The data type of each parameter</li>
  <li>The direction in which each parameter is transferred.</li>
</ul>

<h2 id="the-following-steps-take-place-during-a-rpc">The following steps take place during a RPC</h2>

<p><img src="/images/rpc_1.png" alt="" /></p>

<ul>
  <li>A client invokes a client stub procedure, passing parameters in the usual way. The client stub resides within the client’s own address space.</li>
  <li>The client stub marshalls(pack) the parameters into a message. Marshalling includes converting the representation of the parameters into a standard format, and copying each parameter into the message.</li>
  <li>The client stub passes the message to the transport layer, which sends it to the remote server machine.</li>
  <li>On the server, the transport layer passes the message to a server stub, which demarshalls(unpack) the parameters and calls the desired server routine using the regular procedure call mechanism.</li>
  <li>When the server procedure completes, it returns to the server stub (e.g., via a normal procedure call return), which marshalls the return values into a message. The server stub then hands the message to the transport layer.</li>
  <li>The transport layer sends the result message back to the client transport layer, which hands the message back to the client stub.</li>
  <li>The client stub demarshalls the return parameters and execution returns to the caller.</li>
</ul>

<h2 id="장점">장점</h2>

<ul>
  <li>The technique of using procedure calls in RPC permits high-level languages to provide communication between clients and servers.</li>
  <li>This method is like a local procedure call but with the difference that the called procedure is executed on another process and a different computer.</li>
  <li>The thread-oriented model is also supported by RPC in addition to the process model.</li>
  <li>The RPC mechanism is employed to conceal the core message passing method.</li>
  <li>The amount of time and effort required to rewrite and develop the code is minimal.</li>
  <li>The distributed and local environments can both benefit from remote procedure calls.</li>
  <li>To increase performance, it omits several of the protocol layers.</li>
  <li>Abstraction is provided via RPC.  To exemplify, the user is not known about the nature of message-passing in network communication.</li>
  <li>RPC empowers the utilization of applications in a distributed environment.</li>
</ul>

<h2 id="단점">단점</h2>

<ul>
  <li>In Remote Procedure Calls parameters are only passed by values as pointer values are not allowed.</li>
  <li>It involves a communication system with another machine and another process, so this mechanism is extremely prone to failure.</li>
  <li>The RPC concept can be implemented in a variety of ways, hence there is no standard.</li>
  <li>Due to the interaction-based nature, there is no flexibility for hardware architecture in RPC.</li>
  <li>Due to a remote procedure call, the process’s cost has increased.</li>
</ul>

<h2 id="grpc">gRPC</h2>

<blockquote>
  <p>gRPC는 Google 에서 만든 RPC(Remote Procedure Call) 프로토콜이다. 네트워크 요청을 소프트웨어 내부에 있는 함수를 호출하듯이 사용하게 도와주는 프로토콜이다.</p>
</blockquote>

<p>Monolithic 구조에서는 하나의 프로그램으로 동작하기 때문에 그 안에서 구조적인 2개의 서비스간의 데이터는 공유 메모리를 통해서 주고받을 수 있습니다. 따라서 이 경우 서비스간 메시지 전송 성능은 큰 이슈가 되지 않습니다. 반면 MSA에서는 여러 모듈로 분리되어있고 동일 머신에 존재하지 않을 수 있습니다. 따라서 일반적으로는 보편화된 방식인 REST 통신을 통해 메시지를 주고 받습니다. 문제는 Frontend 요청에 대한 응답을 만들어내기 위해 여러 마이크로 서비스간의 협력이 필요하다면, 구간별 REST 통신에 따른 비효율로 인해 응답속도가 저하된다는 점입니다.</p>

<ul>
  <li>3 way handshake</li>
  <li>HTTP 헤더</li>
</ul>

<p>gRPC는 HTTP 2.0 기반위에서 동작하기 때문에 지금까지 HTTP 2.0의 특징에 대해서 살펴봤습니다. 짧게 정리하자면, Header 압축, Multiplexed Stream 처리 지원 등으로 인해 네트워크 비용을 많이 감소시켰습니다. 그렇다면 HTTP 2.0 특징을 제외한 gRPC만의 특징은 무엇이 있을까요? 먼저 REST API 통신의 문제점에 대해서 먼저 살펴본 다음 gRPC의 특징에 대해서 살펴보도록 하겠습니다.</p>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="https://austingwalters.com/introduction-to-ipc-interprocess-communication/">Austin G. Walters, Intro to IPC</a></li>
  <li><a href="https://dar0m.tistory.com/233" target="_blank">DR-kim, 프로세스간 통신 방법</a></li>
  <li><a href="https://heeonii.tistory.com/13" target="_blank">우당탕탕 히온이네, [운영체제] IPC 프로세스간 통신</a></li>
  <li><a href="https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&amp;blogId=bycho211&amp;logNo=220985701140" target="_blank">bycho211, 프로세스간 통신(IPC)</a></li>
  <li><a href="https://frozenpond.tistory.com/126" target="_blank">얼음연못, [개발상식] 프로세스간 통신(IPC)</a></li>
  <li><a href="https://nesoy.github.io/articles/2019-07/RPC" target="_blank">nesoy, RPC란?</a></li>
  <li><a href="https://velog.io/@jakeseo_me/RPC%EB%9E%80" target="_blank">jakeseo, RPC란?</a></li>
  <li><a href="https://www.w3.org/History/1992/nfs_dxcern_mirror/rpc/doc/Introduction/WhatIs.html" target="_blank">w3, What is Remote Procedure Call?</a></li>
  <li><a href="https://grpc.io/docs/what-is-grpc/" target="_blank">grpc공식문서, What is gRPC?</a></li>
  <li><a href="https://medium.com/naver-cloud-platform/nbp-%EA%B8%B0%EC%88%A0-%EA%B2%BD%ED%97%98-%EC%8B%9C%EB%8C%80%EC%9D%98-%ED%9D%90%EB%A6%84-grpc-%EA%B9%8A%EA%B2%8C-%ED%8C%8C%EA%B3%A0%EB%93%A4%EA%B8%B0-1-39e97cb3460" target="_blank">navercloud, [네이버클라우드 기술&amp;경험] 시대의 흐름, gRPC 깊게 파고들기 #1</a></li>
  <li><a href="https://cla9.tistory.com/175?category=993774" target="_blank">cla9, 1. gRPC 개요</a></li>
  <li><a href="https://tech.buzzvil.com/handbook/grpc/" target="_blank">buzzvil Tech, gRPC</a></li>
</ul>
:ET