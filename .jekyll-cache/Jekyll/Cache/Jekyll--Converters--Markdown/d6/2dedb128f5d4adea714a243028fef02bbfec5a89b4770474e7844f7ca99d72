I"âh<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#logì˜-ì¤‘ìš”ì„±" id="markdown-toc-logì˜-ì¤‘ìš”ì„±">Logì˜ ì¤‘ìš”ì„±</a></li>
  <li><a href="#mysqlì˜-ë¡œê·¸" id="markdown-toc-mysqlì˜-ë¡œê·¸">MySQLì˜ ë¡œê·¸</a></li>
  <li><a href="#mysql-ëª¨ë‹ˆí„°ë§ì„-ìœ„í•œ-ë¡œê·¸" id="markdown-toc-mysql-ëª¨ë‹ˆí„°ë§ì„-ìœ„í•œ-ë¡œê·¸">MySQL ëª¨ë‹ˆí„°ë§ì„ ìœ„í•œ ë¡œê·¸</a>    <ul>
      <li><a href="#general-query-log" id="markdown-toc-general-query-log">General Query Log</a></li>
      <li><a href="#slow-query-log" id="markdown-toc-slow-query-log">Slow Query Log</a></li>
      <li><a href="#error-log" id="markdown-toc-error-log">Error Log</a></li>
      <li><a href="#binary-log" id="markdown-toc-binary-log">Binary Log</a></li>
    </ul>
  </li>
  <li><a href="#íŠ¸ëœì­ì…˜-ì²˜ë¦¬ë¥¼-ìœ„í•œ-ë¡œê·¸" id="markdown-toc-íŠ¸ëœì­ì…˜-ì²˜ë¦¬ë¥¼-ìœ„í•œ-ë¡œê·¸">íŠ¸ëœì­ì…˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ ë¡œê·¸</a>    <ul>
      <li><a href="#undo-log" id="markdown-toc-undo-log">Undo Log</a></li>
      <li><a href="#redo-log" id="markdown-toc-redo-log">Redo Log</a></li>
      <li><a href="#binary-log-1" id="markdown-toc-binary-log-1">Binary Log</a></li>
    </ul>
  </li>
  <li><a href="#ì°¸ê³ " id="markdown-toc-ì°¸ê³ ">ì°¸ê³ </a></li>
</ul>

<hr />

<h1 id="logì˜-ì¤‘ìš”ì„±">Logì˜ ì¤‘ìš”ì„±</h1>

<p>MySQL is open-source relational databases, and you should learn how to use MySQL database logs to improve efficiency and security. It is crucial to understand how to diagnose and monitor the performance of a MySQL instance in the long run.</p>

<p>While using a MySQL instance in production, you will come across issues like <strong>slow queries, deadlocks, and aborted connections</strong>. <strong>Logging is essential to diagnosing these issues</strong>. A good understanding of your MySQL database logs will help you improve operations by reducing the mean time to recovery and the mean time between failures. Logs are also key to detecting and diagnosing <strong>security issues</strong> within your MySQL instance.</p>

<h1 id="mysqlì˜-ë¡œê·¸">MySQLì˜ ë¡œê·¸</h1>

<p>There are six types of log files in MySQL: redo log(WAL), undo log, binlog, error log, slow query log, general log, relay log. Redo logs and undo logs are closely related to transaction operations. Binlogs are also related to transaction operations. These three types of logs are important for understanding transaction operations in MySQL.</p>

<h1 id="mysql-ëª¨ë‹ˆí„°ë§ì„-ìœ„í•œ-ë¡œê·¸">MySQL ëª¨ë‹ˆí„°ë§ì„ ìœ„í•œ ë¡œê·¸</h1>

<p>While using a MySQL instance in production, you will come across issues like <strong>slow queries, deadlocks, and aborted connections</strong>. <strong>Logging is essential to diagnosing these issues</strong>. A good understanding of your MySQL database logs will help you improve operations by reducing the mean time to recovery and the mean time between failures.</p>

<p>Logs are also key to detecting and diagnosing security issues within your MySQL instance. In the event of a compromise, logs track the details of an attack and the actions taken by the attackers. This information provides context to your data and helps you take remedial action.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- General Query Log
- Slow Query Log
- Error Log
- Binary Log
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; show variables;
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Enable Logging on MySQL</span>
mysql&gt;SET GLOBAL general_log <span class="o">=</span> â€˜ONâ€™<span class="p">;</span>

<span class="c"># Logê°€ ì €ì¥ë˜ëŠ” íŒŒì¼ ê²½ë¡œ</span>
mysql&gt;SET GLOBAL general_log_file <span class="o">=</span> â€˜path_on_your_systemâ€™<span class="p">;</span>
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Enable Logging on MySQL</span>
mysql&gt;SET GLOBAL slow_query_log <span class="o">=</span> â€˜ONâ€™<span class="p">;</span>

<span class="c"># Logê°€ ì €ì¥ë˜ëŠ” íŒŒì¼ ê²½ë¡œ</span>
mysql&gt;SET GLOBAL slow_query_log_file <span class="o">=</span> â€˜path_on_your_systemâ€™<span class="p">;</span>
</code></pre></div></div>

<h2 id="general-query-log">General Query Log</h2>

<p>As the name implies, the general query log is a general record of what MySQL is doing. Information is written to this log when clients connect or disconnect to the server. The server also logs each SQL statement it receives from clients. If you suspect an error in a client, you can know exactly what the client sent to the MySQL instance by looking at the general query log.</p>

<p>You should be aware that MySQL writes statements to the general query log in the order in which it receives them. The order might differ from the order in which the queries are executed because, unlike other log formats, the query is written to this log file before MySQL even attempts to execute the query. MySQL database logs are therefore perfect for debugging MySQL crashes.</p>

<p>Since the general query log is a record of every query received by the server, it can grow large quite quickly. If you only want a record of queries that change data, it might be better to use the binary log instead (more on that later).</p>

<h2 id="slow-query-log">Slow Query Log</h2>

<p>As applications scale in size, queries that were once extremely fast can become quite slow. When youâ€™re debugging a MySQL instance for performance issues, the slow query log is a good starting place to see which queries are the slowest and how often they are slow.</p>

<p>The slow query log is the MySQL database log queries that exceed a given threshold of execution time. By default, all queries taking longer than 10 seconds are logged.</p>

<p><strong>Configuration options</strong><br />
You can change the threshold query execution time by setting the value of the <code class="language-plaintext highlighter-rouge">long_query_time</code> system variable. It uses a unit of seconds, with an optional milliseconds component.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SET</span> <span class="k">GLOBAL</span> <span class="n">long_query_time</span> <span class="o">=</span> <span class="mi">5</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>
<p>To verify if the slow query log is working properly, you can execute the following query with a time greater than the value of the <code class="language-plaintext highlighter-rouge">long_query_time</code>.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">SLEEP</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
</code></pre></div></div>

<p>Queries not using indexes are often good candidates for optimization. The <code class="language-plaintext highlighter-rouge">log_queries_not_using_indexes</code> system variable can be switched on to make MySQL log all queries that do not use an index to limit the number of rows scanned. In this case, logging occurs regardless of execution time of the query.</p>

<h2 id="error-log">Error Log</h2>

<h2 id="binary-log">Binary Log</h2>

<h1 id="íŠ¸ëœì­ì…˜-ì²˜ë¦¬ë¥¼-ìœ„í•œ-ë¡œê·¸">íŠ¸ëœì­ì…˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ ë¡œê·¸</h1>

<p>ë°ì´í„°ë² ì´ìŠ¤ëŠ” ë³´í†µ íŠ¸ëœì­ì…˜ ìˆ˜í–‰ì„ ìœ„í•´ ë¡œê·¸ë¥¼ ì‚¬ìš©í•œë‹¤. ë³´í†µ ì´ëŸ¬í•œ ì—­í• ì„ ìˆ˜í–‰í•˜ëŠ” ë¡œê·¸ë¥¼ íŠ¸ëœì­ì…˜ ë¡œê·¸ë¼ê³  í•˜ë©° MySQLì˜ ê²½ìš° Redo Log, Undo Log, Binary Logê°€ ì´ì— í•´ë‹¹í•œë‹¤. Undo LogëŠ” íŠ¸ëœì­ì…˜ì˜ Atomicity, Redo LogëŠ” Durabilityë¥¼ ì œê³µí•´ì¤€ë‹¤.</p>

<p>MySQLì€ ë””ìŠ¤í¬ì˜ I/Oìœ¼ë¡œ ì¸í•œ ì„±ëŠ¥ ì €í•˜ë¥¼ ì¤„ì´ê¸° ìœ„í•´ ìºì‹± ë©”ì»¤ë‹ˆì¦˜ì„ ì‚¬ìš©í•œë‹¤.</p>

<p>ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ìˆ˜ì •í•˜ëŠ” ì¿¼ë¦¬ê°€ ë“¤ì–´ì˜¤ë©´, InnoDBëŠ” ë¨¼ì € ë©”ëª¨ë¦¬ì— ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ê³ , ì—†ìœ¼ë©´ ë””ìŠ¤í¬ì—ì„œ ë¶ˆëŸ¬ì™€ ë©”ëª¨ë¦¬ì— ì˜¬ë¦¬ê³  ë°ì´í„°ë¥¼ ìˆ˜ì •í•œë‹¤. ì´ë ‡ê²Œ ë©”ëª¨ë¦¬ì—ì„œë§Œ ê³„ì† ì½ê³  ì“°ê²Œë˜ë©´ ì¥ì• ë¡œ ì„œë²„ê°€ ì¢…ë£Œë  ë•Œ ë°ì´í„°ê°€ ë‚ ì•„ê°€ê²Œ ëœë‹¤. ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ MySQLì—ì„œëŠ” Redo Logë¥¼ ì‚¬ìš©í•œë‹¤. ë” ìì„¸í•œ ë‚´ìš©ì€ ë°‘ì—ì„œ ì‚´í´ë³¼ ê²ƒì´ë‹¤. ë˜í•œ ë°ì´í„° ìˆ˜ì • ì¿¼ë¦¬ê°€ ë“¤ì–´ì˜¬ ë•Œë§ˆë‹¤ ë©”ëª¨ë¦¬ì˜ ë°ì´í„°ë¥¼ ë°”ë¡œ ìˆ˜ì •í•˜ì§€ëŠ” ì•Šê³ , ì´ ì „ ê°’ì„ Undo Logì— ë³´ê´€í•´ë‘ê³  ìˆ˜ì •ì„ ê°€í•¨ìœ¼ë¡œì¨, íŠ¸ëœì­ì…˜ì´ ì‹¤íŒ¨í•  ê²½ìš° ë°ì´í„°ë¥¼ ë¡¤ë°±(Roll back)í•  ì¤€ë¹„ë¥¼ í•œë‹¤. ì´ ë‚´ìš©ë„ ë°‘ì—ì„œ ë” ìì„¸íˆ ì‚´í´ë³´ì.</p>

<p>(ì°¸ê³ ë¡œ ë””ìŠ¤í¬ì— ìˆëŠ” íŒŒì¼ì¤‘ ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” íŒŒì¼ì„ ë°ì´í„° íŒŒì¼, ë¡œê·¸ë¥¼ ì €ì¥í•˜ë¥¼ íŒŒì¼ì„ ë¡œê·¸ íŒŒì¼ì´ë¼ê³  í•¨)</p>

<p>(ë©”ëª¨ë¦¬ì— ìˆëŠ” ë²„í¼ì¤‘ ë°ì´í„° í˜ì´ì§€ë¥¼ ìºì‹œí•´ë†“ëŠ” ìœ„ì¹˜ë¥¼ ë°ì´í„° ë²„í¼, ë¡œê·¸ë¥¼ ìºì‹œí•´ë†“ëŠ” ìœ„ì¹˜ë¥¼ ë¡œê·¸ ë²„í¼ë¼ê³  í•¨)</p>

<p>(InnoDBì—”ì§„ì´ ë°ì´í„°ë¥¼ ì½ê³  ì“¸ ë•ŒëŠ” í•´ë‹¹í•˜ëŠ” ë°ì´í„°ì™€ ì¸ë±ìŠ¤ë¥¼ ë©”ëª¨ë¦¬ ë²„í¼ í’€ì— ì˜¬ë ¤ë‘”ë‹¤.)</p>

<p><strong>Memory Buffer pool</strong>: occupies the largest block of memory. The cache used to store various data includes index pages, data pages, undo pages, insert buffers, adaptive hash indexes, lock information stored in innodb, data dictionary information, etc. The working method always reads the database file into the buffer pool by page (16k per page), and then retains the cached data in the buffer pool according to the least recently used (lru) algorithm. If the database file needs to be modified, always modify the page in the buffer pool first (dirty page after the modification occurs), and then flush the dirty page of the buffer pool to the file at a certain frequency.</p>

<h2 id="undo-log">Undo Log</h2>

<p>Undo log is to achieve atomicity of transactions. Undo Log is also used to implement multi-version concurrency control (referred to as: MVCC).</p>

<ul>
  <li>Undo logëŠ” íŠ¸ëœì­ì…˜ì˜ Atomicity íŠ¹ì„±ì„ ì§€í‚¤ê¸° ìœ„í•œ ë¡œê·¸</li>
  <li>Undo logëŠ” MVCC(multi-version concurrency control)ë¥¼ ìœ„í•´ì„œë„ ì‚¬ìš©</li>
</ul>

<p><strong>Internal mechanism of delete/update operation</strong></p>

<p>When the transaction is not committed, InnoDB will not delete the undo log immediately, because the undo log may be used later. For example, when the isolation level is repeatable read, the transaction reads the latest committed row version when the transaction is started, as long as the transaction is not over, the row version cannot be deleted, that is, the undo log cannot be deleted.</p>

<p>But when the transaction is committed, the undo log corresponding to the transaction will be put into the delete list, and will be deleted by purge in the future.</p>

<p>The principle of Undo Log is very simple. In order to satisfy the atomicity of transactions, before operating any data, first back up the data to a place (this place where data backup is stored is called Undo Log). Then modify the data. If an error occurs or the user executes a ROLLBACK statement, the system can use the backup in Undo Log to restore the data to the state before the transaction started.</p>

<p>Suppose there are two data, A and B, with values 1, 2 respectively. Perform a +2 transaction operation. A. The transaction begins.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Record A=1 to undo log. 
- Modify A=3. 
- Record B=2 to undo log. 
- Modify B=4. 
- Write undo log to disk. 
- Write data to disk. 
</code></pre></div></div>

<p>The reason why atomicity and persistence can be guaranteed at the same time is because of the following characteristics:</p>

<ul>
  <li>Record Undo log before updating data.</li>
  <li>In order to ensure durability, data must be written to disk before the transaction is committed. As long as the transaction is successfully submitted, the data must have been persisted.</li>
  <li>Undo log must be persisted to disk before data. If the system crashes between transaction, the undo log is complete and can be used to roll back the transaction.</li>
</ul>

<h2 id="redo-log">Redo Log</h2>

<p>Redo log is to save the executed SQL statement to a specified Log file. When mysql performs data recovery, you can re-execute the SQL operation recorded by the redo log. The introduction of the buffer pool will cause the updated data to not be persisted to the disk in real time. When the system crashes, although the data in the buffer pool is lost and the data is not persisted, the system can restore all data to the latest according to the content of the Redo Log status. The redo log exists as a separate file on the disk. There will be two files by default, named ib_logfile0 and ib_logfile1.</p>

<p>The parameter innodb_log_file_size specifies the size of the redo log innodb_log_file_in_group specifies the number of the redo log, and the default is 2; innodb_log_group_home_dir specifies the path where the redo log is located.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>innodb_additional_mem_pool_size = 100M
innodb_buffer_pool_size = 128M
innodb_data_home_dir =/home/mysql/local/mysql/var
innodb_data_file_path = ibdata1:1G: autoextend
innodb_file_io_threads = 4
innodb_thread_concurrency = 16
innodb_flush_log_at_trx_commit = 1
innodb_log_buffer_size = 8M
innodb_log_file_size = 128M
innodb_log_file_in_group = 2
innodb_log_group_home_dir =/home/mysql/local/mysql/var
</code></pre></div></div>

<p>In order to satisfy the atomicity of the transaction, before operating any data, first back up the data to Undo Log, and then modify the data. If an error occurs or the user executes the ROLLBACK statement, the system can use the backup in Undo Log to restore the data to the state before the transaction started. Unlike redo log, there is no separate undo log file on the disk, it is stored in a special segment (segment) inside the database, which is called the undo segment, and the undo segment is located in the shared table space.</p>

<p>The undo log and redo log itself are separate. Innodbâ€™s undo log is recorded in the data file (ibd), and innodb regards the content of the undo log as data, so the operation of the undo log itself (such as inserting an undo record into the undo log, etc.) will record redo log. The undo log does not need to be persisted to disk immediately. Even if it is lost, it can be restored through redo log. So when inserting a record:</p>

<ul>
  <li>Insert an undo log record into the undo log.</li>
  <li>Insert a redo log record of â€œinsert undo log recordâ€ into the redo log.</li>
  <li>Insert data.</li>
  <li>Insert an â€œinsertâ€ redo log record into the redo log.</li>
</ul>

<p><strong>Redo log io performance</strong></p>

<p>In order to ensure that Redo Log has better IO performance, InnoDBâ€™s Redo Log is designed with the following features:</p>

<p>Try to keep Redo Log stored in a continuous space. Therefore, the log file space is completely allocated when the system is first started. The Redo Log is recorded in sequential addition.<br />
Write logs in batches. The log is not written directly to the file, but first written to the redo log buffer, and then the data in the buffer is written to the disk every second
Concurrent transactions share the storage space of Redo Log, and their Redo Logs are recorded together alternately according to the execution order of statements to reduce the space occupied by the log.<br />
Redo Log only performs sequential append operations. When a transaction needs to be rolled back, its Redo Log records will not be deleted from Redo Log.</p>

<p>Contrary to Undo Log, Redo Log records a backup of new data. Before the transaction is committed, only the Redo Log needs to be persisted, and the data does not need to be persisted. When the system crashes, although the data is not persisted, Redo Log has persisted. The system can restore all data to the latest state according to the content of Redo Log.</p>

<p><strong>Simplified process of Undo + Redo transaction</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A. Transaction start. B. Record A=1 to undo log. 
C. Modify A=3. 
D. Record A=3 to redo log. 
E. Record B=2 to undo log. 
F. Modify B=4. 
G . Record B=4 to redo log. 
H. Write redo log to disk. 
I. Transaction commit
</code></pre></div></div>

<p>The AG process is carried out in memory, and the corresponding operations are recorded in redo log buffer (B&amp;E), redo log buffer (E&amp;G), transaction execution results (not submitted at this time) are also stored in db buffer (C&amp;F), and the buffer is full If the number of transactions stored in the buffer is all 1, it means that the log is flushed to the disk immediately, and the data consistency is well guaranteed. If there are multiple storages, the redo log will be synchronized to the disk after a transaction is completed and there will be a status bit to record whether it is committed, then the transaction is actually committed, and the data in the db buffer will be synchronized to the disk of the DB. . To ensure that the contents of the db buffer are written to the disk database file, the contents of the log buffer should be written to the disk log file. This approach can reduce disk IO and increase throughput. However, this method is suitable for scenarios where consistency is not high. Because if there is a system failure such as a power failure, the completed transactions in the log buffer and db buffer have not been synchronized to the disk will be lost. For banks such as banks that require higher transaction consistency, it is necessary to ensure that each transaction is recorded to the disk. If the server is down, go to the redo log to recover and redo the committed transaction.</p>

<p><strong>the role of redo &amp; undo log</strong></p>

<ul>
  <li>Data persistence
    <ul>
      <li>The buffer pool maintains a linked list in the order of dirty page modification, called flush_list. Flush data to persistent storage according to the order of pages in flush_list. The pages are arranged in the order of the earliest modification. Under normal circumstances, when is the dirty page flushed to the disk?
        <ul>
          <li>When the redo space is full, part of the dirty page will be flushed to the disk, and then part of the redo log will be released.</li>
          <li>When you need to allocate a page in the Buffer pool, but it is full, you must flush dirty pages to disk. Generally, this situation can be controlled by the startup parameter innodb_max_dirty_pages_pct. When the dirty page in the buffer pool reaches this ratio, the dirty page is flushed to the disk.</li>
          <li>When the system is detected to be idle, it will flush.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Data Recovery
    <ul>
      <li>Over time, Redo Log will become very large. If you start to recover from the first record every time, the recovery process will be very slow and cannot be tolerated. In order to reduce the recovery time, the Checkpoint mechanism is introduced. Suppose that at a certain point in time, all dirty pages have been flushed to disk. All Redo Logs before this time point do not need to be redone. The system records the end of the redo log at this point in time as the checkpoint. When restoring, just start from this checkpoint position. The log before the checkpoint point is no longer needed and can be deleted.</li>
    </ul>
  </li>
</ul>

<h2 id="binary-log-1">Binary Log</h2>

<p>The redo log is specific to the InnoDB engine and keeps data safe, but how do other engines log data?</p>

<p>At the Server level, MySQL has its own log, that is bin-log (an archived log). You must look at MySQL in isolation. MySQL = Server + different data storage engines, not as a whole.</p>

<p>Binlog records a binary log of all changes to the MySQL database table structure and table data, but not the select and show queries. bin-loglogs are logged as events and include the time consumed by the statements.</p>

<p>The two most important scenarios for turning on Binlog logging are as follows:</p>

<ul>
  <li>Parent-Child replication: enable the Binlog function in the primary library, so that the primary library can pass Binlog to the secondary library, and the secondary library can get Binlog and achieve data recovery to achieve primary-secondary data consistency.</li>
  <li>Data recovery: recover data through tools such as mysqlbinlog.
Bin-log files are logged in three modes: statement, rowand mixed, with row mode usually being used.</li>
</ul>

<p><strong>The difference between bin log and redo log.</strong></p>

<ul>
  <li>The content is different: redo log is a physical log and the content is based on the Page on disk, bin-log content is binary and depending on the binlog_format parameter, may be based on SQL statements, on the data itself, or a mixture of the two.</li>
  <li>Different levels: redo log works with InnoDB and the engine, bin-log is located at the MySQL Server level and is available to all engines.</li>
  <li>Different forms of disk storage: redo log writes cyclically, bin-log accumulates, so it can be used for data recovery or primary-secondary synchronization</li>
  <li>The timing of writing is different: bin-logare written when a transaction usually commits or when N transactions commit once, redo log are written at a variety of times, either every time a transaction commits, by another threaded transaction, or every second when the disk is flushed. (Note: uncommitted transactions in redo log may also be flushed to disk)</li>
  <li>Different roles: redo log is used for crash recovery to ensure that MySQL downtime does not affect persistence; bin-log is used for point-in-time recovery to ensure that the server can recover data based on the point in time, in addition bin-log is also used for primary-secondary replication.</li>
</ul>

<p><strong>Two-phase Commit</strong><br />
Because redo-logis in the InnoDB tier and bin-logis in the Server tier, this introduces a new problem.</p>

<p>If the redo log is written successfully and the bin-log crashes before it is written to disk, the transaction has not yet been committed, so the new data written to the redo-log is invalid.</p>

<p>Restarting the database for data recovery restores the data in the redo-log to disk, which creates invalid data.</p>

<p>In this case, as you wisely know, a two-phase commit is introduced.</p>

<p>In the first stage, the redo-log is written and in the prepared state. After the Server layer saves the bin-log data and drops it to disk, the transaction commits the redo-log at the same time, so that the redo-log becomes committed, which ensures the consistency of the redo-log data and the bin-log data.</p>

<p><strong>The Execution of an Update Statement</strong></p>

<p>With the previous knowledge, you can now explore how the update statement is executed in MySQL.</p>

<p>Suppose we now execute the SQL : update table_test set a = a+1 where id = 2;</p>

<ul>
  <li>First, the client connects via the connector and determines the permissions.</li>
  <li>After verification, the SQL goes through the parser for lexical and syntax analysis (AST) and if it is an Update statement, MySQL will clear all the query cache for the query table table_test. (As you can see, it is not recommended to turn on the query cache)</li>
  <li>The optimizer optimizes the validated SQL, plans to match the id index, and generates an execution plan.</li>
  <li>The executor gets the final SQL and calls the interface of the corresponding storage engine to start executing the update SQL.</li>
  <li>The InnoDB engine opens a transaction, the execution engine first queries from memory whether there is data with id=2, if it matches then the corresponding data with field+1, and then saves it to memory. If it does not query the data with id=2 then it will go to the disk, the query will read the data into memory in pages, then update it and save it to memory.</li>
  <li>The InnoDB engine will then save the data rows to redo-log, which is pre-committed, notifying the Serverâ€™s executor that it is ready to commit the transaction.</li>
  <li>The executor will generate the corresponding bin-log and write it to disk.</li>
  <li>The transaction is committed and the redo-log is then committed.</li>
  <li>This is where the execution of a transaction is complete.</li>
</ul>

<h1 id="ì°¸ê³ ">ì°¸ê³ </h1>
<ul>
  <li><a href="https://bourbonkk.tistory.com/86" target="_blank">í•´ì»¤ì˜ ê°œë°œì¼ê¸°, ë°ì´í„°ë² ì´ìŠ¤ì˜ ë¬´ê²°ì„±ì„ ë³´ì¥í•´ì£¼ëŠ” Write-Ahead-Log</a></li>
  <li><a href="https://www.alibabacloud.com/blog/what-are-the-differences-and-functions-of-the-redo-log-undo-log-and-binlog-in-mysql_598035" target="_blank">alibabacloud, What are the Differences and Functions of the Redo Log, Undo Log, and Binlog in MySQL?</a></li>
  <li><a href="https://coralogix.com/blog/5-essential-mysql-database-logs-to-keep-an-eye-on/" target="_blank">Coralogix, 5 Essential MySQL Database Logs To Keep an Eye On</a></li>
  <li><a href="https://scaling.dev/replication/log" target="_blank">scaling.dev, Transaction Log. Commit Log. WAL.</a></li>
  <li><a href="https://www.postgresql.org/docs/current/wal-intro.html" target="_blank">PostgreSQL ê³µì‹ë¬¸ì„œ, Write-Ahead Logging (WAL)</a></li>
  <li><a href="https://betterprogramming.pub/mysqls-redolog-and-binlog-1a35bc052489" target="_blank">Dwen, MySQLâ€™s RedoLog and BinLog</a></li>
  <li><a href="https://developpaper.com/you-must-understand-the-three-mysql-logs-binlog-redo-log-and-undo-log/" target="_blank">developPAPER, You must understand the three MySQL logs â€“ binlog, redo log and undo log</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-redo-log.html" target="_blank">MySQL ê³µì‹ë¬¸ì„œ, 14.6.6 Redo Log</a></li>
  <li><a href="https://blog.katastros.com/a?ID=01200-5fbbae7f-7eb9-4570-876c-23048d66fb82" target="_blank">Katastros, InnoDB transaction log (redo log and undo log) detailed</a></li>
  <li><a href="https://github.com/heesuk-ahn/today-I-learned/blob/master/database/binary-log.md" target="_blank">heesuk-ahn, [ë°ì´í„°ë² ì´ìŠ¤] binary log ë€?</a></li>
  <li><a href="https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/binary-log.html" target="_blank">The Binary Log</a></li>
  <li><a href="https://jvns.ca/blog/2017/06/11/log-structured-storage/" target="_blank">Log-structured storage</a></li>
</ul>
:ET