I"<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#프로세스" id="markdown-toc-프로세스">프로세스</a>    <ul>
      <li><a href="#프로세스의-네-가지-상태" id="markdown-toc-프로세스의-네-가지-상태">프로세스의 네 가지 상태</a></li>
      <li><a href="#프로세스의-구조" id="markdown-toc-프로세스의-구조">프로세스의 구조</a></li>
      <li><a href="#프로세스의-생성과-복사" id="markdown-toc-프로세스의-생성과-복사">프로세스의 생성과 복사</a></li>
      <li><a href="#프로세스의-전환" id="markdown-toc-프로세스의-전환">프로세스의 전환</a></li>
      <li><a href="#프로세스의-계층-구조" id="markdown-toc-프로세스의-계층-구조">프로세스의 계층 구조</a></li>
    </ul>
  </li>
  <li><a href="#스레드" id="markdown-toc-스레드">스레드</a></li>
  <li><a href="#프로세스-간-통신" id="markdown-toc-프로세스-간-통신">프로세스 간 통신</a>    <ul>
      <li><a href="#동기화" id="markdown-toc-동기화">동기화</a></li>
      <li><a href="#프로세스-간-통신의-종류" id="markdown-toc-프로세스-간-통신의-종류">프로세스 간 통신의 종류</a>        <ul>
          <li><a href="#전역-변수를-이용한-통신" id="markdown-toc-전역-변수를-이용한-통신">전역 변수를 이용한 통신</a></li>
          <li><a href="#파일을-이용한-통신" id="markdown-toc-파일을-이용한-통신">파일을 이용한 통신</a></li>
          <li><a href="#소켓을-이용한-통신" id="markdown-toc-소켓을-이용한-통신">소켓을 이용한 통신</a></li>
        </ul>
      </li>
      <li><a href="#임계구역" id="markdown-toc-임계구역">임계구역</a>        <ul>
          <li><a href="#임계구역-해결-조건" id="markdown-toc-임계구역-해결-조건">임계구역 해결 조건</a></li>
          <li><a href="#임계구역-해결-방법" id="markdown-toc-임계구역-해결-방법">임계구역 해결 방법</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#교착-상태" id="markdown-toc-교착-상태">교착 상태</a>    <ul>
      <li><a href="#자원-할당-그래프" id="markdown-toc-자원-할당-그래프">자원 할당 그래프</a></li>
      <li><a href="#교착-상태-필요조건" id="markdown-toc-교착-상태-필요조건">교착 상태 필요조건</a></li>
      <li><a href="#교착-상태-해결방법" id="markdown-toc-교착-상태-해결방법">교착 상태 해결방법</a>        <ul>
          <li><a href="#교착-상태-검출과-회복" id="markdown-toc-교착-상태-검출과-회복">교착 상태 검출과 회복</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#멀티-프로세싱-멀티-스레딩-동시성-프로그래밍-그리고-비동기-프로그래밍" id="markdown-toc-멀티-프로세싱-멀티-스레딩-동시성-프로그래밍-그리고-비동기-프로그래밍">멀티 프로세싱, 멀티 스레딩, 동시성 프로그래밍 그리고 비동기 프로그래밍</a>    <ul>
      <li><a href="#멀티-태스킹" id="markdown-toc-멀티-태스킹">멀티 태스킹</a></li>
      <li><a href="#멀티-프로세싱" id="markdown-toc-멀티-프로세싱">멀티 프로세싱</a></li>
      <li><a href="#멀티-스레딩" id="markdown-toc-멀티-스레딩">멀티 스레딩</a></li>
      <li><a href="#멀티-스레딩과-비동기-프로그래밍은-다르다" id="markdown-toc-멀티-스레딩과-비동기-프로그래밍은-다르다">멀티 스레딩과 비동기 프로그래밍은 다르다</a></li>
      <li><a href="#콜백-함수" id="markdown-toc-콜백-함수">콜백 함수</a></li>
      <li><a href="#thread-safe" id="markdown-toc-thread-safe">Thread Safe</a></li>
      <li><a href="#멀티-코어를-가진-cpu-1개-vs-싱글-코어를-가진-cpu-여러개" id="markdown-toc-멀티-코어를-가진-cpu-1개-vs-싱글-코어를-가진-cpu-여러개">멀티 코어를 가진 CPU 1개 vs 싱글 코어를 가진 CPU 여러개</a></li>
    </ul>
  </li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>
<hr />

<h1 id="프로세스">프로세스</h1>
<p>프로세스 관리는 운영체제의 핵심적인 역할</p>

<p>프로세스가 생성되고 작업을 마칠 때까지의 상태 변화</p>

<p>프로세스와 스레드 비교</p>

<p>스레드 사용의 이점</p>

<p>운영체제에서 프로세스는 하나의 작업 단위</p>

<p>프로그램을 실행하면 프로세스가 된다</p>

<p>프로그램은 하드디스크 같은 저장장치에 저장</p>

<p>프로그램을 실행하면 해당 코드가 메모리에 올라와서 작업이 진행된다</p>

<p>프로그램은 저장장치에 저장되어 있는 정적인 상태</p>

<p>프로세스는 실행을 위해 메모리에 올라온 동적인 상태</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>프로그램 - 클래스 - 레시피

프로세스 - 객체  - 요리
</code></pre></div></div>

<p>CPU가 시간을 쪼개어 여러 프로세스에 적당히 배분함으로써 동시에 실행하는 것처럼 느껴진다</p>

<h2 id="프로세스의-네-가지-상태">프로세스의 네 가지 상태</h2>

<p>시분할 방식에서의 예상치 못한 상황 처리</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>새우튀김을 해야하는데 새우가 아직 손질되지 않았다고 가정해보자. 메인 셰프가 보조 요리사에게 새우 손질을 지시한다  
그동안 메인 셰프가 아무것도 하지 않으면 비효율적이다.  
메인 셰프는 새우튀김을 '대기 목록'(대기 상태)으로 옮기고 주문 목록(준비 상태)에 있는 다른 주문서를 가져와서 요리를 해야한다.  

새우 손질이 끝났다고 가정해보자. 그렇다고 바로 대기 목록에서 새우튀김을 가져와서 바로 요리하지는 않는다.  

우선 현재 작업 중이던 요리를 마친 뒤 새우튀김을 만드는 것이 좋다. 따라서 새우튀김 요리 주문서를 대기 목록에서 주문 목록 뒤에 이동시킨 뒤 순서를 기다린다.  
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>손님이 급한 볼일을 보느라 음식을 천천히 달라고 요청하는 경우도 있다. 손님의 지연 요청은 언제 끝날지 알 수 없기 때문에 무작정 대기 목록에 올려둘 수 없다. (손님이 지연 끝에 취소를 할 수도 있다)  

이와 같이 언제 다시 시작될지 모르는 주문서는 '보류 목록'으로 옮기고, 손님이 음식을 달라고 하면 보류 목록에 있는 주문서를 '주문 목록'으로 보낸다.  
보류 목록은 언제 다시 시작될지 모르거나, 중간에 그만둘지 모르는 작업들을 모아두는 곳이다
</code></pre></div></div>

<p>현대의 운영체제는 시분할 방식을 기본으로 사용한다. 프로세스가 여러 상태를 오가며 실행된다. 그렇다면 운영체제가 어떻게 여러 프로세스를 함께 처리하는지 살펴보자.</p>

<p><strong>프로그램에서 프로세스로의 전환</strong></p>

<p>프로세스는 컴퓨터 시스템의 작업 단위로 태스크라고도 불린다.</p>

<p>시분할 방식 시스템에서 프로그램이 프로세스로 전환될 때 어떤 일이 일어나는지 살펴보자</p>

<p>우선 운영체제는 프로그램을 메모리의 적당한 위치로 가져온다. 그와 동시에 주문서에 해당하는 작업 지시서(프로세스 제어블록)를 만든다. 프로세스 제어블록에는 프로세스를 처리하는 데 필요한 다양한 정보가 들어 있다. 프로그램이 프로세스로 전환되려면 운영체제로부터 프로세스 제어블록을 받아야 한다. (프로세스 제어블록은 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에 운영체제 영역에 만들어진다) 프로세스가 종료되면 메모리에서 삭제되고, 프로세스 제어블록도 폐기된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>프로세스 제어블록에 포함된 대표적인 정보

- 프로세스 구분자: 프로세스를 구분하는 구분자(PID)

- 메모리 관련 정보: 프로세스가 올라가 있는 메모리의 위치 정보

- 각종 중간값: 프로세스가 사용했던 각종 중간값 (시분할 시스템이기 때문에 중간값을 저장해야 한다) 
            (ex. 다음 작업할 코드의 위치가 담긴 프로그램 카운터, 각종 중간값을 보관 중인 레지스터)
</code></pre></div></div>

<p><img src="/images/os_3.png" alt="" /></p>

<p><strong>프로세스의 상태</strong></p>

<p>앞서 레스토랑의 예에서 주문서가 다양한 목록을 옮겨 다니는 것과 같이, 운영체제에서도 여러 가지 이유로 프로세스 상태가 변화된다. 시분할 시스템에서 프로세스는 CPU 리소스를 넘겨주고 다시 받고 하는 일이 빈번하게 일어난다. 프로세스는 상황에 따라 다섯 가지 상태를 오간다.</p>

<ul>
  <li><strong>생성 상태</strong>
    <ul>
      <li>프로세스가 메모리에 올라와 실행 준비를 완료한 상태</li>
      <li>프로세스를 관리하는데 필요한 프로세스 제어블록이 생성됨</li>
    </ul>
  </li>
  <li><strong>준비 상태</strong>
    <ul>
      <li>생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태</li>
      <li>디스패치: CPU 스케줄러가 준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일</li>
    </ul>
  </li>
  <li><strong>실행 상태</strong>
    <ul>
      <li>준비 상태에 있던 프로세스가 CPU를 얻어 실제 작업을 수행하는 상태</li>
      <li>프로세스 제어블록을 CPU에 전달</li>
      <li>주어진 시간내 작업이 끝나지 않은 경우 다시 준비 상태로 돌아감(클록이 인터럽트를 사용해 CPU에 알림)</li>
      <li>작업이 끝날때까지 준비 상태와 실행 상태를 왔다 갔다함</li>
    </ul>
  </li>
  <li><strong>완료 상태</strong>
    <ul>
      <li>실행 상태의 프로세스가 시간내 작업을 마치면 완료 상태로 진입</li>
      <li>프로세스 제어블록이 사라진 상태</li>
    </ul>
  </li>
  <li><strong>대기 상태</strong>
    <ul>
      <li>프로세스가 입출력을 요청하면 입출력 관리자가 입출력을 완료하기 전까지 프로세스를 대기 상태로 옮겨둔다</li>
      <li>입출력 관리자가 입출력을 완료하면 프로세스를 대기 상태에서 준비 상태로 옮긴다</li>
    </ul>
  </li>
</ul>

<p><img src="/images/os_5.png" alt="" /></p>

<p><strong>컨텍스트 스위칭</strong></p>

<p>컨텍스트 스위칭(context switching)은 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다. 이 때 두 프로세스 제어블록의 내용이 변경된다. 실행 상태에서 나가는 프로세스 제어블록에는 CPU에 있던 지금까지의 작업 내용을 저장하고, 반대로 실행 상태로 들어오는 프로세스 제어블록의 내용으로 CPU를 다시 세팅한다. 이와 같이 두 프로세스의 프로세스 제어블록을 교환하는 작업을 컨텍스트 스위칭이라 한다.</p>

<p>컨텍스트 스위칭은 인터럽트가 걸렸을 때 발생한다.</p>

<ul>
  <li>타임아웃 인터럽트: 프로세스가 할당받은 시간을 초과한 경우</li>
  <li>Out-Of-Memory 인터럽트: 프로세스가 할당받은 메모리를 초과한 경우</li>
</ul>

<h2 id="프로세스의-구조">프로세스의 구조</h2>

<p><img src="/images/os_7.png" alt="" /></p>

<ul>
  <li><strong>코드 영역</strong>
    <ul>
      <li>프로그램의 코드가 기술된 곳으로 텍스트 영역이라고도 함</li>
      <li>자기 자신을 수정하는 프로그램은 존재하지 않기 때문에, 코드는 읽기 전용으로 처리</li>
    </ul>
  </li>
  <li><strong>데이터 영역</strong>
    <ul>
      <li>코드가 실행되면서 사용되는 변수나 파일 등의 각종 데이터를 모아놓는 곳</li>
      <li>변수는 기본적으로 읽기와 쓰기가 가능</li>
    </ul>
  </li>
  <li><strong>스택 영역</strong>
    <ul>
      <li>프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳</li>
      <li>예를들어, 함수가 호출되면 함수를 수행하고 마치면 다시 되돌아올 위치를 이 영역에 저장</li>
      <li>스택 영역은 운영체제가 사용자의 프로세스를 작동하기 위해 유지하는 영역이므로 사용자에게는 보이지 않음</li>
    </ul>
  </li>
  <li><strong>힙 영역</strong>
    <ul>
      <li>동적으로 할당되는 데이터들을 위해 존재하는 공간이다. ex) malloc</li>
    </ul>
  </li>
</ul>

<p>위의 특징 외에도 코드 영역과 데이터 영역은 선언할 때 그 크기가 결정되는 정적 영역이지만,<br />
스택 영역과 힙 영역은 프로세스가 실행되는 동안 크기가 늘어났다 줄어들기도 하는 동적 영역이다</p>

<p>원칙적으로 서로 다른 프로세스간의 메모리 공간 접근은 허용되지 않는다.<br />
만약 프로세스간 서로 다른 자원에 접근하려면 프로세스간의 통신을 해야한다.</p>

<h2 id="프로세스의-생성과-복사">프로세스의 생성과 복사</h2>

<p>프로세스는 프로그램을 실행할 때 새로 생성된다. 사용자가 프로그램을 실행하면 운영체제는 프로그램을 메모리에 가져와 코드 영역에 넣고 프로세스 제어블록을 생성한다. 그리고 메모리에 데이터 영역과 스택 영역을 확보한 후 프로세스를 실행한다.</p>

<p>프로세스를 새로 생성하는 방법뿐만 아니라 <strong>실행 중인 프로세스로부터 새로운 프로세스를 복사하는 방법</strong>도 있다.</p>

<p><strong>fork()</strong></p>

<p>커널이 제공하는 <code class="language-plaintext highlighter-rouge">fork()</code> 시스템 호출은 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수이다. 이 함수는 워드 프로그램, 브라우저 등에서 프로그램을 하나 더 실행할 때 전형적으로 호출된다. 이렇게 프로세스를 복사하게 되면 기존의 프로세스는 부모 프로세스가 되고, 새로 생긴 프로세스는 자식 프로세스가 된다.</p>

<h2 id="프로세스의-전환">프로세스의 전환</h2>

<p><strong>exec()</strong></p>

<p><code class="language-plaintext highlighter-rouge">exec()</code> 시스템 호출을 사용하면 복사된 프로세스를 새로운 프로세스로 전환할 수 있다. 이 함수를 사용하는 목적은 프로세스의 구조체를 재활용하기 위함이다.</p>

<p>새로운 프로세스를 만들려면 제어블록을 만들고 메모리의 자리를 확보하는 과정이 필요하다. 또한 프로세스를 종료하고 사용한 메모리를 청소(garbage collection)하기 위해 상위 프로세스와 부모-자식 관계를 만들어야 한다.</p>

<p><code class="language-plaintext highlighter-rouge">exec()</code>를 사용하면 이미 만들어진 제어블록, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있어 편리하다. 새로운 코드 영역만 가져오면 되기 때문에 운영체제의 작업이 수월하다.</p>

<p><code class="language-plaintext highlighter-rouge">exec()</code> 함수의 동작과정은 간단하다. 호출을 하면 코드 영역에 있는 기존의 내용을 지우고 새로운 코드로 바꾼다. 또한 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋된다. 제어블록의 내용 중 프로세스 구분자, 부모 프로세스 구분자, 메모리 관련 사항 등은 변하지 않지만 프로그램 카운터 레지스터 값을 비롯한 각종 레지스터와 사용한 파일 정보가 모두 리셋된다.</p>

<h2 id="프로세스의-계층-구조">프로세스의 계층 구조</h2>

<p>위에서 배운 프로세스의 복사와 전환은 프로세스의 계층 구조를 이해하는데 핵심 열쇠가 된다.</p>

<p><code class="language-plaintext highlighter-rouge">fork()</code>와 <code class="language-plaintext highlighter-rouge">exec()</code>를 사용하면 프로세스들을 자동적으로 부모-자식 프로세스의 계층 구조로 만들어준다. 프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져서 시스템을 관리하기가 수월하다. 프로세스가 작업을 마쳐서 그 프로세스가 사용하던 자원을 회수(garbage collection)할 때 특히 편리하다. 만약 모든 프로세스가 독립적으로 만들어지면 프로세스가 종료될 때마다 운영체제가 직접 자원을 회수해야 하기 때문에 작업이 복잡해질 것이다. 그러나 모든 프로세스를 부모-자식 관계로 만들면 자식 프로세스가 작업을 마쳤을 때 사용하던 자원을 부모 프로세스가 회수하면 된다.</p>

<p><strong>고아 프로세스</strong></p>

<p>부모 프로세스는 자원을 회수하기 위해 자식 프로세스가 끝날 때까지 기다려야 된다. 그런데 부모 프로세스가 먼저 종료되거나 자식 프로세스가 비정상적으로 종료되어 부모 프로세스에 연락이 안되는 경우도 있다. 이렇게 부모 프로세스가 먼저 종료되고 비정상적으로 남아있는 자식 프로세스를 고아 프로세스 또는 좀비 프로세스라고 한다. 좀비 프로세스는 자식 프로세스를 종료했음에도 부모가 뒤처리를 하지 않을 때 발생한다. 이런 좀비 프로세스가 많아지면 자원이 낭비되게 된다. 따라서 운영체제는 반환되지 못한 자원을 주기적으로 회수해야 한다.</p>

<h1 id="스레드">스레드</h1>

<p>스레드는 다음과 같은 내용에서 많이 등장하는 단어이다.</p>

<ul>
  <li><strong>프로세스와 스레드의 차이</strong></li>
  <li><strong>CPU 코어 1개에 스레드 2개</strong></li>
  <li><strong>멀티 스레딩</strong></li>
</ul>

<p>먼저 프로세스는 OS가 메모리에 올라가는 단위. 또는 OS로부터 자원을 할당받는 단위라고 생각하면 된다.</p>

<p>스레드는 <strong>프로세스를 실행하는 작업의 단위</strong>라고 생각하면 된다.</p>

<p>그래서 프로세스는 메모리에 올라가는 물리적인 단위, <strong>스레드는 실행 단위. 즉 논리적인 단위</strong>라고 할 수 있다.</p>

<p>CPU 코어당 스레드 2개를 무슨 말일까? 난 처음에 CPU에서 프로세서에 해당하는 코어에 뭔가 2개로 나뉜 스레드라는게 있는 줄 알았다.</p>

<p>근데 그런게 아니고, 코어 1개를 이용해 최대 2개의 스레드를 할당해 처리하도록 할 수 있다는 뜻이다. 3개 이상을 사용하지 않는 이유는, 코어 1개가 스레드 3개를 할당하면 오히려 복잡도로 인해 성능이 떨어지기 때문이라고 한다.</p>

<details>
<summary>자세한 내용은 여기를 참고해주세요</summary>
<div>

    <p>Threads don’t exist in the CPU. They are a feature of the operating system, used in programs for concurrent programming. Meaning, having different threads of a program running at the same time. While you could just have a process rather than a thread, it’s less efficient, and harder to communicate between the pieces.</p>

    <p>As for cores, that is a CPU thing. Starting in the 1970s, the microprocessor could run one program at a time. Into the 80s, and 90s, they still could run only one program at a time. The operating system simply switched programs as needed, giving each program a time slice of the CPU time. For example, simplistically, 10 programs could each be run 1/10s during a second ( that’s not really how it’s done, but good enough for this discussion.)</p>

    <p>CPUs eventually hit a performance wall. The ability to make their clock speed faster became harder to do. To compensate, they started effectively putting more than one CPU on the silicon die. So that multiple programs could run truly simultaneously. <strong>The more cores, the more programs that can run at the same time</strong>. Of course there are way more programs running on a typical Windows or Linux computer than your CPU has cores. So there still needs to be some sharing of the CPU, which is handled by the operating system.</p>

    <p>Note that many programs could be seen as consisting of a single thread. And some programs have more than one thread. Multiple threaded programs may also be happy to have more CPU cores, as they may run faster, depending on the program. For example, there are applications, for example video editing, where the programs will work better with more cores. I mention this, because this may be one reason people associate threads and cores.</p>

    <p>스레드가 CPU에 물리적으로 존재하는게 아니라 논리적인 존재라면 왜 최대 2개 밖에 안되는걸까?</p>

    <p>Because running more than 2 threads on a single core would increase core complexity without improving performance.</p>

    <p>Even having 2 threads running simultaneous on a single CPU core is not universal. CPU cores were originally designed to run 1 thread at a time. A multitasking OS on a single core machine gives the illusion that it runs multiple threads at the same time, but it does so by running a single thread for a limited amount of time before switching to the next thread.</p>

    <p>However, for a while now, CPU cores have had more than one execution unit. For instance, the original Intel Pentium CPU (which is a single core CPU) had 2 integer execution units and 1 floating point unit. This means that it can, in principle, perform multiple instructions at the same time. However, this is only possible when running a single thread, if consecutive instructions are independent of each other, which means that the input of the second instruction does not depend on the output of the first one.</p>

    <p>Modern CPUs, such as the Intel i3/i5/i7 series have as many as 8 execution units per core, and they can start execution of 4 new instructions each clock cycle. Even with some instructions taking more than 1 clock cycle, this means that most of the time, some of the execution units have nothing to do.</p>

    <p>Hyperthreading is a technology, originally introduced by Intel in its Pentium 4 processors, to fill up these unused execution units with instructions from a different thread. So a CPU core with hyperthreading can run 2 threads at the same time.</p>

    <p>Now we finally come to your question: why does hyperthreading limit itself to 2 threads? why not more? The answer is that a single hyperthreading core running 2 threads is nowhere near as fast as two separate cores running these same threads. Since each thread has to make do with the execution units not used by the other one, neither thread runs at maximum speed. If you were to allow more than 2 threads on a single core, this would increase core complexity considerably without much tangible benefit.</p>

  </div>
</details>

<p>그러면 스레드는 어떤 기준으로 정해주어야 할까? 스레드는 컴퓨터가 자동으로 나누어주는 것은 아니고, 프로그래머가 프로그램을 개발할 때 <strong>스레드로 만들어 줄 수 있고, 스레드로 만들었을 때 원하는 성능 향상을 얻을 수 있는 경우 스레드로 만들어준다.</strong></p>

<p>그러면 <strong>언제 스레드가 필요한지, 어떤 조건이 갖추어졌을 때 스레드가 될 수 있는지</strong> 알아보자.</p>

<p>멀티스레딩에 관한 얘기는 뒤에서 멀티 프로세싱과 비교하며 설명할 것이다.</p>

<h1 id="프로세스-간-통신">프로세스 간 통신</h1>

<p>프로세스는 서로 독립적이기 때문에 데이터를 주고 받기 위해서는 프로세스 간 통신을 해야 한다.</p>

<p>프로세스끼리 통신을 할 때에는 누가 먼저 작업할지, 작업이 언제 끝날지 등을 서로 알려주어야 하는데 이를 <strong>동기화</strong>라고 한다.</p>

<p>그리고 같은 데이터를 여러 프로세스가 사용할 때는 서로 침범하면 안되는 <strong>임계구역</strong>이 존재한다.</p>

<p>프로세스 간 통신(IPC, Inter Process Communication)에는 같은 컴퓨터내에 있는 프로세스 간 통신도 있고, 네트워크로 연결된 다른 컴퓨터에 있는 프로세스 간 통신도 있다.</p>

<p><img src="/images/os_9.png" alt="" /></p>

<ul>
  <li><strong>프로세스 내부 데이터 통신</strong>: 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우의 통신. 프로세스 내부의 스레드는 전역 변수나 파일을 이용해 데이터를 주고 받는다</li>
  <li><strong>프로세스 간 데이터 통신</strong>: 같은 컴퓨터에 있는 여러 프로세스끼리 통신하는 경우로, 공용 파일 또는 운영체제가 제공하는 파이프를 사용하여 통신한다</li>
  <li><strong>네트워크를 이용한 데이터 통신</strong>: 여러 컴퓨터가 네트워크로 연결되어 있을 때도 통신이 가능한데, 이 경우 프로세스는 소켓을 이용하여 데이터를 주고받는다. 이처럼 소켓을 이용하는 프로세스 간 통신을 네트워킹이라고 한다. 다른 컴퓨터에 있는 함수를 호출하여 통신하는 원격 프로시저 호출(RPC)도 여기에 해당한다.</li>
</ul>

<p>(같은 프로세스끼리도 루프백(127.0.0.1) 주소를 사용하면 소켓을 이용하여 통신할 수도 있지만, 소켓을 사용하려면 많은 전처리를 해야하기 때문에 같은 컴퓨터에 있는 프로세스 간 통신에는 소켓을 거의 사용하지 않는다)</p>

<h2 id="동기화">동기화</h2>
<p>프로세스 간 통신은 겉으로 보기에는 단순하다. 데이터를 주거나(send), 받는것(receive)을 의미한다. 예를 들어 전역 변수를 이용해 통신하는 경우를 생각해보자. 데이터를 보내는 프로세스는 데이터를 전역 변수에 저장한다. 데이터를 받는 프로세스는 전역 변수에 저장된 데이터를 읽어간다.</p>

<p>하지만 내부적으로는 이것보다는 복잡하다. 예를 들어 통신하려는 상대 프로세스를 어떻게 찾을지, 데이터의 크기는 얼마로 할지, 데이터 도착 여부를 어떻게 확인할지 등의 문제를 해결해야 한다.</p>

<p>프로세스 간 통신 방법을 분류할 때는 크게 두 가지가 기준이 된다. 바로 <strong>통신 방향</strong>과 <strong>동기화의 유무</strong>이다.</p>

<ul>
  <li><strong>단방향</strong>: 모스 신호처럼 한쪽 방향으로만 데이터를 전송할 수 있는 구조. (전역 변수, 파이프)</li>
  <li>
    <p><strong>양방향</strong>: 데이터를 동시에 양쪽 방향으로 전송할 수 있는 구조 (소켓 통신)</p>
  </li>
  <li><strong>동기화</strong>: 상대쪽에서 데이터를 전송하면 운영체제가 데이터가 도착했음을 알려준다. (파이프, 소켓)</li>
  <li><strong>비동기화</strong>: 상대쪽에서 데이터를 전송했는지 반복문을 무한 실행하며 기다려야 한다(바쁜 대기). (전역 변수, 파일)</li>
</ul>

<h2 id="프로세스-간-통신의-종류">프로세스 간 통신의 종류</h2>

<h3 id="전역-변수를-이용한-통신">전역 변수를 이용한 통신</h3>

<p>전역 변수를 이용한 통신은 공동으로 관리하는 메모리를 사용하여 데이터를 주고 받는 것이다.</p>

<p>전역 변수를 이용한 통신은 변수를 두 개를 사용하면 양방향 통신을 가능하게 한다.</p>

<p>하지만 동기화 문제가 해결되지 않는다.</p>

<h3 id="파일을-이용한-통신">파일을 이용한 통신</h3>

<p>파일을 이용한 통신은 부모-자식 프로세스 간 통신에 많이 사용</p>

<p>운영체제가 별다른 동기화를 제공하지 않기 때문에, 프로세스가 알아서 동기화를 해야 한다.</p>

<p>동기화를 위해 주로 부모 프로세스가 wait() 함수를 이용하여 자식 프로세스의 작업이 끝날 때까지 기다렸다가 작업을 시작한다.</p>

<h3 id="소켓을-이용한-통신">소켓을 이용한 통신</h3>

<p>서로 다른 컴퓨터에 있는 프로세스 간 통신은 원격 프로시저 호출(RPC)이나 소켓을 이용한다.</p>

<p>원격 프로시저 호출은 다른 컴퓨터에 있는 함수를 호출하는 것을 뜻한다.</p>

<p>객체지향 언어에서 다른 컴퓨터에 있는 객체의 메소드를 불러와 사용하는 것이 원격 프로시저 호출의 대표적인 예이다.</p>

<p>원격 프로시저 호출은 일반적으로 소켓을 이용하여 구현한다.</p>

<p>프로세스는 소켓에 쓰기 연산을 통해 데이터를 전송하고 읽기 연산을 통해 데이터를 받는다.</p>

<p>소켓은 동기화를 지원한다.</p>

<p>소켓은 하나만 사용해도 양방향 통신이 가능하다.</p>

<p>네트워크 프로그래밍을 흔히 소켓 프로그래밍이라 부르는 이유는 네트워킹의 기본이 소켓이기 때문이다.</p>

<p><img src="/images/os_10.png" alt="" /></p>

<p><img src="/images/os_11.png" alt="" /></p>

<p>여러 컴퓨터에 있는 프로세스에 데이터를 전달하는 방법 중 가장 대중화된 것은 소켓을 이용한 네트워킹이다. 소켓을 이용한 네트워킹에서도 open(), read()/write(), close() 구조를 사용한다.</p>

<p>위의 그림은 클라이언트와 서버가 어떤 절차를 거쳐서 통신하는지를 보여준다. 클라이언트와 서버는 둘 다 소켓을 사용한다. 소켓은 양방향 통신을 지원하고 동기화도 지원한다.</p>

<p>클라이언트는 소켓을 생성한 후 connect()를 사용하여 서버와의 접속을 시도한다. 서버와 접속되면 read() 혹은 write() 작업을 하며, 작업이 끝나면 사용한 소켓 디스크립터를 닫고 종료한다.</p>

<p>서버 쪽 통신 절차는 좀 더 복잡하다. 서버는 소켓을 생성한 후 bind()를 삿용하여 생성한 소켓을 특정 포트에 등록한다. 포트는 한 컴퓨터 내에 존재하는 여러 프로세스를 구분하기 위한 목적이다. 포트를 사용해 어떤 프로세스와 통신할지 구분할 수 있다.</p>

<p>하나의 포트 번호에 소켓이 하나만 생성되는 것은 아니다. 네이버 홈페이지를 운영하는 서버의 포트 번호는 80번인데, 여기에 소켓을 하나만 생성할 수 있다면단 한사람에게만 서비스를 할 수 있을 것이다. 서버는 동시에 여러 클라이언트에 서비스를 하기 위해 하나의 포트 번호에 여러 개의 소켓을 생성한다. 따라서 bind()는 특정 포트에 새로운 소켓을 등록하겠다는 의미이다.</p>

<p>bind()로 소켓이 정상적으로 등록되면 listen()을 실행하여 클라이언트를 받을 준비를 한다. accept()는 클라이언트의 connect(), 즉 연결 요청을 기다리다가 여러 명의 클라이언트가 동시에 connect()를 하는 경우 그중 하나를 골라 작업을 시작하게 해준다. 따라서 클라이언트가 accept()되면 소켓 디스크립터가 생성되고 작업이 시작된다. read()혹은 write() 작업을 마치면 생성된 소켓 디스크립터를 닫고 다음 클라이언트를 기다린다.</p>

<p>서버에서의 소켓 생성은 listen()으로 클라이언트의 접속을 확인한 후, accept()에서 이루어진다.</p>

<p>서버의 경우 계속 클라이언트를 받아 작업해야 하기 때문에 무한 루프를 돌며 작업을 반복한다.</p>

<h2 id="임계구역">임계구역</h2>

<p>임계구역은 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역을 말한다.</p>

<h3 id="임계구역-해결-조건">임계구역 해결 조건</h3>

<ul>
  <li>상호 배제: 한 프로세스가 임계구역에 들어가면 다른 프로세스는 들어갈 수 없다</li>
  <li>한정 대기: 어떤 프로세스도 무한 대기하지 않아야 한다</li>
  <li>진행의 융통성: 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다</li>
</ul>

<h3 id="임계구역-해결-방법">임계구역 해결 방법</h3>

<ul>
  <li>세마포어: 임계구역에 진입하기 전에 스위치를 사용 중으로 놓고 임계구역으로 들어가는 방법</li>
</ul>

<h1 id="교착-상태">교착 상태</h1>

<p>교착 상태는 2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태를 말한다.</p>

<p>컴퓨터 시스템에서 교착 상태는 시스템 자원, 공유 변수(또는 파일), 응용 프로그램(데이터베이스) 등을 사용할 때 발생할 수 있다.</p>

<h2 id="자원-할당-그래프">자원 할당 그래프</h2>

<p>프로세스가 어떤 자원을 사용 중이고 어떤 자원을 기다리고 있는지를 방향성이 있는 그래프로 표현한 것이다.</p>

<p>자원 할당 그래프를 사용하면 자원의 할당과 대기 상태를 한눈에 파악할 수 있다.</p>

<h2 id="교착-상태-필요조건">교착 상태 필요조건</h2>

<ul>
  <li>상호 배제: 한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 한다</li>
  <li>비선점: 한 프로세스가 사용 중인 자원은 다른 프로세스가 빼앗을 수 없는 비선점 자원이어야 한다</li>
  <li>점유와 대기: 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태이어야 한다</li>
  <li>원형 대기: 점유와 대기를 하는 프로세스 간에 관계가 원을 이루어야 한다</li>
</ul>

<p>위 조건이 하나라도 만족되지 않으면 교착 상태는 일어나지 않는다.</p>

<h2 id="교착-상태-해결방법">교착 상태 해결방법</h2>

<h3 id="교착-상태-검출과-회복">교착 상태 검출과 회복</h3>

<p><strong>교착 상태 검출</strong></p>

<p>교착 상태 검출은 운영체제가 프로세스의 작업을 관찰하면서 교착 상태 발생 여부를 계속 주시하는 방법. 만약 교착 상태가 발견되면 이를 해결하기 위해 교착 상태 회복 단계를 밟는다.</p>

<p>교착 상태를 검출하는 방법에는 크게 타임아웃 방법과 자원 할당 그래프를 이용하는 방법이 있다.</p>

<p><strong>타임아웃</strong></p>

<p>일정 시간 동안 작업이 진행되지 않은 프로세스를 교착 상태가 발생한 것으로 간주하여 처리하는 방법이다.</p>

<ul>
  <li>장점: 쉽게 구현</li>
  <li>단점: 엉뚱한 프로세스가 종료될 수 있다. 분산 데이터베이스에는 적용 불가(교착 상태 때무인지, 네트워크 때문인지 알 수 없음)</li>
</ul>

<p>위와 같은 문제에도 불구하고 타임아웃은 대부분의 데이터베이스와 운영체제에서 많이 선호한다. 그 이유는 자원 할당 그래프를 이용한 방법은 구현하기가 힘들기 때문이다.</p>

<p><strong>자원 할당 그래프를 이용</strong></p>

<ul>
  <li>장점: 교착 상태를 정확하게 파악 할 수 있다</li>
  <li>단점: 그래프를 유지, 갱신하고 사이클을 검사하는 추가 작업으로 인한 오버헤드가 발생</li>
</ul>

<p><img src="/images/os_12.png" alt="" /></p>

<p><strong>교착 상태 회복</strong></p>

<p>교착 상태를 유발한 프로세스를 강제 종료한다</p>

<ul>
  <li>교착 상태를 일으킨 모든 프로세스를 동시에 종료
    <ul>
      <li>이 방법은 작업을 시작하면 다시 교착 상태를 일으킬 가능성이 높다</li>
      <li>그래서 다시 실행할 때는 어떤 프로세스를 먼저 실행할지 순서를 정해 순차적으로 실행해야 한다</li>
    </ul>
  </li>
  <li>교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료
    <ul>
      <li>순서대로 종료하면서 나머지 프로세스의 상태를 파악하는 방법</li>
      <li>우선순위가 낮은 프로세스를 먼저 종료한다</li>
      <li>우선순위가 같은 경우 작업시간이 짧은 프로세스를 먼저 종료한다</li>
      <li>위의 두 조건이 같은 경우 자원을 많이 사용하는 프로세스를 먼저 종료한다</li>
    </ul>
  </li>
</ul>

<h1 id="멀티-프로세싱-멀티-스레딩-동시성-프로그래밍-그리고-비동기-프로그래밍">멀티 프로세싱, 멀티 스레딩, 동시성 프로그래밍 그리고 비동기 프로그래밍</h1>

<p>197년대 까지는 프로세서는 하나의 프로세스를 실행해서 종료하고, 또 하나의 프로세스를 실행하고 종료하는 방식으로 동작했다. 다시 말해 멀티 태스킹을 할 수 없었다. 그러다 80년대에 들어서 운영체제(OS)에서 <strong>멀티 태스킹</strong>을 지원하기 시작했다. 멀티 태스킹은 OS의 스케줄링을 이용해 여러 프로세스를 시분할로 함께 실행시키는 것이다. 예를 들어 10개의 프로그램을 실행했을 때, CPU는 각 프로세스에 작은 단위의 시간을 할당해 마치 여러 프로세스가 동시에 실행되는 듯하게 만드는 것이다.</p>

<p>그러나 시대가 계속 발전함에 따라 우리는 프로세스 하나의 더 높은 성능을 기대하기 시작했다. 그래서 인텔과 같이 CPU를 만드는 회사에서는 CPU 한개에 여러 개의 코어를 탑재한 멀티 코어 칩을 만들어 냈다. 우리는 이제 정말로 동시에 여러 프로세스를 실행할 수 있게 되었다. 이는 코어 하나에 온전히 하나의 프로세스만 할당함으로써 프로세스의 성능을 높게 유지할 수 있었다.</p>

<p>그러나 소프트웨어 개발자들은 여기서 그치지 않고, 하나의 프로세스를 여러 프로세서가 협력해 처리하는 병렬 처리를 통해 프로세스 하나의 성능을 극대화 시키는 방법을 고민하고 있었다. 그렇게 등장한 것이 바로 <strong>멀티 프로세싱</strong>이다. 멀티 프로세싱은 하나의 프로세스를 여러 프로세서가 병렬 처리하는 것을 말한다. 하나의 프로세스를 여러 프로세서가 나눠서 처리하기 위해 프로세스를 나누는 작업은 프로그래머의 몫이다.</p>

<p>마지막으로 작업을 프로세서에게 나눠주는 단위를 프로세스가 아니라 스레드 단위로 할 수도 있다. 이를 <strong>멀티 스레딩</strong>이라 한다. 스레드는 스택 영역만 분리되고 나머지 영역은 공유한다. 그리고 스레드는 하나의 프로세서에 최대 2개의 스레드를 할당할 수 있다. (하지만 코어가 스레드 2개를 병렬처리하는 것은 아니고 컨텍스트 스위칭을 통해 번갈아가며 처리한다)</p>

<p>위에서 설명한 바와 같이 프로세스가 병렬 처리되도록 프로그래밍하는 것을 <strong>동시성 프로그래밍</strong>이라고 한다.</p>

<p>지금까지 멀티 태스킹, 멀티 프로세싱, 멀티 스레딩에 관한 개념이 등장하게 된 배경에 대해 설명했다.</p>

<p>이제 각각의 특징과 장단점에 관해 조금 더 얘기해보자.</p>

<ul>
  <li>프로세스
    <ul>
      <li>운영체제로부터 자원을 할당받는 작업의 단위</li>
      <li>프로그램이 인스턴스화 되어 메모리에 올라온 상태</li>
    </ul>
  </li>
  <li>스레드
    <ul>
      <li>프로세스가 할당받은 자원을 이용하는 실행의 단위</li>
      <li>스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유</li>
    </ul>
  </li>
</ul>

<h2 id="멀티-태스킹">멀티 태스킹</h2>

<p>멀티 태스킹은 task를 OS의 스케쥴링에 의해 task를 번갈아가며 수행하는 것을 의미한다. 여러개의 task를 자주 번갈아가며 수행하다보니 사용자는 동시에 여러 task가 수행되고 있다고 느끼게 된다. 현대 컴퓨터도 OS의 스케줄링을 이용해 시분할 방식으로 멀티 태스킹을 지원하고 있다.</p>

<h2 id="멀티-프로세싱">멀티 프로세싱</h2>

<p>멀티 프로세싱은 다수의 프로세서가 서로 협력적으로 일을 처리하는 것을 의미한다. 프로세스 간 통신을 하기 위해서는 IPC를 통해야 한다.</p>

<p><img src="/images/os_31.png" alt="" /></p>

<ul>
  <li>장점
    <ul>
      <li>독립된 구조로 안전성이 높은 장점이 있다.</li>
      <li>프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않아, 작업속도가 느려지는 손해정도는 생기지만 정지되거나 하는 문제는 발생하지 않는다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>메모리 사용량이 많다</li>
      <li>독립된 메모리 영역이기 때문에 작업량이 많을수록( Context Switching이 자주 일어나서 주소 공간의 공유가 잦을 경우) 오버헤드가 발생하여 성능저하가 발생 할 수 있다.</li>
      <li>Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 시간이 소모되는 등 오버헤드가 발생한다.</li>
    </ul>
  </li>
</ul>

<h2 id="멀티-스레딩">멀티 스레딩</h2>

<p>멀티 스레딩은 하나의 프로세스를 스레드 단위로 프로세서에게 할당해 병렬 처리하는 것을 의미하며, 여러 개의 스레드는 서로 자원을 공유할 수 있다.</p>

<p><img src="/images/os_32.png" alt="" /></p>

<ul>
  <li>
    <p>장점</p>

    <ul>
      <li>응답성 향상: 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답할 수 있다</li>
      <li>자원 공유: 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원활하게 진행할 수 있다</li>
      <li>효율성 향상: 불필요한 자원의 중복을 막음으로써 시스템의 효율이 향상된다</li>
      <li>다중 CPU 지원: 2개 이상의 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티스레드를 동시에 처리하여 CPU 사용량이 증가하고 프로세스의 처리 시간이 단축된다</li>
      <li>시스템 자원소모 감소 (자원의 효율성 증대)
        <ul>
          <li>프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어 자원을 효율적으로 관리할 수 있다.</li>
        </ul>
      </li>
      <li>시스템 처리율 향상 (처리비용 감소)
        <ul>
          <li>스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어든다.</li>
          <li>스레드 사이 작업량이 작아 Context Switching이 빠르다. (캐시 메모리를 비울 필요가 없다.)</li>
        </ul>
      </li>
      <li>간단한 통신 방법으로 프로그램 응답시간 단축
        <ul>
          <li>스레드는 프로세스 내 스택영역을 제외한 메모리 영역을 공유하기에 통신 비용이 적다.</li>
          <li>힙 영역을 공유하므로 데이터를 주고 받을 수 있다.</li>
        </ul>
      </li>
      <li>운영체제가 시스템 자원을 효율적으로 관리하기 위해 스레드를 사용한다.</li>
      <li>멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.</li>
      <li>또한, 프로세스 간의 통신보다 스레드 간의 통신 비용이 적으므로 작업들 간 통신의 부담이 줄어든다. (처리비용 감소. 프로세스는 독립구조이기 때문)</li>
    </ul>
  </li>
  <li>
    <p>단점</p>
    <ul>
      <li>모든 스레드가 자원을 공유하기 때문에 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미친다.</li>
      <li>자원을 공유하기에 동기화 문제가 발생할 수 있다. (병목현상, 데드락 등)</li>
      <li>주의 깊은 설계가 필요하고 디버깅이 어렵다. (불필요 부분까지 동기화하면, 대기시간으로 인해 성능저하 발생)</li>
      <li>하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받는다.</li>
      <li>단일 프로세스 시스템의 경우 효과를 기대하기 어렵다.</li>
      <li>스레드를 활용하면 자원의 효율성이 증가하기도 하지만, 스레드 간의 자원 공유는 전역 변수를 이용하므로 동기화 문제가 발생 할 수 있으므로 프로그래머의 주의가 필요하다.</li>
      <li>스레드 하나가 프로세스 내 자원을 망쳐버린다면 모든 프로세스가 종료될 수 있다.</li>
      <li>자원을 공유하기 때문에 필연적으로 동기화 문제가 발생할 수밖에 없다.</li>
      <li>동기화 그리고 교착상태가 발생하지 않도록 주의해야 한다.</li>
      <li>자식 스레드 중 하나에 문제가 생긴경우 전체 프로세스에 영향을 줄 수 있다.</li>
    </ul>
  </li>
</ul>

<p>자원의 효율성증대<br />
멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우 프로세스를 생성하여 자원을 할당하는 비용이 적고, 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어든다.</p>

<p>응답 시간 단축 및 처리 비용 감소<br />
프로세스간 IPC를 사용하여 통신하는 것은 상대적으로 비용이 크다.</p>

<p>하지만 스레드는 프로세스의 메모리 영역을 공유하여 스레드 간의 통신 비용이 적게 든다.</p>

<p>또한 프로세스간의 Context Switching은 느린 반면 쓰레드간의 Context Switching 은 빠른데, 그 이유는 Context Switching 시 스레드는 Stack 영역만 처리하면 되기 때문이다.</p>

<p>멀티 스레드의 안정성 문제<br />
여러 개의 스레드가 동일한 데이터 공간(Critical Section)을 공유하면서 이들을 수정한다는 점에 필연적으로 생기는 문제이다.</p>

<p>Tip<br />
Critical Section: <br />
임계 구역(critical section) 또는 공유변수 영역은 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원(자료 구조 또는 장치)을 접근하는 코드의 일부를 말한다.</p>

<p>멀티 프로세스의 프로그램은 문제가 생기면 해당 프로세스가 중단되거나 중단 시키고 다시 시작 하면된다.</p>

<p>하지만 멀티 스레드 방식의 프로그램에서는 하나의 스레드가 자신이 사용하던 데이터 공간을 망가뜨린다면, 해당 데이터 공간을 공유하는 모든 스레드를 망가뜨릴 수 있다.</p>

<h2 id="멀티-스레딩과-비동기-프로그래밍은-다르다">멀티 스레딩과 비동기 프로그래밍은 다르다</h2>

<p>멀티 스레딩은 하나의 프로세스를 여러 개의 실행 단위로 나누어 병렬 처리하는 것을 의미하며, 여러 개의 스레드는 서로 자원을 공유할 수 있다.</p>

<h2 id="콜백-함수">콜백 함수</h2>

<ul>
  <li>함수 안에 인자로 전달되는 함수</li>
  <li>fun1(fun2) -&gt; fun1 함수를 실행하는 도중에 fun2 함수가 실행되고 fun2 함수가 종료된 후 fun1 함수가 마저 실행됨</li>
  <li>fun2와 같은 함수를 콜백 함수라고 함</li>
</ul>

<h2 id="thread-safe">Thread Safe</h2>

<h2 id="멀티-코어를-가진-cpu-1개-vs-싱글-코어를-가진-cpu-여러개">멀티 코어를 가진 CPU 1개 vs 싱글 코어를 가진 CPU 여러개</h2>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;barcode=9791156644071" target="_blank">쉽게 배우는 운영체제 책 참고</a></li>
  <li><a href="https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%A0%88%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85)" target="_blank">위키백과 스레드</a></li>
  <li><a href="https://oizys.tistory.com/9" target="_blank">우당탕탕 개발, 멀티프로세싱, 멀티프로그래밍,멀티태스킹,멀티스레딩</a></li>
  <li><a href="https://wooody92.github.io/os/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C/" target="_blank">wooody92’s blog, 멀티 프로세스(Multi Process)와 멀티 스레드(Multi Thread)</a></li>
  <li><a href="https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4" target="_blank">인파, 프로세스 vs 쓰레드 차이 정리</a></li>
  <li><a href="https://brunch.co.kr/@babosamo/100#comment" target="_blank">Noah, Process, Thread 차이가 뭐예요?</a></li>
  <li><a href="https://jayhyun-hwang.github.io/2021/09/02/The-Difference-Between-Asynchronous-And-Multi-Threading/" target="_blank">비동기와 멀티스레딩</a></li>
  <li><a href="https://kishoreconnect.com/understanding-processes-threads-and-cpu-cores" target="_blank">Kishore’s Blog, Process vs Thread vs Core</a></li>
  <li><a href="https://www.quora.com/Why-does-a-core-only-have-two-threads-in-a-processor" target="_blank">Quora, Why does a core only have two threads in a processor?</a></li>
  <li><a href="https://britishgeologicalsurvey.github.io/science/python-forking-vs-spawn/" target="_blank">Fork vs Spawn in Python Multiprocessing</a></li>
</ul>
:ET