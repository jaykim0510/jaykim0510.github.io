I"7<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#spring-mvc" id="markdown-toc-spring-mvc">Spring MVC</a></li>
  <li><a href="#프론트-컨트롤러-패턴-도입" id="markdown-toc-프론트-컨트롤러-패턴-도입">프론트 컨트롤러 패턴 도입</a></li>
  <li><a href="#매핑-정보" id="markdown-toc-매핑-정보">매핑 정보</a></li>
  <li><a href="#뷰-분리" id="markdown-toc-뷰-분리">뷰 분리</a></li>
  <li><a href="#어댑터-패턴" id="markdown-toc-어댑터-패턴">어댑터 패턴</a></li>
  <li><a href="#spring-mvc-1" id="markdown-toc-spring-mvc-1">Spring MVC</a>    <ul>
      <li><a href="#스프링-mvc-동작순서" id="markdown-toc-스프링-mvc-동작순서">스프링 MVC 동작순서</a></li>
      <li><a href="#인터페이스-살펴보기" id="markdown-toc-인터페이스-살펴보기">인터페이스 살펴보기</a></li>
      <li><a href="#주요-인터페이스-목록" id="markdown-toc-주요-인터페이스-목록">주요 인터페이스 목록</a></li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="spring-mvc">Spring MVC</h1>

<ul>
  <li>하나의 서블릿이나 JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리하게 되면, 나중에 유지보수가 어려워진다</li>
  <li>MVC 패턴은 이런 문제점을 해결하고자, 영역을 크게 컨트롤러(Controller)와 뷰(View)로 나누었다</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Model: 뷰에 출력할 데이터를 담아둔다
- Controller: HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 호출한다. 그리고 뷰에 전달할 데이터를 조회해서 모델에 담는다
- (비즈니스 로직은 서비스(Service)라는 클래스를 만들어 별도로 처리. 컨트롤러의 부담을 줄이고자)
- View: 모델에 담긴 데이터를 사용해서 화면을 렌더링한다 (HTML 생성)
</code></pre></div></div>

<p><img src="/images/mvc_1.png" alt="" /></p>

<h1 id="프론트-컨트롤러-패턴-도입">프론트 컨트롤러 패턴 도입</h1>

<p><img src="/images/front_controller_1.png" alt="" /></p>

<ul>
  <li>프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음</li>
  <li>프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출</li>
  <li>프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨</li>
  <li>스프링 웹 MVC의 DispatcherServlet이 FrontController 패턴으로 구현되어 있음</li>
</ul>

<h1 id="매핑-정보">매핑 정보</h1>

<p><img src="/images/mapping_1.png" alt="" /></p>

<ul>
  <li>요청이 들어온 URL을 보고 어떤 컨트롤러를 호출해야 하는지 매핑 정보에 물어본다</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@WebServlet</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"frontControllerServletV1"</span><span class="o">,</span> <span class="n">urlPatterns</span> <span class="o">=</span> <span class="s">"/front- controller/v1/*"</span><span class="o">)</span> 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FrontControllerServletV1</span> <span class="kd">extends</span> <span class="nc">HttpServlet</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">ControllerV1</span><span class="o">&gt;</span> <span class="n">controllerMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span> 
    <span class="kd">public</span> <span class="nf">FrontControllerServletV1</span><span class="o">()</span> <span class="o">{</span> 
                     <span class="n">controllerMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"/front-controller/v1/members/new-form"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">MemberFormControllerV1</span><span class="o">());</span> 
                     <span class="n">controllerMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"/front-controller/v1/members/save"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">MemberSaveControllerV1</span><span class="o">());</span> 
                    <span class="n">controllerMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"/front-controller/v1/members"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">MemberListControllerV1</span><span class="o">());</span> 
          <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h1 id="뷰-분리">뷰 분리</h1>

<p><img src="/images/view_split.png" alt="" /></p>

<ul>
  <li>모든 컨트롤러에서 뷰로 이동하는 부분에 중복이 있고, 깔끔하지 않다</li>
  <li>컨트롤러가 뷰를 반환</li>
  <li>이제 각 컨트롤러는 복잡한 <code class="language-plaintext highlighter-rouge">dispatcher.forward()</code> 를 직접 생성해서 호출하지 않아도 된다.
단순히 MyView 객체를 생성하고 거기에 뷰 이름만 넣고 반환하면 된다.</li>
  <li>프론트 컨트롤러의 도입으로 MyView 객체의 <code class="language-plaintext highlighter-rouge">render()</code> 를 호출하는 부분을 모두 일관되게 처리할 수 있다. 각각의 컨트롤러는 MyView 객체를 생성만 해서 반환하면 된다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 각 컨트롤러</span>
<span class="kd">public</span> <span class="nc">MyView</span> <span class="nf">process</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span> 
    <span class="k">return</span> <span class="k">new</span> <span class="nf">MyView</span><span class="o">(</span><span class="s">"/WEB-INF/views/new-form.jsp"</span><span class="o">);</span>
<span class="o">}</span> 
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 프론트 컨트롤러</span>
<span class="nd">@Override</span> 
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">service</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span> <span class="nc">String</span> <span class="n">requestURI</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">();</span> <span class="nc">ControllerV2</span> <span class="n">controller</span> <span class="o">=</span> <span class="n">controllerMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">requestURI</span><span class="o">);</span> <span class="k">if</span> <span class="o">(</span><span class="n">controller</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="n">response</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="nc">HttpServletResponse</span><span class="o">.</span><span class="na">SC_NOT_FOUND</span><span class="o">);</span> <span class="k">return</span><span class="o">;</span> <span class="o">}</span> 
<span class="nc">MyView</span> <span class="n">view</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span> <span class="n">view</span><span class="o">.</span><span class="na">render</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span> <span class="o">}</span> 
</code></pre></div></div>

<ul>
  <li>컨트롤러는 뷰를 직접 리턴하지 않고, 필요한 뷰의 논리적인 이름만, 프론트 컨트롤러는 필요한 데이터를 그에 맞는 Model 이라는 딕셔너리로</li>
</ul>

<p><img src="/images/view_split_2.png" alt="" /></p>

<h1 id="어댑터-패턴">어댑터 패턴</h1>

<p><img src="/images/adapter_pattern.png" alt="" /></p>

<ul>
  <li>
    <p>핸들러 어댑터: 중간에 어댑터 역할을 하는 어댑터가 추가되었는데 이름이 핸들러 어댑터이다. 여기서 어댑터 역할을 해주는 덕분에 다양한 종류의 컨트롤러를 호출할 수 있다.</p>
  </li>
  <li>핸들러: 컨트롤러의 이름을 더 넓은 범위인 핸들러로 변경했다. 그 이유는 이제 어댑터가 있기 때문에 꼭 컨트롤러의 개념 뿐만 아니라 어떠한 것이든 해당하는 종류의 어댑터만 있으면 다 처리할 수 있기 때문이다.</li>
  <li>컨트롤러(Controller) -&gt; 핸들러(Handler) 이전에는 컨트롤러를 직접 매핑해서 사용했다. 그런데 이제는 어댑터를 사용하기 때문에, 컨트롤러 뿐만 아니라 어댑터가 지원하기만 하면, 어떤 것이라도 URL에 매핑해서 사용할 수 있다. 그래서 이름을 컨트롤러에서 더 넒은 범위의 핸들러로 변경했다</li>
  <li>어댑터 패턴을 사용해서 프론트 컨트롤러가 다양한 방식의 컨트롤러를 처리할 수 있도록 변경해보자.</li>
  <li>이전에는 프론트 컨트롤러가 실제 컨트롤러를 호출했지만 이제는 이 어댑터를 통해서 실제 컨트롤러가 호출된다.</li>
</ul>

<h1 id="spring-mvc-1">Spring MVC</h1>

<p><img src="/images/spring_mvc.png" alt="" /></p>

<ul>
  <li>스프링 MVC도 프론트 컨트롤러 패턴으로 구현되어 있다.</li>
  <li>스프링 MVC의 프론트 컨트롤러가 바로 디스패처 서블릿(<code class="language-plaintext highlighter-rouge">DispatcherServlet</code>)이다.</li>
  <li>그리고 이 디스패처 서블릿이 바로 스프링 MVC의 핵심이다.</li>
  <li>스프링 부트는 <code class="language-plaintext highlighter-rouge">DispacherServlet</code> 을 서블릿으로 자동으로 등록하면서 모든 경로(<code class="language-plaintext highlighter-rouge">urlPatterns="/"</code>)에 대해서 매핑한다.</li>
  <li>서블릿이 호출되면 HttpServlet 이 제공하는 serivce() 가 호출된다.</li>
  <li>스프링 MVC는 <code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 의 부모인 <code class="language-plaintext highlighter-rouge">FrameworkServlet</code> 에서 <code class="language-plaintext highlighter-rouge">service()</code> 를 오버라이드 해두었다.</li>
  <li><code class="language-plaintext highlighter-rouge">FrameworkServlet.service()</code> 를 시작으로 여러 메서드가 호출되면서 <code class="language-plaintext highlighter-rouge">DispacherServlet.doDispatch()</code> 가 호출된다.</li>
</ul>

<h2 id="스프링-mvc-동작순서">스프링 MVC 동작순서</h2>

<ol>
  <li>핸들러 조회: 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다.</li>
  <li>핸들러 어댑터 조회: 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.</li>
  <li>핸들러 어댑터 실행: 핸들러 어댑터를 실행한다.</li>
  <li>핸들러 실행: 핸들러 어댑터가 실제 핸들러를 실행한다.</li>
  <li><code class="language-plaintext highlighter-rouge">ModelAndView</code> 반환: 핸들러 어댑터는 핸들러가 반환하는 정보를 <code class="language-plaintext highlighter-rouge">ModelAndView로</code> 변환해서 반환한다.</li>
  <li><code class="language-plaintext highlighter-rouge">viewResolver</code> 호출: 뷰 리졸버를 찾고 실행한다. JSP의 경우: InternalResourceViewResolver` 가 자동 등록되고, 사용된다.</li>
  <li>View반환: 뷰리졸버는 뷰의 논리이름을 물리이름으로 바꾸고,렌더링 역할을 담당하는 뷰 객체를 반환한다. JSP의 경우 <code class="language-plaintext highlighter-rouge">InternalResourceView(JstlView)</code> 를 반환하는데, 내부에 <code class="language-plaintext highlighter-rouge">forward()</code> 로직이 있다.</li>
  <li>뷰렌더링: 뷰를 통해서 뷰를 렌더링한다.</li>
</ol>

<h2 id="인터페이스-살펴보기">인터페이스 살펴보기</h2>

<ul>
  <li>스프링 MVC의 큰 강점은 <code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 코드의 변경 없이, 원하는 기능을 변경하거나 확장할 수 있다는 점이다.</li>
  <li>지금까지 설명한 대부분을 확장 가능할 수 있게 인터페이스로 제공한다.</li>
  <li>이 인터페이스들만 구현해서 <code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 에 등록하면 여러분만의 컨트롤러를 만들 수도 있다.</li>
</ul>

<h2 id="주요-인터페이스-목록">주요 인터페이스 목록</h2>

<ul>
  <li>핸들러 매핑: org.springframework.web.servlet.HandlerMapping</li>
  <li>핸들러 어댑터: org.springframework.web.servlet.HandlerAdapter</li>
  <li>뷰 리졸버: org.springframework.web.servlet.ViewResolver</li>
  <li>뷰: org.springframework.web.servlet.View</li>
</ul>
:ET