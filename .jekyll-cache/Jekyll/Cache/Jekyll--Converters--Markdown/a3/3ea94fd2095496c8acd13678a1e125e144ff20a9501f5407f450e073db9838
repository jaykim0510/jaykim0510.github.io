I"}<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#dynamic-programming" id="markdown-toc-dynamic-programming">Dynamic Programming</a>    <ul>
      <li><a href="#언제-적용-가능한가" id="markdown-toc-언제-적용-가능한가">언제 적용 가능한가</a></li>
      <li><a href="#적용-가능한-문제의-대표적인-특징" id="markdown-toc-적용-가능한-문제의-대표적인-특징">적용 가능한 문제의 대표적인 특징</a></li>
      <li><a href="#문제-예시" id="markdown-toc-문제-예시">문제 예시</a></li>
      <li><a href="#dp를-쓰는-이유" id="markdown-toc-dp를-쓰는-이유">DP를 쓰는 이유</a></li>
    </ul>
  </li>
  <li><a href="#dp-알고리즘-구현" id="markdown-toc-dp-알고리즘-구현">DP 알고리즘 구현</a>    <ul>
      <li><a href="#bottom-up" id="markdown-toc-bottom-up">Bottom-Up</a></li>
      <li><a href="#top-down" id="markdown-toc-top-down">Top-Down</a></li>
    </ul>
  </li>
  <li><a href="#dp-문제를-풀기위해-필요한-구성요소-top-down-기준" id="markdown-toc-dp-문제를-풀기위해-필요한-구성요소-top-down-기준">DP 문제를 풀기위해 필요한 구성요소 (Top-Down 기준)</a></li>
  <li><a href="#dp-greedy-algorithm-divide-and-conquer" id="markdown-toc-dp-greedy-algorithm-divide-and-conquer">DP, Greedy Algorithm, Divide and Conquer</a></li>
</ul>

<hr />

<h1 id="dynamic-programming">Dynamic Programming</h1>

<ul>
  <li>Explore all possible solution efficiently, systematically</li>
  <li>모든 가능한 경우를 다 확인해야 하는 경우에 효율적이고 정형화된 코드를 작성하도록 하는 알고리즘</li>
</ul>

<h2 id="언제-적용-가능한가">언제 적용 가능한가</h2>

<ul>
  <li>하나의 문제를 여러 개의 작은 문제로 나눌 수 있는 경우
    <ul>
      <li>작은 문제: <strong>overlapping</strong> subproblems -&gt; <strong>reused multiple times</strong></li>
    </ul>
  </li>
  <li>작은 문제의 해를 통해 원래 문제의 해를 만들 수 있는 경우</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F(n-1) + F(n-2)   =   F(n)
  subproblems  original problem
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>즉, 중복되는 부분 문제의 최적해를 통해 원래 문제의 최적 해를 얻을 수 있는 경우
</code></pre></div></div>

<p>하지만 주어진 문제가 이런 조건에 맞는지 알기 어렵다. 반대로, DP로 풀리는 문제가 가지는 대표적인 특징을 알아보자.</p>

<h2 id="적용-가능한-문제의-대표적인-특징">적용 가능한 문제의 대표적인 특징</h2>

<ul>
  <li>최대값, 최소값을 묻는 경우 (최소비용, 최대이윤, 가장 긴 거리)</li>
  <li>~할 수 있는 방법의 수를 묻는 경우 (A에서 B로 갈 수 있는 방법의 수)</li>
  <li>위의 2가지 특징은 Greedy 알고리즘 문제에서도 나타나는 특징</li>
  <li>Greedy 알고리즘과 구분되는 DP 문제만의 특징: <strong>미래의 결정이 이전의 결정에 의존</strong>
    <ul>
      <li>Greedy 알고리즒은 매 시점에서 최대의 이익을 얻는 방법</li>
    </ul>
  </li>
</ul>

<h2 id="문제-예시">문제 예시</h2>

<p>House Robber: 도둑이 집을 털 때, 훔칠 수 있는 돈의 최대 금액</p>

<p>문제가 여기서 끝이라면 Greedy 알고리즘을 써도 된다.</p>

<p>하지만 다음과 같은 제약사항이 있다고 해보자: <strong>adjacent하게 집을 털 수는 없다</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>각 집들이 가지고 있는 돈 = [2, 7, 9, 3, 1]

adjacent하게 집을 털 수 없기 때문에, 

2를 선택할 경우: 2 -&gt; 9 -&gt; 1
7을 선택할 경우: 7 -&gt; 3

과거에 2를 선택했는지, 7을 선택했는지에 따라 다음 내가 선택할 수 있는 결정이 달라진다 -&gt; DP로 접근해야함
</code></pre></div></div>

<h2 id="dp를-쓰는-이유">DP를 쓰는 이유</h2>

<ul>
  <li>DP는 복잡한 문제를 다루기 쉬운 하위 문제로 나눔</li>
  <li>중복되는 하위 문제의 불필요한 재계산을 피함 (하위 문제의 결과를 재사용) -&gt; 시간 복잡도 낮춤</li>
</ul>

<h1 id="dp-알고리즘-구현">DP 알고리즘 구현</h1>

<h2 id="bottom-up">Bottom-Up</h2>

<ul>
  <li><strong>Tabulation</strong> 이라고도 함</li>
  <li><strong>Iteration + Array</strong> 을 사용</li>
  <li>Start at the base case (ex. F(0) = 0, F(1) = 1)</li>
  <li>일반적으로 Top-Down 보다 <strong>빠름</strong></li>
  <li>부분 문제들 간의 논리적 순서를 따라야함</li>
</ul>

<h2 id="top-down">Top-Down</h2>

<ul>
  <li><strong>Memoization</strong> 이라고도 함</li>
  <li><strong>Recursion + Hash Table</strong> 을 사용</li>
  <li>Continue recursively until we reach the base case</li>
  <li>불필요한 계산을 피하기 위해 결과를 Memoization</li>
  <li>Bottom-Up보다 <strong>코드가 간결</strong></li>
  <li>부분 문제들 간의 순서는 상관없음</li>
</ul>

<h1 id="dp-문제를-풀기위해-필요한-구성요소-top-down-기준">DP 문제를 풀기위해 필요한 구성요소 (Top-Down 기준)</h1>

<ul>
  <li>매 주어진 상태에 대해 정답을 리턴하는 함수 또는 자료구조: dp[n]</li>
  <li>점화식: dp[i] = dp[i-1] dp[i-2]</li>
  <li>멈춤의 조건이 되는 베이스케이스: dp[0] = 0</li>
  <li>캐싱: Caching results from function calls and then refering to those results in the future</li>
  <li>Bottom-Up은 베이스 케이스에서 시작해서 최종해에 도달할 때 까지 반복</li>
</ul>

<h1 id="dp-greedy-algorithm-divide-and-conquer">DP, Greedy Algorithm, Divide and Conquer</h1>

<ul>
  <li>부분 문제의 최적해를 통해 원래 문제의 최적해를 찾는 방식의 알고리즘</li>
  <li>Greedy Algorithm과 Divide and Conquer는 부분 문제가 <strong>not overlapping</strong></li>
  <li>Divide and Conquer는 not overlapping하기 때문에 병렬적으로 시행 가능</li>
</ul>
:ET