I"<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#heap" id="markdown-toc-heap">Heap</a>    <ul>
      <li><a href="#우선순위-큐" id="markdown-toc-우선순위-큐">우선순위 큐</a></li>
      <li><a href="#힙" id="markdown-toc-힙">힙</a></li>
    </ul>
  </li>
  <li><a href="#heap-관련-연산" id="markdown-toc-heap-관련-연산">Heap 관련 연산</a>    <ul>
      <li><a href="#힙에-삽입이-발생한-경우" id="markdown-toc-힙에-삽입이-발생한-경우">힙에 삽입이 발생한 경우</a></li>
      <li><a href="#힙에-삭제가-발생한-경우" id="markdown-toc-힙에-삭제가-발생한-경우">힙에 삭제가 발생한 경우</a></li>
    </ul>
  </li>
  <li><a href="#heap-구현" id="markdown-toc-heap-구현">Heap 구현</a></li>
  <li><a href="#heap-활용" id="markdown-toc-heap-활용">Heap 활용</a>    <ul>
      <li><a href="#힙-정렬" id="markdown-toc-힙-정렬">힙 정렬</a></li>
      <li><a href="#top-k-문제" id="markdown-toc-top-k-문제">Top-K 문제</a></li>
      <li><a href="#k-th-요소" id="markdown-toc-k-th-요소">K-th 요소</a></li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="heap">Heap</h1>

<blockquote>
  <p>In many CS applications, we only need to access the largest or smallest element in the dataset. how do we efficiently access the largest or smallest element in the current dataset? The answer would be heap!</p>
</blockquote>

<h2 id="우선순위-큐">우선순위 큐</h2>

<ul>
  <li>힙과 우선순위 큐는 다른 의미</li>
  <li>힙은 데이터 구조(low-level), 우선순위 큐는 추상 자료형(high-level)</li>
  <li>힙은 우선순위 큐를 구현하는 한 가지 방법</li>
  <li>힙 말고도 배열, 링크드 리스트로 우선순위 큐를 구현할 수 있음(물론 시간 복잡도 차이 있음)</li>
</ul>

<h2 id="힙">힙</h2>

<ul>
  <li>힙은 <strong>완전 이진 트리</strong>의 특별한 케이스
    <ul>
      <li>완전 이진 트리: 이진 트리 + 리프 노드가 왼쪽부터 채워짐</li>
    </ul>
  </li>
  <li>각 노드들은 자식 노드보다 크다 (최대힙) (최소힙은 반대)</li>
</ul>

<h1 id="heap-관련-연산">Heap 관련 연산</h1>

<ul>
  <li>삽입 연산: O(logN)</li>
  <li>삭제 연산: O(logN)</li>
  <li>최대값/최소값 얻기: O(1)</li>
  <li>element가 힙에서 삽입/삭제되어도 계속 힙 성질이 유지되어야함
    <ul>
      <li>heapify 연산으로 힙 성질을 유지함</li>
      <li>한 번 삽입/삭제 연산이 일어날 때마다 heapify 실행</li>
      <li>heapify: 부모 노드와 자식 노드의 값을 계속 비교하며 스왑</li>
    </ul>
  </li>
</ul>

<h2 id="힙에-삽입이-발생한-경우">힙에 삽입이 발생한 경우</h2>

<ul>
  <li>삽입된 노드는 리프 노드에 추가 -&gt; 추가된 리프 노드에서 부터 heapify</li>
</ul>

<h2 id="힙에-삭제가-발생한-경우">힙에 삭제가 발생한 경우</h2>

<ul>
  <li>삭제는 항상 루트 노드에서 발생 -&gt; 루트 노드의 빈자리는 리프 노드가 채움 -&gt; 루트 노드에서 부터 heapify</li>
</ul>

<h1 id="heap-구현">Heap 구현</h1>

<ul>
  <li>힙을 파이썬에서 사용할 때는 간단히 heapq 모듈을 이용해 사용 가능
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">heapq</span>

<span class="n">heap_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Insert
</span><span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap_list</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">heap_list</span> <span class="o">==</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span>

<span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap_list</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">heap_list</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="c1"># Get
</span><span class="n">heap_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Delete
</span><span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap_list</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>힙을 직접 구현할 때는 리스트를 사용함
    <ul>
      <li>완전 이진 트리의 성질을 가지도록 하기 위해 부모 노드와 자식 노드의 관계를 정의해야함
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root node: 1
parent node: n
left child node: 2*n
right child node: 2*n + 1
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h1 id="heap-활용">Heap 활용</h1>

<h2 id="힙-정렬">힙 정렬</h2>

<h2 id="top-k-문제">Top-K 문제</h2>

<h2 id="k-th-요소">K-th 요소</h2>
:ET