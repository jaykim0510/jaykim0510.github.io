I":<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#변수란-무엇인가-왜-필요한가" id="markdown-toc-변수란-무엇인가-왜-필요한가">변수란 무엇인가? 왜 필요한가?</a></li>
  <li><a href="#변수-선언" id="markdown-toc-변수-선언">변수 선언</a></li>
  <li><a href="#변수-호이스팅" id="markdown-toc-변수-호이스팅">변수 호이스팅</a></li>
  <li><a href="#값의-할당" id="markdown-toc-값의-할당">값의 할당</a></li>
  <li><a href="#변수-네이밍" id="markdown-toc-변수-네이밍">변수 네이밍</a></li>
  <li><a href="#var-키워드" id="markdown-toc-var-키워드">var 키워드</a></li>
  <li><a href="#let-키워드" id="markdown-toc-let-키워드">let 키워드</a></li>
  <li><a href="#const-키워드" id="markdown-toc-const-키워드">const 키워드</a></li>
  <li><a href="#결론" id="markdown-toc-결론">결론</a></li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<h1 id="변수란-무엇인가-왜-필요한가">변수란 무엇인가? 왜 필요한가?</h1>

<p>사람은 계산과 기억을 모두 두뇌에서 하지만, 컴퓨터는 연산과 기억을 수행하는 부품이 나눠져 있다. 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.</p>

<p>메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다. 메모리 셀 하나의 크기는 1바이트이다. 각 셀은 고유의 메모리 주소를 갖는다. 모든 값은 메모리 상의 임의의 위치에 저장되고 CPU는 이 값을 읽어들여 연산을 수행한다. 연산 결과로 생성된 값도 메모리 상의 임의의 위치에 저장된다. 하지만 문제는 이 값을 재사용하기 위해서는 어디 저장되어야 하는지 알아야 하는데 모른다는 것이다. 설령 안다고 하더라도 개발자가 직접적으로 메모리에 접근하는 것은 위험하다. 그래서 자바스크립트는 직접적인 메모리 제어를 허용하지 않는다.</p>

<p>프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.</p>

<p>변수는 하나의 값을 저장하기 위해 확보한 <strong>메모리 공간을 식별하기 위해 붙인 이름</strong>을 말한다.</p>

<p>변수는 컴파일러 또는 인터프리터에 의해 메모리 공간의 주소로 치환되어 실행된다. 따라서 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 변수를 통해 안전하게 값에 접근할 수 있다.</p>

<h1 id="변수-선언">변수 선언</h1>

<p>변수 선언이란 변수를 생성하는 것을 말한다. 좀 더 자세히 말하면 메모리에는 값을 저장하기 위한 공간을 확보하고, 변수 이름을 메모리 공간의 주소로 연결(name binding)하는 것을 말한다.</p>

<p>변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 <code class="language-plaintext highlighter-rouge">var</code>, <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code> 키워드를 사용한다.</p>

<p>자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 걸쳐 수행한다.</p>
<ul>
  <li><strong>선언 단계</strong>: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.</li>
  <li><strong>초기화 단계</strong>: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 <code class="language-plaintext highlighter-rouge">undefined</code>를 할당해 초기화한다.</li>
</ul>

<p>이렇게 초기화 단계를 거침으로써 이전에 다른 애플리케이션이 사용했던 값(garbage value)이 재사용되는 것을 방지해줄 수 있다.</p>

<h1 id="변수-호이스팅">변수 호이스팅</h1>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">score</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">score</span><span class="p">;</span>
</code></pre></div></div>

<p>위의 코드를 보면 변수 선언문보다 변수를 참조하는 코드가 앞에 있다. 그럼에도 결과는 에러가 아닌 <code class="language-plaintext highlighter-rouge">undefined</code>다.</p>

<p>자바스크립트에서는 <strong>변수 선언이 런타임(소스코드가 실행되는 시점)이 아니라 그 이전 단계에서 먼저 실행</strong>된다.</p>

<p>자바스크립트 엔진은 소스코드를 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다. 이 과정에서 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아서 먼저 실행한다. 그리고 이 과정이 끝나면 비로소 모든 선언문을 제외한 나머지 코드를 한 줄씩 순차적으로 실행한다.</p>

<p>이처럼 모든 선언문(<code class="language-plaintext highlighter-rouge">var</code>, <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code>, <code class="language-plaintext highlighter-rouge">function</code>, <code class="language-plaintext highlighter-rouge">function*</code>, <code class="language-plaintext highlighter-rouge">class</code>)이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 특징을 <strong>호이스팅(hoisting)</strong>이라 한다. (단, ES6에서 도입된 <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code>, <code class="language-plaintext highlighter-rouge">class</code>를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다)</p>

<h1 id="값의-할당">값의 할당</h1>

<p>변수에 값을 할당할 때는 연산자 <code class="language-plaintext highlighter-rouge">=</code>를 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">score</span><span class="p">;</span> <span class="c1">// 변수 선언</span>
<span class="nx">score</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">// 값의 할당</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">score</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">// 변수 선언과 값의 할당</span>
</code></pre></div></div>

<p>자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 2개의 문으로 나누어 각각 실행한다. 이 때 주의할 점은 변수 선언과 값의 할당의 실행 시점이 다르다는 것이다. 변수 선언은 값의 할당이 일어나는 런타임 이전에 이루어진다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">score</span><span class="p">);</span> <span class="c1">// undefined</span>

<span class="kd">var</span> <span class="nx">score</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">score</span><span class="p">);</span> <span class="c1">// 80</span>
</code></pre></div></div>

<p>또한 변수의 선언과 값의 할당을 하나의 문으로 단축 표현해도 자바스크립트 엔진은 나누어 실행하므로, 변수에 먼저 <code class="language-plaintext highlighter-rouge">undefined</code>가 할당되어 초기화되는 것은 변함이 없다. 그리고 값이 할당될 때에는 새로운 메모리 공간을 확보하고 그 곳에 할당 값을 저장한다.</p>

<p><img src="../../images/js_8.png" alt="" /></p>

<p>이렇게 되고나면 <code class="language-plaintext highlighter-rouge">undefined</code>는 가비지 컬렉션에 의해 메모리에서 자동 해제된다.</p>

<h1 id="변수-네이밍">변수 네이밍</h1>
<p>자바스크립트는 변수 네이밍을 할 때에 카멜 케이스와 파스칼 케이스를 권장한다.</p>

<h1 id="var-키워드">var 키워드</h1>

<ul>
  <li>초기 자바스크립트에서 변수를 정의할 떄 사용한 키워드이다</li>
  <li>런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 <strong>선언 단계와 초기화 단계(undefined)가 한 번에 진행</strong>된다</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🦄 var 키워드의 단점
- var 키워드의 가장 대표적인 단점은 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프만 지원한다는 것이다.
- 중복 선언을 허용해서 의도치 않은 에러를 유발한다
- 변수 호이스팅을 일으키고 이는 가독성을 떨어트린다
</code></pre></div></div>

<h1 id="let-키워드">let 키워드</h1>

<ul>
  <li>ES6에서 <code class="language-plaintext highlighter-rouge">var</code> 키워드의 단점을 보완하기 위해 새로운 변수 선언 키워드인 <code class="language-plaintext highlighter-rouge">let</code>과 <code class="language-plaintext highlighter-rouge">const</code>를 도입했다</li>
  <li><code class="language-plaintext highlighter-rouge">let</code> 키워드는 변수를 중복 선언하면 문법 에러(Syntax Error)가 발생한다</li>
  <li>블록 레벨 스코프이다 -&gt; 함수, <code class="language-plaintext highlighter-rouge">if</code>문, <code class="language-plaintext highlighter-rouge">for</code>문, <code class="language-plaintext highlighter-rouge">while</code>문, <code class="language-plaintext highlighter-rouge">try/catch</code> 문 등을 지역 스코프로 인정한다</li>
  <li>변수 호이스팅이 발생하지 않는 것처럼 동작한다 (<code class="language-plaintext highlighter-rouge">undefined</code>로 초기화되는 단계는 실제 코드가 작성된 부분에 와서야 진행된다)</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 중복선언</span>
<span class="c1">// Syntax Error 발생</span>
<span class="c1">// Cannot redeclare block-scoped variable 'foo'</span>
<span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1">// 참고로 이렇게 다른 블록 스코프면 상관 없다</span>
<span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">{</span>
    <span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 호이스팅</span>

<span class="c1">// 여기서부터 이미 foo 라는 변수가 선언은 되어 있다. 하지만 undefined로 할당은 안되어 있다.</span>
<span class="c1">// 그래서 결론적으로 ReferenceError가 난다</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">apple</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">foo</span><span class="p">;</span> <span class="c1">// 여기 오면 이제 foo가 undefined로 초기화 된다</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// undefined</span>

<span class="nx">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 여기 오면 이제 foo가 1의 값으로 할당 된다</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// 1</span>
</code></pre></div></div>

<h1 id="const-키워드">const 키워드</h1>

<ul>
  <li>선언과 동시에 초기화해야 한다</li>
  <li>재할당이 불가능 하다 (다른 메모리 주소를 참조하도록 할 수 없다)
    <ul>
      <li>그래서 원시 값은 변경 불가다</li>
      <li>객체는 재할당 없이도 값을 변경할 수 있기 때문에 변경 가능하다</li>
    </ul>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 무조건 선언과 초기화를 같이 해야한다</span>
<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">foo</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 이런 식으로 재할당 불가능 하다 (원시 값은 바뀌면 무조건 다른 메모리 주소 가지게됨)</span>

<span class="c1">// 객체는 이렇게 값 변경되도 메모리 주소 그대로 유지</span>
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Lee</span><span class="dl">'</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Kim</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<h1 id="결론">결론</h1>

<ul>
  <li>우선적으로 <code class="language-plaintext highlighter-rouge">const</code> 사용</li>
  <li>재할당이 필요하면 <code class="language-plaintext highlighter-rouge">let</code> 사용</li>
</ul>

<h1 id="참고">참고</h1>
<ul>
  <li><a href="https://ko.wikipedia.org/wiki/네임_바인딩" target="_blank">name-binding</a></li>
</ul>
:ET