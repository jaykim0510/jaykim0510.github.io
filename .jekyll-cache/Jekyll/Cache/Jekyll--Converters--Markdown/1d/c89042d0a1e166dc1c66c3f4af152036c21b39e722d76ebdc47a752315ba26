I"<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#var" id="markdown-toc-var">var</a></li>
  <li><a href="#let" id="markdown-toc-let">let</a></li>
  <li><a href="#const" id="markdown-toc-const">const</a></li>
  <li><a href="#결론" id="markdown-toc-결론">결론</a></li>
</ul>

<hr />

<h1 id="var">var</h1>

<ul>
  <li><code class="language-plaintext highlighter-rouge">var</code>은 중복 선언을 허용한다</li>
  <li>함수 레벨 스코프이다</li>
  <li>변수 호이스팅이 일어난다</li>
  <li>(<code class="language-plaintext highlighter-rouge">var</code>은 런타임 이전에 무조건 <code class="language-plaintext highlighter-rouge">undefined</code>로 초기화되어서 런타임에 선언문을 만나기 전에 참조 에러가 안생기고 <code class="language-plaintext highlighter-rouge">undefined</code>를 참조한다)</li>
</ul>

<h1 id="let">let</h1>

<ul>
  <li>중복 선언은 금지하지만, 재할당은 허용한다 (재할당은 새로운 메모리 주소에 새로운 값을 저장하고 식별자가 새로운 메모리 주소와 바인딩되는 것을 말한다)</li>
  <li>블록 레벨 스코프이다</li>
  <li>변수 호이스팅이 발생하지만, 초기화가 런타임 때 선언문을 만났을 때 일어난다</li>
  <li>(변수가 런타임 이전에 등록은 되지만, 초기화는 런타임 때 선언문을 만났을 때 일어나기 때문에 그 전에 참조하면 참조 에러가 난다)</li>
</ul>

<h1 id="const">const</h1>

<ul>
  <li>중복 선언도 금지하고, 재할당도 금지한다</li>
  <li>블록 레벨 스코프이다</li>
  <li><code class="language-plaintext highlighter-rouge">let</code>과 마찬가지로 변수 호이스팅이 발생하지만, 호이스팅 발생하지 않는 것처럼 선언문 이 후에 참조할 수 있다</li>
</ul>

<h1 id="결론">결론</h1>

<ul>
  <li>ES6 이후로는 <code class="language-plaintext highlighter-rouge">var</code>은 사용하지 않아도 된다</li>
  <li>일단 <code class="language-plaintext highlighter-rouge">const</code>를 사용하자</li>
  <li>재할당이 필요한 경우는 <code class="language-plaintext highlighter-rouge">let</code>을 사용하자</li>
</ul>
:ET