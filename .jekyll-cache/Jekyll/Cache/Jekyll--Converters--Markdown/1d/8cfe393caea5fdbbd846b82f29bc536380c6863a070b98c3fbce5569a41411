I"Q*<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#state" id="markdown-toc-state">State</a>    <ul>
      <li><a href="#operator-state" id="markdown-toc-operator-state">Operator State</a></li>
      <li><a href="#keyed-state" id="markdown-toc-keyed-state">Keyed State</a></li>
    </ul>
  </li>
  <li><a href="#recovery" id="markdown-toc-recovery">Recovery</a>    <ul>
      <li><a href="#checkpoint" id="markdown-toc-checkpoint">Checkpoint</a></li>
      <li><a href="#savepoint" id="markdown-toc-savepoint">Savepoint</a></li>
    </ul>
  </li>
  <li><a href="#statebackend" id="markdown-toc-statebackend">StateBackend</a></li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<h1 id="state">State</h1>

<p>대부분의 어플리케이션은 상태를 저장하고 활용(stateful)합니다. 만약 각각의 이벤트를 단순히 변환(transformation)하는 용도의 어플리케이션이라면 상태(state)가 필요하지 않을 수도 있습니다. 하지만 단순한 비즈니스 로직조차도 이전의 이벤트나 중간 결과를 사용하는 경우가 대부분이기 때문에 상태를 저장해 활용하는 것은 대부분의 서비스에 중요한 요소입니다.</p>

<p>스트림 처리 어플리케이션의 경우 상태(state)의 중요성이 더욱 커지게 됩니다. 스트림 처리 어플리케이션에서 상태가 중요한 이유는 다음과 같습니다.</p>

<ul>
  <li><strong>Low Latency</strong>: 스트림 처리는 짧은 지연을 위해 값을 출력 후 갱신을 통해 정확도를 높이는 방식이기에 이전 값을 기억해야함</li>
  <li><strong>Recovery</strong>: 장애 발생시 저장된 상태를 통해 다시 복구가 가능</li>
</ul>

<p><img src="/images/flink_17.png" alt="" /></p>

<p>플링크에서는 상태를 프로그래밍 모델의 일급 시민(first-class citizen)으로 사용하고 있습니다. 플링크에서 상태 핸들링에 관한 주요 특징들에는 다음과 같은 것들이 있습니다.</p>

<ul>
  <li><strong>Multiple State Primitives</strong>: Flink provides state primitives for different data structures, such as atomic values, lists, or maps. Developers can choose the state primitive that is most efficient based on the access pattern of the function.</li>
  <li><strong>Pluggable State Backends</strong>: Application state is managed in and checkpointed by a pluggable state backend. Flink features different state backends that store state in memory or in RocksDB, an efficient embedded on-disk data store. Custom state backends can be plugged in as well.</li>
  <li><strong>Exactly-once state consistency</strong>: Flink’s checkpointing and recovery algorithms guarantee the consistency of application state in case of a failure. Hence, failures are transparently handled and do not affect the correctness of an application.</li>
  <li><strong>Very Large State</strong>: Flink is able to maintain application state of several terabytes in size due to its asynchronous and incremental checkpoint algorithm.</li>
  <li><strong>Scalable Applications</strong>: Flink supports scaling of stateful applications by redistributing the state to more or fewer workers.</li>
</ul>

<p>플링크에서 상태는 단순히 변수에 저장되는 하나의 값일 수도 있고, 파일이나 데이터베이스에 저장되는 데이터일 수도 있습니다. 이런 상태의 다양성을 반영하기 위해 플링크에서는 크게 두 가지 종류의 상태를 제공하며 또 각각의 상태별로 표현할 수 있는 기본 상태(State primitive)도 여러가지 입니다.</p>

<h2 id="operator-state">Operator State</h2>

<p><img src="/images/flink_15.png" alt="" /></p>

<p>연산자 상태(Operator State)는 태스크별로 자신의 상태를 저장하고 있습니다. 카프카에서 컨슈머 그룹 내 컨슈머별로 토픽의 파티션을 공유하지 않고 자신의 파티션을 가지는 것과 비슷한 용도입니다.</p>

<p>대부분의 플링크 어플리케이션에서는 연산자 상태가 필요하지 않습니다. 연산자 상태는 대부분 소스나 싱크쪽에서 필요로 하는 상태이기 때문입니다. 이러한 이유로 파이선의 DataStream API에서는 아직 연산자 상태를 지원하지 않습니다.</p>

<h2 id="keyed-state">Keyed State</h2>

<p><img src="/images/flink_16.png" alt="" /></p>

<p>키 상태(Keyed State)는 스트림 데이터가 가지는 키별로 접근할 수 있는 상태를 말합니다. 예를 들어 태스크로 들어온 데이터가 ‘Lion’이라는 키를 가지고 있으면 ‘Lion’키와 관련된 상태에만 접근할 수 있습니다. 따라서 스트림의 형태는 기본적으로 <code class="language-plaintext highlighter-rouge">KeyedStream</code>이어야 합니다.</p>

<p>KeyedState로 사용할 수 있는 기본 상태의 종류는 다음과 같습니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ValueState&lt;T&gt;</code> : 키별로 하나의 값만을 저장합니다(ex. 키별 최대값)</li>
  <li><code class="language-plaintext highlighter-rouge">ListState&lt;T&gt;</code> : 키별로 리스트를 저장합니다(ex. 키별 회원 이름)</li>
  <li><code class="language-plaintext highlighter-rouge">MapState&lt;UK, UV&gt;</code> : 키별로 키-값 쌍을 저장합니다. (ex. 키별 회원 이름과 직업 쌍)</li>
</ul>

<h1 id="recovery">Recovery</h1>

<p>플링크는 중간 결과를 저장하기 위해 상태를 로컬 버퍼에 저장하게 됩니다. 이를 통해 플링크는 짧은 지연으로 결과를 계속 갱신할 수 있습니다. 하지만 로컬 버퍼는 태스크매니저 프로세스가 종료되면 같이 사라지는 휘발성 저장소입니다. 이는 장애 발생시 실행중이던 태스크가 종료될 뿐 아니라 저장해두었던 상태도 함께 사라진다는 뜻입니다. 이를 위해 플링크에서는 상태를 주기적으로 체크포인팅해 원격의 영구저장소로 저장합니다.</p>

<p><img src="/images/flink_18.png" alt="" /></p>

<h2 id="checkpoint">Checkpoint</h2>

<p>스트림 처리 어플리케이션은 장비, 네트워크 등 예상치 못한 장애로 상태가 유실되거나 일관성을 잃게될 수 있습니다. 이를 위해 플링크는 주기적으로 원격 영구 저장소로 상태를 체크포인팅해야 합니다.</p>

<p>체크포인트의 naive한 알고리즘은 다음과 같습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 입력 데이터의 인입을 멈춘다
2. 어플리케이션에 남아있는 데이터를 처리한다
3. 각 태스크의 상태를 복사해 원격 영구저장소로 체크포인팅한다
4. 입력 데이터를 다시 받는다
</code></pre></div></div>

<p>플링크에서는 위와같은 naive한 알고리즘을 사용하지는 않습니다. 왜냐하면 위와 같이 체크포인팅을 할 경우 일명 ‘Stop the world’와 같이 체크포인팅을 하는 동안 어플리케이션 전체가 멈춰버리는 현상이 발생하기 때문에 짧은 지연을 요구하는 스트림 처리 어플리케이션에는 적합하지 않습니다.</p>

<p>따라서 플링크에서는 전체를 정지하지 않고 체크포인트와 처리간의 결합을 분리하였습니다. 다시 말해 일부 태스크는 상태를 저장하고, 일부 태스크는 데이터를 계속 처리하게 됩니다. 이를 <a href="https://www.microsoft.com/en-us/research/publication/distributed-snapshots-determining-global-states-distributed-system/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Flamport%2Fpubs%2Fchandy.pdf" target="_blank"><strong>챈디-램포트 알고리즘</strong></a> <strong>기반의 분산 스냅샷 체크포인팅</strong>이라고 합니다.</p>

<p>플링크의 분산 스냅샷의 핵심 요소는 체크포인트 <strong>배리어(barrier)</strong>입니다. 배리어는 이전 포스트에서 봤던 워터마크처럼 특별한 용도의 레코드입니다. 레코드이기 때문에 데이터 스트림에 주입되고 데이터 스트림의 일부로 레코드와 함께 흐릅니다.</p>

<p><img src="/images/flink_19.png" alt="" /></p>

<p>배리어는 데이터 스트림에 주입되어 스트림에 흐르고 있는 <strong>레코드들이 어떤 체크포인트에 속하는지 식별하도록 해주는 식별자</strong> 역할을합니다. 따라서 배리어 이전에 처리된 레코드가 만든 상태 변경은 배리어의 현재 체크포인트에 포함됩니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 잡 매니저가 모든 소스 태스크에 메시지를 보내서 체크포인트를 초기화한다
2. 소스태스크는 메시지 받은 후 레코드를 더이상 보내지 않는다
3. 소스태스크는 로컬 상태를 상태 백엔드에 체크포인팅한다
4. 소스태스크는 체크포인트 배리어를 소스와 연결된 모든 하위 병렬 태스크로 브로드캐스팅 한다
5. 상태 백엔드가 체크포인팅 완료하면 태스크에 알린다
6. 태스크는 잡 매니저에 체크포인팅 완료됐음을 알린다
7. 소스태스크는 배리어 전송 후 자신의 연산을 계속 수행한다
8. 입력 스트림은 체크포인트 시점 위치에서 다시 시작된다
</code></pre></div></div>

<h2 id="savepoint">Savepoint</h2>

<h1 id="statebackend">StateBackend</h1>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791161754093&amp;orderClick=LEa&amp;Kc=" target="_blank">아파치 플링크로 하는 스트림 데이터 처리 책</a></li>
  <li><a href="https://flink.apache.org/flink-applications.html" target="_blank">Flink 공식문서: What is Apache Flink? — Applications</a></li>
  <li><a href="https://nightlies.apache.org/flink/flink-docs-master/docs/concepts/stateful-stream-processing/" target="_blank">Flink 공식문서: Stateful Stream Processing</a></li>
  <li><a href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/fault-tolerance/state/#keyed-datastream" target="_blank">Flink 공식문서: Working with State</a></li>
  <li><a href="https://www.ververica.com/blog/performance-factors-stateful-functions-operators-flink" target="_blank">Ververica: 3 important performance factors for stateful functions and operators in Flink</a></li>
  <li><a href="https://mehmetozanguven.github.io/apache-flink/2020/05/02/state-backend-and-state-example.html" target="_blank">mehmetozanguven: Apache Flink Series 8-State Backend &amp; State Example</a></li>
</ul>
:ET