I"(><hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#mysql의-전체-구조" id="markdown-toc-mysql의-전체-구조">MySQL의 전체 구조</a></li>
  <li><a href="#mysql-엔진-아키텍처" id="markdown-toc-mysql-엔진-아키텍처">MySQL 엔진 아키텍처</a></li>
  <li><a href="#innodb-스토리지-엔진-아키텍처" id="markdown-toc-innodb-스토리지-엔진-아키텍처">InnoDB 스토리지 엔진 아키텍처</a>    <ul>
      <li><a href="#innodb-버퍼-풀" id="markdown-toc-innodb-버퍼-풀">InnoDB 버퍼 풀</a>        <ul>
          <li><a href="#lru-알고리즘" id="markdown-toc-lru-알고리즘">LRU 알고리즘</a></li>
        </ul>
      </li>
      <li><a href="#체인지-버퍼" id="markdown-toc-체인지-버퍼">체인지 버퍼</a></li>
      <li><a href="#로그-버퍼" id="markdown-toc-로그-버퍼">로그 버퍼</a></li>
      <li><a href="#리두-로그" id="markdown-toc-리두-로그">리두 로그</a>        <ul>
          <li><a href="#버퍼-풀과-리두-로그의-관계" id="markdown-toc-버퍼-풀과-리두-로그의-관계">버퍼 풀과 리두 로그의 관계</a></li>
          <li><a href="#버퍼-풀-플러시" id="markdown-toc-버퍼-풀-플러시">버퍼 풀 플러시</a></li>
        </ul>
      </li>
      <li><a href="#언두-로그" id="markdown-toc-언두-로그">언두 로그</a></li>
      <li><a href="#테이블-스페이스" id="markdown-toc-테이블-스페이스">테이블 스페이스</a></li>
      <li><a href="#어댑티브-해시-인덱스" id="markdown-toc-어댑티브-해시-인덱스">어댑티브 해시 인덱스</a></li>
    </ul>
  </li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<h1 id="mysql의-전체-구조">MySQL의 전체 구조</h1>

<p><img src="/images/mysql_2.png" alt="" /></p>

<ul>
  <li><strong>MySQL 엔진</strong>: 요청된 SQL문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행</li>
  <li><strong>스토리지 엔진</strong>: 데이터를 디스크에 저장하거나 디스크로부터 읽어오는 역할</li>
</ul>

<h1 id="mysql-엔진-아키텍처">MySQL 엔진 아키텍처</h1>

<ul>
  <li><strong>커넥션 핸들러</strong>: 클라이언트의 접속, 쿼리 요청을 처리</li>
  <li><strong>SQL 파서</strong>: 실행 이전에 문법성 오류 체크</li>
  <li><strong>SQL 옵티마이저</strong>: 쿼리의 최적화</li>
</ul>

<h1 id="innodb-스토리지-엔진-아키텍처">InnoDB 스토리지 엔진 아키텍처</h1>

<p><img src="/images/mysql_3.png" alt="" /></p>

<p>There is a metadata file (ibdata1, which holds, by default, data pages, index pages, table metadata and MVCC information), also known as the InnoDB tablespace file.</p>

<ul>
  <li>You can have more than one ibdata file (see innodb_data_file_path)</li>
  <li>There are redo logs (ib_logfile0 and ib_logfile1)</li>
  <li>You can have more than two redo logs (see innodb_log_files_in_group)</li>
  <li>You can spread data and indexes across multiple ibdata files if innodb_file_per_table is disabled</li>
  <li>You can separate data and index pages from ibdata into separate tablespace files (see innodb_file_per_table and StackOverflow Post on how to set this up)</li>
</ul>

<h2 id="innodb-버퍼-풀">InnoDB 버퍼 풀</h2>

<ul>
  <li>스토리지 엔진에서 가장 핵심적인 부분</li>
  <li><strong>데이터 캐시</strong>: 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간</li>
  <li><strong>쓰기 버퍼링</strong>: 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할</li>
  <li>페이지 크기의 조각으로 쪼개어 디스크로부터 읽어온 페이지를 저장</li>
  <li>
    <p>메모리 공간을 관리하기 위해 LRU리스트, 플러시 리스트, 프리 리스트라는 자료구조를 관리</p>
  </li>
  <li>The buffer pool is an area in main memory where InnoDB caches table and index data as it is accessed.</li>
  <li>The buffer pool permits frequently used data to be accessed directly from memory, which speeds up processing.</li>
  <li>On dedicated servers, up to 80% of physical memory is often assigned to the buffer pool.</li>
  <li>For efficiency of <strong>high-volume read</strong> operations, the buffer pool is divided into pages that can potentially hold multiple rows.</li>
  <li>For efficiency of cache management, <strong>the buffer pool is implemented as a linked list of pages</strong>; data that is rarely used is aged out of the cache using a variation of the least recently used (LRU) algorithm.</li>
</ul>

<h3 id="lru-알고리즘">LRU 알고리즘</h3>

<p><img src="/images/buffer_pool_1.png" alt="" /></p>

<ul>
  <li>테이블 데이터와 인덱스 데이터를 버퍼 풀에 캐시한다</li>
  <li>새로운 위치의 테이블 데이터 또는 인덱스 데이터를 버퍼 풀에 캐시하려는데 메모리에 더 이상 자리가 없다</li>
  <li>버퍼 풀에서 한동안 사용되지 않았던 페이지를 버퍼 풀에서 제거한다(만약 더티 페이지라면 플러시 후 제거)</li>
  <li>버퍼 풀에 있는 페이지들은 링크드 리스트 구조로 되어 있음</li>
  <li>이 링크드 리스트는 크게 두 개의 서브리스트로 구분됨 (New Sublist와 Old Sublist)</li>
  <li>(저는 New대신 Young이라고 하겠습니다. 공식 문서에서도 Young이라고도 하는데, 저는 Young이 더 와닿기 때문에)</li>
  <li>Young 서브리스트는 링크드 리스트의 HEAD에 가까운 5/8, Old 서브리스트는 링크드 리스트의 TAIL에 가까운 3/8</li>
  <li>이 Old 서브리스트가 삭제되는 페이지의 후보들이다(무조건 3/8이 다 삭제되는게 아니라, 필요한만큼 삭제됨)</li>
  <li>새로운 페이지는 Old 서브리스트의 HEAD로 감. 이 부분을 Midpoint라고도 함</li>
  <li>페이지들은 어떤 작업에 의해 젊어지고 늙어갈까?
    <ol>
      <li>유저의 SELECT 연산에 의해 데이터가 읽어지면 young해지고 Young 서브리스트의 제일 머리로 올라간다</li>
      <li>InnoDB에 의해 자동적으로 수행되는 Read-ahead 작업으로 데이터가 young해질 수도 있음</li>
      <li>SELECT 연산이 WHERE 조건문이 없으면 테이블 풀 스캔 -&gt; young해질 수도 있음</li>
    </ol>
  </li>
  <li>자동적으로 위와 같은 작업에 해당되지 않는 데이터들은 old해짐</li>
  <li>하지만 2번과 3번은 정말 의미있는 데이터를 young해지도록 하는 것은 아님 -&gt; 이로 인해 오히려 중요한 데이터가 old해지는 악영향을 초래할 수도 있음
    <ul>
      <li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-midpoint_insertion.html" target="_blank">MySQL 공식문서: Making the Buffer Pool Scan Resistant</a></li>
      <li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-read_ahead.html" target="_blank">MySQL 공식문서: Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)</a></li>
      <li>위의 문서를 참고하면, 중요한 데이터를 버퍼 풀에 고정시키는 방법과 같은 것들을 알 수 있음</li>
    </ul>
  </li>
</ul>

<p><strong>read-ahead</strong><br />
A type of I/O request that prefetches a group of pages (an entire extent) into the buffer pool asynchronously, in case these pages are needed soon. The linear read-ahead technique prefetches all the pages of one extent based on access patterns for pages in the preceding extent. The random read-ahead technique prefetches all the pages for an extent once a certain number of pages from the same extent are in the buffer pool. Random read-ahead is not part of MySQL 5.5, but is re-introduced in MySQL 5.6 under the control of the <code class="language-plaintext highlighter-rouge">innodb_random_read_ahead</code> configuration option.</p>

<h2 id="체인지-버퍼">체인지 버퍼</h2>

<blockquote>
  <p>The change buffer is a special data structure that caches changes to secondary index pages when those pages are not in the buffer pool. The buffered changes, which may result from INSERT, UPDATE, or DELETE operations (DML), are merged later when the pages are loaded into the buffer pool by other read operations.</p>
</blockquote>

<p><img src="/images/change_buffer_1.png" alt="" /></p>

<ul>
  <li>세컨더리 인덱스는 보통 유니크하지 않은 경우가 많다</li>
  <li>그리고 세컨더리 인덱스에 삽입하는 데이터는 보통 한 곳에서 순차적으로 발생하지 않고, 랜덤한 곳에서 발생한다</li>
  <li><code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, <code class="language-plaintext highlighter-rouge">DELETE</code>와 같은 DML작업이 세컨더리 인덱스(secondary index)를 가지는 컬럼에 발생했을 때,</li>
  <li>해당 변경사항을 반영하기 위해 세컨더리 인덱스를 업데이트 해야한다.</li>
  <li>이 때 만약 세컨더리 인덱스 페이지가 버퍼 풀에 없다면,</li>
  <li>세컨더리 인덱스 페이지를 업데이트 하기 위해 디스크에 접근하게 되면 디스크 I/O로 인해 성능 저하</li>
  <li>-&gt; 세컨더리 인덱스 페이지의 변경사항을 체인지 버퍼에 캐시해둔다</li>
  <li>나중에 <code class="language-plaintext highlighter-rouge">SELECT</code> 연산에 의해 버퍼 풀에 인덱스 페이지가 로드되면, 그 때 체인지 버퍼에 캐시된 변경사항을 버퍼 풀로 병합시킨다</li>
  <li>그래서 대량의 DML 작업이 발생할 때, 체인지 버퍼는 많은 도움이 된다</li>
  <li>하지만 체인지 버퍼는 버퍼 풀 메모리의 일부를 차지하고 있다</li>
  <li>그래서 만약 주로 읽기 작업이 발생하는 OLAP를 위해 사용하고 있거나, 세컨더리 인덱스가 별로 없는 경우에는 체인지 버퍼의 기능을 꺼두는 것이 좋다</li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html" target="_blank">MySQL 공식문서 참고. 내용 좋음</a></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>기본적으로 데이터/인덱스 변경사항은 버퍼 풀에 반영된다
근데 그중에서 세컨더리 인덱스에 한해,
버퍼 풀에 세컨더리 인덱스 페이지가 없을 때 변경 사항을 체인지 버퍼에 캐시해둔다
읽기 작업으로 버퍼 풀에 세컨더리 인덱스 페이지가 생겼으면 버퍼 풀에 있는 세컨더리 인덱스 페이지로 변경 사항을 병합한다

-&gt; 체인지 버퍼는 세컨더리 인덱스 페이지가 버퍼 풀에 없는 경우에만 유용하다
-&gt; 세컨더리 인덱스 페이지가 버퍼 풀에 있으면 변경 사항은 바로 버퍼 풀에 반영된다
</code></pre></div></div>

<h2 id="로그-버퍼">로그 버퍼</h2>

<blockquote>
  <p>The log buffer is the memory area that holds data to be written to the log files on disk. Log buffer size is defined by the <code class="language-plaintext highlighter-rouge">innodb_log_buffer_size</code> variable. The default size is 16MB. The contents of the log buffer are periodically flushed to disk. A large log buffer enables large transactions to run without the need to write redo log data to disk before the transactions commit. Thus, if you have transactions that update, insert, or delete many rows, increasing the size of the log buffer saves disk I/O.</p>
</blockquote>

<ul>
  <li>디스크의 로그 파일에 쓸 데이터를 버퍼링하는 메모리 영역</li>
  <li>기본 크기는 16MB</li>
  <li>로그 버퍼의 내용은 주기적으로 디스크로 플러시</li>
</ul>

<h2 id="리두-로그">리두 로그</h2>

<ul>
  <li>데이터의 변경 내용을 기록하는 디스크 기반 자료구조</li>
  <li>ACID의 D(Durable)에 해당하는 영속성과 가장 밀접하게 연관</li>
  <li>장애로 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 역할</li>
  <li>상대적으로 비용이 높은 쓰기 작업의 성능 향상을 위해 로그 버퍼에 리두 로그를 버퍼링한 후 디스크 영역에 저장</li>
  <li>데이터가 데이터 파일에 저장되는 시점보다 리두 로그가 로그 파일에 먼저 저장 -&gt; 리두 로그를 WAL 로그라고도 함</li>
</ul>

<h3 id="버퍼-풀과-리두-로그의-관계">버퍼 풀과 리두 로그의 관계</h3>

<ul>
  <li>버퍼 풀과 리두 로그의 관계를 이해하면 버퍼 풀 성능 향상에 도움이 되는 요소를 알 수 있음</li>
  <li>데이터 변경이 발생하면 버퍼 풀에는 더티 페이지가 생기고, 로그 버퍼에는 리두 로그 레코드가 버퍼링</li>
  <li>이 두가지 요소는 체크포인트마다 디스크로 동기화되어야 함</li>
  <li>체크포인트는 장애 발생시 리두 로그의 어느 부분부터 복구를 실행해야 할지 판단하는 기준점</li>
</ul>

<h3 id="버퍼-풀-플러시">버퍼 풀 플러시</h3>

<ul>
  <li>버퍼 풀을 플러시하면 버퍼 풀 메모리 공간과 리두 로그 공간을 모두 얻을 수 있음</li>
  <li>버퍼 풀을 플러시(더티 페이지들을 디스크에 동기화)하면 오래된 리두 로그 공간을 지울 수 있음</li>
  <li>이를 위해 InnoDB 스토리지 엔진은 주기적으로 플러시 리스트 플러시 함수를 호출</li>
  <li>플러시 리스트에서 오래 전에 변경된 데이터 페이지 순서대로 디스크에 동기화</li>
  <li>또한 사용 빈도가 낮은 데이터 페이지를 제거하기 위해 LRU 리스트 플러시 함수를 호출</li>
  <li>이 때 InnoDB 스토리지 엔진은 버퍼 풀을 스캔하며 더티 페이지는 동기화 클린 페이지는 프리 리스트로 옮김</li>
</ul>

<h2 id="언두-로그">언두 로그</h2>

<ul>
  <li>DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 백업된 데이터를 기록해두는 디스크 기반 자료구조</li>
  <li><strong>트랜잭션 보장</strong>: 트랜잭션이 롤백될 경우 원래 데이터로 복구하기 위해 언두 로그에 백업해둔 데이터를 이용</li>
  <li><strong>격리수준 보장</strong>: 특정 커넥션이 변경 중인 레코드에 다른 커넥션이 접근할 경우 격리수준에 맞게 언두 로그의 이전 데이터 제공</li>
  <li>대용량 데이터를 변경하거나, 오랜 시간 유지되는 트랜잭션이 증가할 경우 언두 로그의 크기 급격히 증가</li>
  <li>언두 로그의 사이즈가 커지면 쿼리 실행시 스토리지 엔진은 언두 로그를 필요한 만큼 스캔해야해서 쿼리의 성능이 감소</li>
</ul>

<h2 id="테이블-스페이스">테이블 스페이스</h2>

<h2 id="어댑티브-해시-인덱스">어댑티브 해시 인덱스</h2>

<h1 id="참고">참고</h1>

<ul>
  <li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791158392703&amp;orderClick=LAG&amp;Kc=" target="_blank">Real MySQL 8.0 (1권) 책</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html" target="_blank">MySQL 공식문서: InnoDB Buffer Pool</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html" target="_blank">MySQL 공식문서: Change Buffer</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html" target="_blank">MySQL 공식문서: The InnoDB Storage Engine</a></li>
  <li>
    <p><a href="https://myinfrabox.tistory.com/42" target="_blank">MyInfraBox: InnoDB Architecture</a></p>
  </li>
  <li><a href="" target="_blank"></a></li>
  <li><a href="" target="_blank"></a></li>
</ul>
:ET