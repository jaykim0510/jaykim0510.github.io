I"D/<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#디스크-읽기-방식" id="markdown-toc-디스크-읽기-방식">디스크 읽기 방식</a>    <ul>
      <li><a href="#hdd와-ssd" id="markdown-toc-hdd와-ssd">HDD와 SSD</a></li>
      <li><a href="#랜덤-io와-순차-io" id="markdown-toc-랜덤-io와-순차-io">랜덤 I/O와 순차 I/O</a></li>
    </ul>
  </li>
  <li><a href="#인덱스란" id="markdown-toc-인덱스란">인덱스란?</a></li>
  <li><a href="#b-tree-인덱스" id="markdown-toc-b-tree-인덱스">B-Tree 인덱스</a>    <ul>
      <li><a href="#myisam-스토리지-엔진의-b-tree-인덱스-구조-및-특성" id="markdown-toc-myisam-스토리지-엔진의-b-tree-인덱스-구조-및-특성">MyISAM 스토리지 엔진의 B-Tree 인덱스 구조 및 특성</a></li>
      <li><a href="#innodb-스토리지-엔진의-b-tree-인덱스-구조-및-특성" id="markdown-toc-innodb-스토리지-엔진의-b-tree-인덱스-구조-및-특성">InnoDB 스토리지 엔진의 B-Tree 인덱스 구조 및 특성</a></li>
      <li><a href="#데이터의-insert-update-delete시-인덱스에서의-동작" id="markdown-toc-데이터의-insert-update-delete시-인덱스에서의-동작">데이터의 Insert, Update, Delete시 인덱스에서의 동작</a></li>
      <li><a href="#b-tree-인덱스-사용에-영향을-미치는-요소" id="markdown-toc-b-tree-인덱스-사용에-영향을-미치는-요소">B-Tree 인덱스 사용에 영향을 미치는 요소</a></li>
      <li><a href="#데이터의-select시-인덱스에서의-동작" id="markdown-toc-데이터의-select시-인덱스에서의-동작">데이터의 Select시 인덱스에서의 동작</a>        <ul>
          <li><a href="#인덱스-레인지-스캔" id="markdown-toc-인덱스-레인지-스캔">인덱스 레인지 스캔</a></li>
          <li><a href="#인덱스-풀-스캔" id="markdown-toc-인덱스-풀-스캔">인덱스 풀 스캔</a></li>
          <li><a href="#테이블-풀-스캔" id="markdown-toc-테이블-풀-스캔">테이블 풀 스캔</a></li>
          <li><a href="#루스-인덱스-스캔" id="markdown-toc-루스-인덱스-스캔">루스 인덱스 스캔</a></li>
          <li><a href="#인덱스-스킵-스캔" id="markdown-toc-인덱스-스킵-스캔">인덱스 스킵 스캔</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#멀티-컬럼-인덱스" id="markdown-toc-멀티-컬럼-인덱스">멀티 컬럼 인덱스</a></li>
  <li><a href="#참고" id="markdown-toc-참고">참고</a></li>
</ul>

<hr />

<p><strong>인덱스는 데이터베이스 쿼리의 성능과 관련</strong>해서 빼놓을 수 없는 중요한 부분입니다. 인덱스에 대한 지식은 개발자나 관리자 모두에게 중요한 부분이며, 쿼리 튜닝의 기본이 됩니다.</p>

<h1 id="디스크-읽기-방식">디스크 읽기 방식</h1>
<p>보통 컴퓨터에서 가장 큰 성능 저하는 디스크 I/O에서 발생합니다. 따라서 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O을 줄이느냐가 관건일 때가 상당히 많습니다.</p>

<h2 id="hdd와-ssd">HDD와 SSD</h2>
<p>데이터베이스 서버에서 순차 I/O 작업보다는 랜덤 I/O이 차지하는 비중이 훨씬 큽니다. 그리고 이러한 랜덤 I/O의 속도를 훨씬 높여준 장치가 바로 SSD입니다. 이러한 이유로 DBMS용 스토리지에 SSD는 최적의 장치라고 할 수 있습니다.</p>

<h2 id="랜덤-io와-순차-io">랜덤 I/O와 순차 I/O</h2>
<p>랜덤 I/O은 데이터의 개수만큼 데이터의 위치를 찾아야 하고, 순차 I/O은 한 번만 데이터의 위치를 찾으면 되기 때문에 랜덤 I/O으로 인한 작업 부하가 훨씬 더 크게 발생합니다. HDD는 매번 데이터의 위치를 찾기 위해 디스크 헤드를 움직여야 하기 때문에 랜덤 I/O의 작업 부하는 훨씬 더 커지게 됩니다. SSD는 디스크 원판이 아닌 플래시 메모리를 사용하기 때문에 차이가 없을 것 같지만 마찬가지로 랜덤 I/O에서 성능이 저하됩니다.</p>

<p>그래서 일반적으로 <strong>쿼리 튜닝의 목적은 랜덤 I/O의 회수를 줄이는 것</strong>입니다. 여기서 랜덤 I/O을 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미합니다. 그리고 <strong>랜덤 I/O을 줄이기 위해 저희는 인덱스라는 것을 활용할 것</strong>입니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DBMS에서는 랜덤 I/O이 자주 발생하고, 쿼리의 성능을 높이기 위해서는 랜덤 I/O을 줄여야 한다.  
이렇게 랜덤 I/O을 줄이기 위해 DBMS에서는 인덱스를 사용한다.
</code></pre></div></div>

<h1 id="인덱스란">인덱스란?</h1>
<p>보통 인덱스를 설명할 때 <strong>책 맨 끝에 있는 색인</strong>을 예시로 많이 사용합니다. 예를 들어 책에서 ‘무궁화’라는 단어를 찾고 싶다면 저희는 책 페이지에서 내용을 하나씩 찾아보기 보다는 색인에서 ‘무궁화’라는 단어가 포함된 페이지의 쪽수를 찾게 될 겁니다.</p>

<p>DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 레코드(Row)를 가져오려면 시간이 오래 걸릴 것입니다. 그래서 <strong>컬럼의 값과 그 값을 가지는 레코드가 저장된 주소를 매핑한 인덱스</strong>를 만들어 두는 것입니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>책의 색인: 단어 - 책 페이지 매핑
DBMS의 인덱스: 컬럼 값 - 값을 가지는 레코드(Row)의 주소 매핑
</code></pre></div></div>

<p>그리고 인덱스의 중요한 특성 중 하나는 키(컬럼 값)가 정렬되어 있다는 것입니다. 예를 들어 테이블의 사람 이름을 나타내는 name이라는 컬럼으로 인덱스를 만들었다고 했을 때, name 값을 정렬하여 각각의 주소를 매핑해 인덱스를 만들게 됩니다.</p>

<p>아래는 인덱스 페이지의 예시로 다음과 같이 name이 알파벳 순으로 정렬되어 있습니다.</p>

<table>
  <tbody>
    <tr>
      <td><strong>name</strong></td>
      <td><strong>레코드 주소</strong></td>
    </tr>
    <tr>
      <td>Alice</td>
      <td>14345342</td>
    </tr>
    <tr>
      <td>Bob</td>
      <td>61345549</td>
    </tr>
    <tr>
      <td>Carl</td>
      <td>24641345</td>
    </tr>
    <tr>
      <td>Doson</td>
      <td>41127651</td>
    </tr>
  </tbody>
</table>

<p>이렇게 인덱스 페이지를 정렬했을 때 장단점이 있습니다.</p>

<ul>
  <li>장점: 정렬되어 있기 때문에 인덱스(컬럼 값)를 빠르게 찾고 결과적으로 데이터를 <strong>빠르게 읽어온다</strong></li>
  <li>단점: 컬럼 값에 INSERT, UPDATE, DELETE가 발생할 때마다 인덱스 파일을 정렬하기 때문에 <strong>저장 속도가 느리다</strong></li>
</ul>

<p>결론적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 데이터의 읽기 속도를 높여주게 됩니다. 그래서 인덱스 파일을 하나 더 추가할지 말지는 데이터의 저장 속도를 얼마만큼 희생하여, 그 결과로 읽기 성능을 얼마나 더 빠르게 만들지에 따라 결정되게 됩니다.</p>

<p>위에서 인덱스 페이지가 정렬되어 있어 인덱스 값을 빨리 찾을 수 있다고 했습니다. 정렬되어 있다는 것의 이점은 탐색 알고리즘에서 선형 탐색이 아닌 이진 탐색과 비슷하지만 이보다 더 빠른 탐색 알고리즘을 사용할 수 있다는 것입니다.</p>

<p>인덱스 파일은 이진 탐색을 지원하는 이진 트리 자료 구조와 비슷하지만 더 빠른 탐색을 가능하게 하는 <strong>Balanced Tree(B-Tree)</strong>라는 자료구조로 구현되어 있습니다.</p>

<p>이외에도 대표적으로 Hash Table 자료구조를 이용한 방법도 있으며 최근에는 Fractal-Tree, Merge-Tree와 같은 알고리즘을 사용하는 DBMS도 개발되고 있습니다.</p>

<p><strong>B-Tree 인덱스</strong></p>
<ul>
  <li>가장 일반적으로 사용되는 인덱스 형태</li>
  <li>컬럼 값을 변형하지 않고 원래의 값을 이용해 인덱싱</li>
  <li>B-Tree를 응용한 많은 자료구조가 등장</li>
</ul>

<p><strong>Hash Table 인덱스</strong></p>
<ul>
  <li>컬럼 값을 해시한 결과를 인덱스로 사용</li>
  <li>매우 빠른 검색 지원</li>
  <li>해시값을 인덱스로 사용해 컬럼 값의 일부만 검색하거나 범위를 검색할 때는 사용 불가</li>
  <li>주로 메모리 기반의 데이터베이스에서 많이 사용</li>
</ul>

<h1 id="b-tree-인덱스">B-Tree 인덱스</h1>

<p>디스크 기반 스토리지는 하드웨어적 특성으로 I/O의 <strong>가장 작은 단위가 페이지</strong>가 됩니다. 디스크 기반 자료구조는 디스크 접근 횟수를 최소화 하기 위해 데이터의 지역성을 높여야 한다. 이렇게 <strong>지역성을 높이는 방법은 페이지를 만들 때 비슷하게 참조되는 데이터를 페이지로 만드는 것</strong>입니다. 비슷하게 참조되는 데이터를 페이지로 만듦으로써 데이터를 조회할 때 페이지를 넘나드는 포인터를 최소화할 수 있습니다.</p>

<p>이렇게 만든 <strong>페이지가 B-트리에서 노드</strong>가 됩니다. 다시 말해 <strong>B-트리는 페이지 기반 자료구조</strong>입니다.</p>

<p>(비슷하게 참조되는 키값은 사실상 정렬했을 때 인근 키값들)</p>

<p>이제 <strong>키 값을 기준으로 그 키 값을 가지는 실제 파일 주소를 어떻게 찾는지 예시</strong>를 들어 설명해보겠습니다.</p>

<p>참고로 여기서 설명하는 B-트리는 엄밀히 B+ 트리입니다 B-트리와 B+ 트리의 차이는 B-트리는 루트 노드, 브랜치 노드, 리프 노드 모든 레벨에 값을 저장하는 것이 가능하고, <strong>B+ 트리의 경우 브랜치 노드에 리프노드에 저장된 값을 찾는데 필요한 구분(seperator) 키만 저장</strong>합니다.</p>

<p><img src="/images/sql_10.png" alt="" /></p>

<p><strong>MySQL에서는 MyISAM, InnoDB 모두 B+ 트리 형태</strong>로 되어 있고, 편의상 그냥 B-트리라고 하기 때문에 B-트리라고 하더라도 마음속으로는 B+ 트리 형태를 떠올리면 되겠습니다.</p>

<p>참고로 이러한 B+ 트리는 리프 노드에만 값을 저장하기 때문에 Insert, Update, Delete 연산은 리프노드에만 영향을 미칩니다. 상위 레벨의 노드는 트리 균형을 위해 분할 혹은 병합이 일어날 때만 영향을 받습니다.</p>

<h2 id="myisam-스토리지-엔진의-b-tree-인덱스-구조-및-특성">MyISAM 스토리지 엔진의 B-Tree 인덱스 구조 및 특성</h2>

<p><img src="/images/sql_11.png" alt="" /></p>

<h2 id="innodb-스토리지-엔진의-b-tree-인덱스-구조-및-특성">InnoDB 스토리지 엔진의 B-Tree 인덱스 구조 및 특성</h2>

<p><img src="/images/sql_12.png" alt="" /></p>

<h2 id="데이터의-insert-update-delete시-인덱스에서의-동작">데이터의 Insert, Update, Delete시 인덱스에서의 동작</h2>

<h2 id="b-tree-인덱스-사용에-영향을-미치는-요소">B-Tree 인덱스 사용에 영향을 미치는 요소</h2>

<h2 id="데이터의-select시-인덱스에서의-동작">데이터의 Select시 인덱스에서의 동작</h2>

<h3 id="인덱스-레인지-스캔">인덱스 레인지 스캔</h3>

<h3 id="인덱스-풀-스캔">인덱스 풀 스캔</h3>

<h3 id="테이블-풀-스캔">테이블 풀 스캔</h3>

<h3 id="루스-인덱스-스캔">루스 인덱스 스캔</h3>

<h3 id="인덱스-스킵-스캔">인덱스 스킵 스캔</h3>

<h1 id="멀티-컬럼-인덱스">멀티 컬럼 인덱스</h1>

<h1 id="참고">참고</h1>

:ET