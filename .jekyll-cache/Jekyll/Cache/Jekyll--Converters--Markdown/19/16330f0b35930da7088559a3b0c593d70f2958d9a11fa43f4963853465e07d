I"[<hr />
<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#비동기란" id="markdown-toc-비동기란">비동기란</a></li>
  <li><a href="#백엔드에서-비동기가-필요한-때" id="markdown-toc-백엔드에서-비동기가-필요한-때">백엔드에서 비동기가 필요한 때</a></li>
  <li><a href="#자바스크립트에서-비동기-구현-방식" id="markdown-toc-자바스크립트에서-비동기-구현-방식">자바스크립트에서 비동기 구현 방식</a></li>
</ul>

<hr />

<h1 id="비동기란">비동기란</h1>

<p>블로킹은 요청에 대한 결과를 바로 줄 수 없는 경우 그 결과를 기다리도록 하는것을 의미합니다. 요청에 대한 결과를 바로 받을 수 없는 상황에서, 블로킹의 경우엔 결과가 나타날 때 까지 기다리게 됩니다.
블로킹은 요청에 대한 결과가 올 때 까지 쓰레드는 아무것도 하지 못하고 대기하게 됩니다</p>

<p>논블로킹에선 결과를 기다리지 않고, 바로 종료됩니다. 요청에 대한 응답을 기다리지 않고, 다음 작업을 바로 수행 할 수 있게 되는것이죠
논블로킹은 항상 요청에 대한 결과를 기다리지 않고 바로 반환을 하게됩니다.</p>

<p>Synchronous는 결과를 기다리는 주체가 요청을 호출한 Thread입니다. 해당 Thread는 요청에 대한 결과가 돌아오기까지 아무것도 하지 않게 될것입니다. Blocking / Non-Blocking에서 나타낸 모든 예시는 사실 Synchronous인 경우를 가정하여 설명했습니다.</p>

<p>Synchronous이면서 Blocking인 경우에는, I/O 요청을 한 Thread가 I/O 응답이 올 때 까지 아무일도 안하고 기다리게 됩니다
결과를 기다리는 주체가 호출한 자신이 되는것이지요</p>

<p>하지만 Synchronous이면서 Non-Blocking인 경우엔 “I/O 응답이 아직 오지 않았다” 자체가 결과가 되어 즉시 반환됩니다.</p>

<p>위 그림은 Asynchronous + Non-Blocking의 경우를 도식화 한 것 입니다. Asynchronous의 경우에는 위와같이 Callback을 등록함으로써 I/O 요청을 보내게 됩니다.</p>

<p>Callback을 등록한 결과는 기다림 없이 즉시 반환되게 되지요(Non-Blocking). 그리고 I/O 결과는 해당 Thread가 아니더라도 Signal을 통해 호출된 callback으로 처리되게 됩니다.</p>

<p>Asynchronous이면서 Blocking인 경우도 있지만 일반적으로 비효율적인 방식이라 잘 활용되지 않기에 굳이 소개하지는 않도록 하겠습니다.</p>

<h1 id="백엔드에서-비동기가-필요한-때">백엔드에서 비동기가 필요한 때</h1>

<p>비동기 프로그래밍은 현대 웹 애플리케이션의 핵심 개념 중 하나로, 사용자 경험을 향상시키고 서버 효율성을 높이는 데 중요한 역할을 합니다. 이 글에서는 비동기 프로그래밍의 필요성과 Node.js가 어떻게 비동기 프로그래밍을 지원하는지에 대해 알아보겠습니다.</p>

<p>비동기 프로그래밍은 동시에 여러 작업을 처리할 수 있도록 해주며, I/O 바운드 작업을 효율적으로 다룰 수 있는 방법을 제공합니다. Node.js는 이러한 개념을 활용하여 JavaScript로 서버 애플리케이션을 개발할 수 있게 해줍니다. 비동기 프로그래밍은 콜백 함수, 프로미스, async/await와 같은 패턴을 사용하여 구현됩니다. Node.js는 이러한 패턴들을 네이티브하게 지원하며, 이를 통해 비동기 작업을 간편하게 다룰 수 있습니다.</p>

<h1 id="자바스크립트에서-비동기-구현-방식">자바스크립트에서 비동기 구현 방식</h1>

<ul>
  <li><a href="https://velog.io/@onejaejae/%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B9%84%EB%8F%99%EA%B8%B0-IO-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BB%A4%EB%AE%A4%EB%8B%88%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B9%84%EB%8F%99%EA%B8%B0asynchronous">동기 vs. 비동기 통신: 백엔드 시스템 설계의 핵심, onejaejae</a></li>
  <li><a href="https://choi-geonu.medium.com/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%B4-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%A0-%EB%8F%99%EC%8B%9C%EC%84%B1-2-%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-e11b3d01fdf8">백엔드 개발자들이 알아야할 동시성 2 — 블로킹과 논블로킹, 동기와 비동기, Choi Geonu</a></li>
  <li><a href="https://d0lim.com/blog/2023/07/async-programming-0/">비동기 프로그래밍 - 간단한 고찰, 도림.로그</a></li>
</ul>
:ET