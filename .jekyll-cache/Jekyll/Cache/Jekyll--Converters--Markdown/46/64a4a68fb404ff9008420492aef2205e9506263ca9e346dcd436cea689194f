I"˜2<hr />

<p id="toc"><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
  <li><a href="#flink-ìƒíƒœê³„-êµ¬ì„±" id="markdown-toc-flink-ìƒíƒœê³„-êµ¬ì„±">Flink ìƒíƒœê³„ êµ¬ì„±</a></li>
  <li><a href="#flink-ëŸ°íƒ€ì„-ì•„í‚¤í…ì²˜" id="markdown-toc-flink-ëŸ°íƒ€ì„-ì•„í‚¤í…ì²˜">Flink ëŸ°íƒ€ì„ ì•„í‚¤í…ì²˜</a>    <ul>
      <li><a href="#job-manager" id="markdown-toc-job-manager">Job Manager</a></li>
      <li><a href="#task-manager" id="markdown-toc-task-manager">Task Manager</a></li>
      <li><a href="#tasks-and-operator-chains" id="markdown-toc-tasks-and-operator-chains">Tasks and Operator Chains</a></li>
      <li><a href="#task-slots-and-resources" id="markdown-toc-task-slots-and-resources">Task Slots and Resources</a></li>
    </ul>
  </li>
  <li><a href="#task-scheduling-and-network-shuffle" id="markdown-toc-task-scheduling-and-network-shuffle">Task Scheduling And Network Shuffle</a></li>
  <li><a href="#flink-api" id="markdown-toc-flink-api">Flink API</a></li>
  <li><a href="#ì°¸ê³ " id="markdown-toc-ì°¸ê³ ">ì°¸ê³ </a></li>
</ul>

<hr />

<h1 id="flink-ìƒíƒœê³„-êµ¬ì„±">Flink ìƒíƒœê³„ êµ¬ì„±</h1>

<p><img src="/images/flink_23.png" alt="" /></p>

<h1 id="flink-ëŸ°íƒ€ì„-ì•„í‚¤í…ì²˜">Flink ëŸ°íƒ€ì„ ì•„í‚¤í…ì²˜</h1>

<p>í”Œë§í¬ ëŸ°íƒ€ì„ì€ ë‘ ì¢…ë¥˜ì˜ í”„ë¡œì„¸ìŠ¤ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤. í•˜ë‚˜ëŠ” <strong>Job Manager</strong>ì´ê³  ë‹¤ë¥¸ í•˜ë‚˜ëŠ” <strong>Task Manger</strong>ë¡œ Task ManagerëŠ” í•œ ê°œ ì´ìƒìœ¼ë¡œ êµ¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>

<p>í”Œë§í¬ í´ë¼ì´ì–¸íŠ¸ëŠ” ëŸ°íƒ€ì„ì— í¬í•¨ë˜ì§€ëŠ” ì•Šì§€ë§Œ ë°ì´í„°í”Œë¡œìš°ë¥¼ Job Managerë¡œ ë³´ë‚´ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤. ì´ í›„ í´ë¼ì´ì–¸íŠ¸ëŠ” ì—°ê²°ì„ ëŠì„ ìˆ˜ë„ ìˆê³  ë˜ëŠ” attached modeë¥¼ í†µí•´ ì§„í–‰ ê²½ê³¼ë¥¼ ë³´ê³  ë°›ì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” ìë°” ìœ„ì—ì„œ í´ë¼ì´ì–¸íŠ¸ ëª…ë ¹ì–´ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤.</p>

<p><img src="/images/flink_22.png" alt="" /></p>

<h2 id="job-manager">Job Manager</h2>

<p>ì¡ ë§¤ë‹ˆì €ëŠ” ì–´í”Œë¦¬ì¼€ì´ì…˜ì˜ <strong>ì‹¤í–‰ì„ ì œì–´í•˜ëŠ” ë§ˆìŠ¤í„° í”„ë¡œì„¸ìŠ¤</strong>ì…ë‹ˆë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” ì¡ ë§¤ë‹ˆì €ë¡œ ì–´í”Œë¦¬ì¼€ì´ì…˜ì„ ì œì¶œí•©ë‹ˆë‹¤. ì–´í”Œë¦¬ì¼€ì´ì…˜ì€ ë°ì´í„°í”Œë¡œìš° ê·¸ë˜í”„(ë˜ëŠ” ì¡ê·¸ë˜í”„)ì™€ í•„ìš”í•œ í´ë˜ìŠ¤, ë¼ì´ë¸ŒëŸ¬ë¦¬ ë“±ì„ í¬í•¨í•˜ëŠ” JARíŒŒì¼ë¡œ êµ¬ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤.</p>

<p>ì¡ ë§¤ë‹ˆì €ëŠ” ì¡ê·¸ë˜í”„ë¥¼ ì‹¤í–‰ê·¸ë˜í”„(ExecutionGraph)ë¼ê³  ë¶ˆë¦¬ëŠ” ë¬¼ë¦¬ì ì¸ ê·¸ë˜í”„ë¡œ ë³€í™˜í•©ë‹ˆë‹¤. ì¡ ë§¤ë‹ˆì €ëŠ” íƒœìŠ¤í¬ ë§¤ë‹ˆì €ë‚´ì— ì‚¬ìš© ê°€ëŠ¥í•œ íƒœìŠ¤í¬ ìŠ¬ë¡¯ì— ì¡ê·¸ë˜í”„ë¥¼ íƒœìŠ¤í¬ í˜•íƒœë¡œ ë°°í¬í•©ë‹ˆë‹¤.</p>

<p><img src="/images/flink_25.png" alt="" /></p>

<p>ë˜í•œ ì¡ ë§¤ë‹ˆì €ëŠ” ì™„ë£Œëœ íƒœìŠ¤í¬, ì‹¤í–‰ ì‹¤íŒ¨, ì¥ì•  ë³µêµ¬, ì²´í¬í¬ì¸íŠ¸ ì¡°ìœ¨ ë“± ì¤‘ì•™ì—ì„œ ì œì–´í•´ì•¼ í•˜ëŠ” ëª¨ë“  ë™ì‘ì— ì±…ì„ì„ ì§‘ë‹ˆë‹¤.</p>

<p><img src="/images/flink_21.png" alt="" /></p>

<h2 id="task-manager">Task Manager</h2>

<p>íƒœìŠ¤í¬ ë§¤ë‹ˆì €(ì›Œì»¤)ëŠ” <strong>ë°ì´í„°í”Œë¡œìš°ì˜ íƒœìŠ¤í¬ë“¤ì„ ì‹¤í–‰</strong>í•©ë‹ˆë‹¤. íƒœìŠ¤í¬ ë§¤ë‹ˆì €ì— í• ë‹¹í•˜ëŠ” ê°€ì¥ ì‘ì€ ì‘ì—… ë‹¨ìœ„ë¥¼ íƒœìŠ¤í¬ ìŠ¬ë¡¯ì´ë¼ê³  í•©ë‹ˆë‹¤. íƒœìŠ¤í¬ ë§¤ë‹ˆì € ì•ˆì— ìˆëŠ” ìŠ¬ë¡¯ì˜ ê°œìˆ˜ëŠ” ë™ì‹œì— ì²˜ë¦¬ë˜ëŠ” ì‘ì—…ì˜ ê°œìˆ˜ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. í•˜ë‚˜ì˜ ìŠ¬ë¡¯ì•ˆì—ì„œ ì—¬ëŸ¬ê°œì˜ ì—°ì‚°ìê°€ ì‹¤í–‰ë  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.</p>

<p><img src="/images/flink_26.png" alt="" /></p>

<h2 id="tasks-and-operator-chains">Tasks and Operator Chains</h2>

<p>í”Œë§í¬ì˜ íƒœìŠ¤í¬ëŠ” ì—°ì‚°ìë¥¼ ì²´ì´ë‹í•œ ì„œë¸ŒíƒœìŠ¤í¬ì˜ ì§‘í•©ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤. ê°ê°ì˜ ì„œë¸ŒíƒœìŠ¤í¬ëŠ” í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ë©ë‹ˆë‹¤. ì´ë ‡ê²Œ ì—°ì‚°ìë“¤ì„ ì²´ì´ë‹ í•¨ìœ¼ë¡œì¨ í”Œë§í¬ëŠ” ìŠ¤ë ˆë“œê°„ í•¸ë“œì˜¤ë²„ì™€ ë²„í¼ë§ìœ¼ë¡œ ì¸í•œ ì˜¤ë²„í—¤ë“œë¥¼ ì¤„ì…ë‹ˆë‹¤. ì´ëŠ” ì „ì²´ì ì¸ ì²˜ë¦¬ëŸ‰ ì¦ê°€ì™€ ì§€ì—°ìœ¨ ê°ì†Œë¥¼ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.</p>

<p><img src="/images/flink_28.png" alt="" /></p>

<h2 id="task-slots-and-resources">Task Slots and Resources</h2>

<p>íƒœìŠ¤í¬ ë§¤ë‹ˆì €ëŠ” ê°ê° í•˜ë‚˜ì˜ JVM í”„ë¡œì„¸ìŠ¤ì…ë‹ˆë‹¤. ê·¸ë¦¬ê³  íƒœìŠ¤í¬ ë§¤ë‹ˆì €ëŠ” í•˜ë‚˜ ì´ìƒì˜ ì„œë¸ŒíƒœìŠ¤í¬ë¥¼ ìŠ¤ë ˆë“œë¡œ ë¶„ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>

<p>ê°ê°ì˜ íƒœìŠ¤í¬ ìŠ¬ë¡¯ì€ ê°ê°ì˜ ë¶„ë¦¬ëœ ìì›ìœ¼ë¡œ ê°€ì¥ ì‘ì€ ì‘ì—… ë‹¨ìœ„ ì…ë‹ˆë‹¤. íƒœìŠ¤í¬ ìŠ¬ë¡¯ìœ¼ë¡œ ë¶„ë¦¬ëœ ì‘ì—…ë“¤ì€ ìì›ì„ ìœ„í•´ ì„œë¡œ ê²½ìŸí•  ì¼ì´ ì—†ìŠµë‹ˆë‹¤. íƒœìŠ¤í¬ ìŠ¬ë¡¯ì—ì„œ ë¶„ë¦¬í•˜ëŠ” ìì›ì€ ë©”ëª¨ë¦¬ ë¿ì…ë‹ˆë‹¤. CPUëŠ” ë¶„ë¦¬ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</p>

<p>íƒœìŠ¤í¬ ë§¤ë‹ˆì €ëŠ” ê°ê° í•˜ë‚˜ì˜ JVM í”„ë¡œì„¸ìŠ¤ì´ê¸° ë•Œë¬¸ì— íƒœìŠ¤í¬ ë§¤ë‹ˆì €ê°€ ì—¬ëŸ¬ê°œì˜ íƒœìŠ¤í¬ ìŠ¬ë¡¯ì„ ê°€ì§„ë‹¤ë©´ ì—¬ëŸ¬ê°œì˜ íƒœìŠ¤í¬ê°€ í•˜ë‚˜ì˜ JVM í”„ë¡œì„¸ìŠ¤ ìœ„ì—ì„œ ì‹¤í–‰ëœë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤. í•˜ë‚˜ì˜ JVM ìœ„ì—ì„œ ì‹¤í–‰ë˜ëŠ” íƒœìŠ¤í¬ë“¤ì€ TCP ì—°ê²°ì„ í†µí•´ ì„œë¡œ í•˜íŠ¸ë¹„íŠ¸ ë©”ì„¸ì§€ë¥¼ ì£¼ê³  ë°›ìŠµë‹ˆë‹¤. ë˜í•œ íƒœìŠ¤í¬ê°„ ë°ì´í„°ì…‹ì„ ê³µìœ í•¨ìœ¼ë¡œì¨ íƒœìŠ¤í¬ë³„ë¡œ ë°œìƒí•˜ëŠ” ì˜¤ë²„í—¤ë“œë¥¼ ì¤„ì—¬ì¤ë‹ˆë‹¤.</p>

<p>í”Œë§í¬ëŠ” ë””í´íŠ¸ë¡œ ì‘ì—…ì˜ ì „ì²´ íŒŒì´í”„ë¼ì¸ì„ í•˜ë‚˜ì˜ ìŠ¬ë¡¯ì— í• ë‹¹í•©ë‹ˆë‹¤.</p>

<p><img src="/images/flink_27.png" alt="" /></p>

<h1 id="task-scheduling-and-network-shuffle">Task Scheduling And Network Shuffle</h1>

<p>Flink jobs consist of different operations that are connected together in a dataflow graph. The system decides how to schedule the execution of these operations on different processes/machines (TaskManagers) and how data is shuffled (sent) between them.</p>

<p>Multiple operations/operators can be chained together using a feature called chaining. A group of one or multiple (chained) operators that Flink considers as a unit of scheduling is called a task. Often the term subtask is used to refer to the individual instances of tasks that are running in parallel on multiple TaskManagers but we will only use the term task here.</p>

<p>Task scheduling and network shuffles work differently for BATCH and STREAMING execution mode. Mostly due to the fact that we know our input data is bounded in BATCH execution mode, which allows Flink to use more efficient data structures and algorithms.</p>

<p>We will use this example to explain the differences in task scheduling and network transfer:</p>

<p>Operations that imply a 1-to-1 connection pattern between operations, such as <code class="language-plaintext highlighter-rouge">map()</code>, <code class="language-plaintext highlighter-rouge">flatMap()</code>, or <code class="language-plaintext highlighter-rouge">filter()</code> can just forward data straight to the next operation, which allows these operations to be chained together. This means that Flink would not normally insert a network shuffle between them.</p>

<p>Operation such as <code class="language-plaintext highlighter-rouge">keyBy()</code> or <code class="language-plaintext highlighter-rouge">rebalance()</code> on the other hand require data to be shuffled between different parallel instances of tasks. This induces a network shuffle.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="nc">DataStreamSource</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(...);</span>

<span class="n">source</span><span class="o">.</span><span class="na">name</span><span class="o">(</span><span class="s">"source"</span><span class="o">)</span>
	<span class="o">.</span><span class="na">map</span><span class="o">(...).</span><span class="na">name</span><span class="o">(</span><span class="s">"map1"</span><span class="o">)</span>
	<span class="o">.</span><span class="na">map</span><span class="o">(...).</span><span class="na">name</span><span class="o">(</span><span class="s">"map2"</span><span class="o">)</span>
	<span class="o">.</span><span class="na">rebalance</span><span class="o">()</span>
	<span class="o">.</span><span class="na">map</span><span class="o">(...).</span><span class="na">name</span><span class="o">(</span><span class="s">"map3"</span><span class="o">)</span>
	<span class="o">.</span><span class="na">map</span><span class="o">(...).</span><span class="na">name</span><span class="o">(</span><span class="s">"map4"</span><span class="o">)</span>
	<span class="o">.</span><span class="na">keyBy</span><span class="o">((</span><span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">)</span>
	<span class="o">.</span><span class="na">map</span><span class="o">(...).</span><span class="na">name</span><span class="o">(</span><span class="s">"map5"</span><span class="o">)</span>
	<span class="o">.</span><span class="na">map</span><span class="o">(...).</span><span class="na">name</span><span class="o">(</span><span class="s">"map6"</span><span class="o">)</span>
	<span class="o">.</span><span class="na">sinkTo</span><span class="o">(...).</span><span class="na">name</span><span class="o">(</span><span class="s">"sink"</span><span class="o">);</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Task1: source, map1, and map2
Task2: map3, map4
Task3: map5, map6, and sink
</code></pre></div></div>

<p>And we have a network shuffle between Tasks 1 and 2, and also Tasks 2 and 3. This is a visual representation of that job:</p>

<p><img src="/images/flink_31.png" alt="" /></p>

<h1 id="flink-api">Flink API</h1>

<p><img src="/images/flink_24.png" alt="" /></p>

<ul>
  <li>
    <p>The lowest level abstraction simply offers stateful and timely stream processing. It is embedded into the DataStream API via the Process Function. It allows users to freely process events from one or more streams, and provides consistent, fault tolerant state. In addition, users can register event time and processing time callbacks, allowing programs to realize sophisticated computations.</p>
  </li>
  <li>
    <p>In practice, many applications do not need the low-level abstractions described above, and can instead program against the Core APIs: the DataStream API (bounded/unbounded streams) and the DataSet API (bounded data sets). These fluent APIs offer the common building blocks for data processing, like various forms of user-specified transformations, joins, aggregations, windows, state, etc. Data types processed in these APIs are represented as classes in the respective programming languages.</p>

    <p>The low level Process Function integrates with the DataStream API, making it possible to use the lower-level abstraction on an as-needed basis. The DataSet API offers additional primitives on bounded data sets, like loops/iterations.</p>
  </li>
  <li>
    <p>The Table API is a declarative DSL centered around tables, which may be dynamically changing tables (when representing streams). The Table API follows the (extended) relational model: Tables have a schema attached (similar to tables in relational databases) and the API offers comparable operations, such as select, project, join, group-by, aggregate, etc. Table API programs declaratively define what logical operation should be done rather than specifying exactly how the code for the operation looks. Though the Table API is extensible by various types of user-defined functions, it is less expressive than the Core APIs, and more concise to use (less code to write). In addition, Table API programs also go through an optimizer that applies optimization rules before execution.</p>

    <p>One can seamlessly convert between tables and DataStream/DataSet, allowing programs to mix the Table API with the DataStream and DataSet APIs.</p>
  </li>
  <li>
    <p>The highest level abstraction offered by Flink is SQL. This abstraction is similar to the Table API both in semantics and expressiveness, but represents programs as SQL query expressions. The SQL abstraction closely interacts with the Table API, and SQL queries can be executed over tables defined in the Table API.</p>
  </li>
</ul>

<h1 id="ì°¸ê³ ">ì°¸ê³ </h1>
<ul>
  <li><a href="https://www.confluent.io/blog/apache-flink-apache-kafka-streams-comparison-guideline-users/" target="_blank">Flink and Kafka Streams: a Comparison and Guideline for Users</a></li>
  <li><a href="https://towardsdatascience.com/heres-how-flink-stores-your-state-7b37fbb60e1a" target="_blank">Kartik Khare, Hereâ€™s How Apache Flink Stores Your State data</a></li>
  <li><a href="https://stackoverflow.com/questions/31951978/storage-in-apache-flink" target="_blank">stackoverflow: Storage in Apache Flink</a></li>
</ul>
:ET