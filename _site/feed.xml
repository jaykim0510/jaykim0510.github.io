<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Code Museum</title>
        <description>Jay Tech personal blogging theme for Jekyll</description>
        <link>http://localhost:4000/</link>
        <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Fri, 19 Aug 2022 00:37:15 +0900</pubDate>
        <lastBuildDate>Fri, 19 Aug 2022 00:37:15 +0900</lastBuildDate>
        <generator>Jekyll v4.2.1</generator>
        
            <item>
                <title>AWS Series [Part9]: AWS Analytics Service: Kinesis</title>
                <description>&lt;hr /&gt;

&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#kinesis&quot; id=&quot;markdown-toc-kinesis&quot;&gt;Kinesis&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#kinesis-data-streams&quot; id=&quot;markdown-toc-kinesis-data-streams&quot;&gt;Kinesis Data Streams&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#kinesis-data-firehose&quot; id=&quot;markdown-toc-kinesis-data-firehose&quot;&gt;Kinesis Data Firehose&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#youtube&quot; id=&quot;markdown-toc-youtube&quot;&gt;Youtube&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;kinesis&quot;&gt;Kinesis&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;You can use Amazon Kinesis Data Streams to collect and process large streams of data records in real time&lt;/li&gt;
  &lt;li&gt;Apache Kafka와 같은 용도로 사용한다&lt;/li&gt;
  &lt;li&gt;Apache Kafka와 아키텍처까지 비슷한 서비스로는  Managed Streaming for Apache Kafka(MSK)가 있다&lt;/li&gt;
  &lt;li&gt;Kinesis가 MSK보다 조금 더 일찍 서비스로 제공되었기 때문에 아직까지는 MSK 보다 통합성이 좋지만 점차 MSK도 나아지는 중&lt;/li&gt;
  &lt;li&gt;Kinesis가 더 일찍 서비스되었기 때문에 실무에서는 MSK보다 Kinesis를 더 많이 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아래 영상은 Kinesis와 MSK의 특징과 차이를 자세히 설명해준다.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/9y-aCX5O3Ms&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h1 id=&quot;kinesis-data-streams&quot;&gt;Kinesis Data Streams&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Apache Kafka의 Broker와 비슷한 용도&lt;/li&gt;
  &lt;li&gt;아래 그림은 설정 화면을 캡처한 것인데 크게 설정할게 없는 것 같다.
&lt;img src=&quot;/images/kinesis_1.png&quot; alt=&quot;&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;중복없는 전송과 같은 설정은 script(python의 boto3 라이브러리)로 해결하거나 Source에서 해결해야 하는 것 같다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Kinesis Data Stream 서비스 자체에 Auto-scaling 설정 기능이 없다
    &lt;ul&gt;
      &lt;li&gt;Unlike some other AWS services, Kinesis does not provide a native auto-scaling solution like DynamoDB On-Demand or EC2 Auto Scaling. Therefore, there is a need for the right number of shards to be calculated for every stream based on the expected number of records and/or the size of the records&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;아래와 같은 방법이 하나의 솔루션이 된다 
&lt;img src=&quot;/images/kinesis_3.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;kinesis-data-firehose&quot;&gt;Kinesis Data Firehose&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Apache Kafka의 Connector와 비슷한 용도&lt;/li&gt;
  &lt;li&gt;Source로 설정가능한 값은 Kinesis Data Stream 또는 Direct PUT 뿐이다&lt;/li&gt;
  &lt;li&gt;Target으로 가능한 것은 S3, Redshift와 같은 것들이 있다&lt;/li&gt;
  &lt;li&gt;Source로 Direct PUT을 사용하면 Apache Kafka + Kinesis Firehose 조합도 가능할 것 같다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/kinesis_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;youtube&quot;&gt;Youtube&lt;/h1&gt;

&lt;p&gt;Kinesis Data Stream과 Kinesis Data Firehose의 Use case를 포함해 데이터 파이프라인에 관한 좋은 인사이트를 제공해준다.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/S3vdTBbQ2YM&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/&quot; target=&quot;_blank&quot;&gt;AWS docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.whizlabs.com/blog/aws-kinesis-data-streams-vs-aws-kinesis-data-firehose/&quot; target=&quot;_blank&quot;&gt;whizlabs, AWS Kinesis Data Streams vs AWS Kinesis Data Firehose&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=S3vdTBbQ2YM&amp;amp;list=LL&amp;amp;index=8&quot; target=&quot;_blank&quot;&gt;Youtube AWS Korea: AWS에서 데이터 분석을 시작하기 위한 실시간, 배치 데이터 수집 방법 알아보기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/slalom-data-ai/amazon-kinesis-data-streams-auto-scaling-the-number-of-shards-105dc967bed5&quot; target=&quot;_blank&quot;&gt;Brandon Stanley, Amazon Kinesis Data Streams: Auto-scaling the number of shards&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Thu, 11 Aug 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/aws-series9</link>
                <guid isPermaLink="true">http://localhost:4000/aws-series9</guid>
                
                <category>AWS</category>
                
                
                <category>Cloud</category>
                
            </item>
        
            <item>
                <title>AWS Series [Part8]: AWS [Database, Analytics] Service: Redshift</title>
                <description>&lt;hr /&gt;

&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introduction&quot; id=&quot;markdown-toc-introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#use-case&quot; id=&quot;markdown-toc-use-case&quot;&gt;Use Case&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#examples&quot; id=&quot;markdown-toc-examples&quot;&gt;Examples&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#클러스터-생성&quot; id=&quot;markdown-toc-클러스터-생성&quot;&gt;클러스터 생성&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#스키마-생성&quot; id=&quot;markdown-toc-스키마-생성&quot;&gt;스키마 생성&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#쿼리-및-분석&quot; id=&quot;markdown-toc-쿼리-및-분석&quot;&gt;쿼리 및 분석&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Amazon Redshift is a fully managed(setting up, operating, and scaling a data warehouse, provisioning capacity, monitoring and backing up the cluster), petabyte-scale data warehouse service in the cloud. You can start with just a few hundred gigabytes of data and scale to a petabyte or more. This enables you to use your data to acquire new insights for your business and customers.&lt;/p&gt;

&lt;p&gt;The first step to create a data warehouse is to launch a set of nodes, called an Amazon Redshift cluster. After you provision your cluster, you can upload your data set and then perform data analysis queries. Regardless of the size of the data set, Amazon Redshift offers fast query performance using the same SQL-based tools and business intelligence applications that you use today.&lt;/p&gt;

&lt;p&gt;Redshift is an OLAP-style (Online Analytical Processing) column-oriented database. It is based on PostgreSQL version 8.0.2. This means regular SQL queries can be used with Redshift. But this is not what separates it from other services. The fast delivery to queries made on a large database with exabytes of data is what helps Redshift stand out.&lt;/p&gt;

&lt;p&gt;Fast querying is made possible by Massively Parallel Processing design or MPP. The technology was developed by ParAccel. With MPP, a large number of computer processors work in parallel to deliver the required computations. Sometimes processors situated across multiple servers can be used to deliver a process.&lt;/p&gt;

&lt;h1 id=&quot;use-case&quot;&gt;Use Case&lt;/h1&gt;

&lt;p&gt;Amazon Redshift is used when the data to be analyzed is humongous. The data has to be at least of a petabyte-scale (1015 bytes) for Redshift to be a viable solution. The MPP technology used by Redshift can be leveraged only at that scale. Beyond the size of data, there are some specific use cases that warrant its use.&lt;/p&gt;

&lt;p&gt;(쿼리의 성능이 극대화됨 -&amp;gt; 대용량 데이터 or 실시간 분석에 적합 -&amp;gt; 그 외의 경우 요구사항 대비 지나친 성능으로 낭비가 될 수 있음)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;more than petabyte-scale&lt;/li&gt;
  &lt;li&gt;processing real-time analytics&lt;/li&gt;
  &lt;li&gt;combining multiple data sources&lt;/li&gt;
  &lt;li&gt;business intelligence&lt;/li&gt;
  &lt;li&gt;log analysis&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;examples&quot;&gt;Examples&lt;/h1&gt;

&lt;h2 id=&quot;클러스터-생성&quot;&gt;클러스터 생성&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;노드 유형, 개수는 작게 시작하는 것이 좋다 (Redshift는 비싸니까)&lt;/li&gt;
  &lt;li&gt;IAM 역할을 제대로 지정안하면 안됨 -&amp;gt; 나의 경우 Athena, Glue, S3의 FullAccess를 이용
    &lt;ul&gt;
      &lt;li&gt;처음에 RedshiftFullAccess도 추가해줬었는데 왜인지 모르겠지만 에러남&lt;/li&gt;
      &lt;li&gt;(왜 Redshift를 이용할 때 RedshiftFullAccess를 추가하면 에러가 날까)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/redshift_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스키마-생성&quot;&gt;스키마 생성&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Glue의 Catalog가 있으면 Redshift를 사용할 때도 정말 편하다&lt;/li&gt;
  &lt;li&gt;Catalog 없으면 [Create Schema] -&amp;gt; [Create Table] -&amp;gt; [Load Data] 해줘야됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/redshift_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;쿼리-및-분석&quot;&gt;쿼리 및 분석&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;MongoDB에서 저장할 때 requirements라는 속성을 array형태로 저장했었다&lt;/li&gt;
  &lt;li&gt;array가 있으면 쿼리시 에러가 난다 -&amp;gt; unnesting을 진행했다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/redshift_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/welcome.html&quot; target=&quot;_blank&quot;&gt;AWS docs, Redshift&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/redshift/latest/dg/query-super.html&quot; target=&quot;_blank&quot;&gt;AWS docs, Querying semistructured data&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cloudzero.com/blog/aws-redshift&quot; target=&quot;_blank&quot;&gt;CLOUDZERO, AWS Redshift 101: What Is It and When Should You Use It?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Thu, 11 Aug 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/aws-series8</link>
                <guid isPermaLink="true">http://localhost:4000/aws-series8</guid>
                
                <category>AWS</category>
                
                
                <category>Cloud</category>
                
            </item>
        
            <item>
                <title>AWS Series [Part7]: AWS Database Service: DynamoDB</title>
                <description>&lt;hr /&gt;

&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#what-is-dynamodb&quot; id=&quot;markdown-toc-what-is-dynamodb&quot;&gt;What is DynamoDB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#features-of-dynamodb&quot; id=&quot;markdown-toc-features-of-dynamodb&quot;&gt;Features of DynamoDB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#components-of-dynamodb&quot; id=&quot;markdown-toc-components-of-dynamodb&quot;&gt;Components of DynamoDB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#storing-data-in-dynamodb&quot; id=&quot;markdown-toc-storing-data-in-dynamodb&quot;&gt;Storing Data in DynamoDB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#querying-data-in-dynamodb&quot; id=&quot;markdown-toc-querying-data-in-dynamodb&quot;&gt;Querying Data in DynamoDB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#configuration-in-dynamodb&quot; id=&quot;markdown-toc-configuration-in-dynamodb&quot;&gt;Configuration in DynamoDB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pricing&quot; id=&quot;markdown-toc-pricing&quot;&gt;Pricing&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#dynamodb-provisioned-capacity&quot; id=&quot;markdown-toc-dynamodb-provisioned-capacity&quot;&gt;DynamoDB Provisioned Capacity&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#dynamodb-on-demand-pricing&quot; id=&quot;markdown-toc-dynamodb-on-demand-pricing&quot;&gt;DynamoDB On-demand Pricing&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;what-is-dynamodb&quot;&gt;What is DynamoDB&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo_00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Amazon DynamoDB is a cloud-native fully managed NoSQL primarily key-value database.&lt;/p&gt;

&lt;p&gt;DynamoDB’s NoSQL design is oriented towards simplicity and scalability, which appeal to developers and devops teams respectively. It can be used for a wide variety of semistructured data-driven applications prevalent in modern and emerging use cases beyond traditional databases, from the Internet of Things (IoT) to social apps or massive multiplayer games. With its broad programming language support, it is easy for developers to get started and to create very sophisticated applications using DynamoDB.&lt;/p&gt;

&lt;p&gt;While we cannot describe exactly what DynamoDB is, we can describe how you interact with it. When you set up DynamoDB on AWS, you do not provision specific servers or allocate set amounts of disk. Instead, you provision throughput — you define the database based on provisioned capacity — how many transactions and how many kilobytes of traffic you wish to support per second. Users specify a service level of read capacity units (RCUs) and write capacity units (WCUs).&lt;/p&gt;

&lt;p&gt;DynamoDB needed to “provide fast performance at any scale,” allowing developers to “start small with just the capacity they need and then increase the request capacity of a given table as their app grows in popularity.” Predictable performance was ensured by provisioning the database with guarantees of throughput, measured in “capacity units” of reads and writes. “Fast” was defined as single-digit milliseconds, based on data stored in Solid State Drives (SSDs).&lt;/p&gt;

&lt;p&gt;DynamoDB lets you offload the administrative burdens of operating and scaling a distributed database so that you don’t have to worry about hardware provisioning, setup and configuration, replication, software patching, or cluster scaling. DynamoDB also offers encryption at rest, which eliminates the operational burden and complexity involved in protecting sensitive data.&lt;/p&gt;

&lt;p&gt;You can scale up or scale down your tables’ throughput capacity without downtime or performance degradation. You can use the AWS Management Console to monitor resource utilization and performance metrics.&lt;/p&gt;

&lt;p&gt;DynamoDB allows you to delete expired items from tables automatically to help you reduce storage usage and the cost of storing data that is no longer relevant. For more information, see Expiring items by using DynamoDB Time to Live (TTL).&lt;/p&gt;

&lt;h1 id=&quot;features-of-dynamodb&quot;&gt;Features of DynamoDB&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;NoSQL primarily key-value (and document using JSON) database service&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Fully Managed Distributed Systems -&amp;gt; Stable Performance&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Managed&lt;/strong&gt; — provided ‘as-a-Service’ so users would not need to maintain the database&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Scalable&lt;/strong&gt; — automatically provision hardware on the backend, invisible to the user&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Durable&lt;/strong&gt; and highly available — multiple availability zones for failures/disaster recovery&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Integrates well with other AWS services&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Built-in support for ACID transactions&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Encryption at rest&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;On-demand backup&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Point-in-time recovery&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;components-of-dynamodb&quot;&gt;Components of DynamoDB&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Attribute&lt;/strong&gt;: &lt;strong&gt;single field&lt;/strong&gt; that is attached to an item. Key-value pair&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Item&lt;/strong&gt;: &lt;strong&gt;unique set of attributes&lt;/strong&gt; in a table. set of key-value pair&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Table&lt;/strong&gt;: &lt;strong&gt;group of items&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Primary Key&lt;/strong&gt;: The primary key &lt;strong&gt;uniquely identifies each item in the table&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;therefore, no two items can have the same key&lt;/li&gt;
      &lt;li&gt;primary key could be just &lt;strong&gt;partition key&lt;/strong&gt; or &lt;strong&gt;partition key + sort key&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Partiton Key&lt;/strong&gt;: key for determining physical storage in which the item will be stored
    &lt;ul&gt;
      &lt;li&gt;input to an internal hash function. the output from the hash function determines the partition&lt;/li&gt;
      &lt;li&gt;필수 지정값. primary key로 partition key만 지정되면 partition key는 고유한 값을 가져야함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Sort Key&lt;/strong&gt;: 동일한 파티션 키를 공유하는 모든 항목을 정렬하거나 검색하는데 이용 (선택 사항)
    &lt;ul&gt;
      &lt;li&gt;partition key + sort key -&amp;gt; Referred to as a composite primary key&lt;/li&gt;
      &lt;li&gt;All items with the same partition key value are stored together, in sorted order by sort key value.&lt;/li&gt;
      &lt;li&gt;In a table that has a partition key and a sort key, it’s possible for multiple items to have the same partition key value. However, those items must have different sort key values.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Secondary Indexes&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;You can create one or more secondary indexes on a table. A secondary index lets you query the data in the table using an alternate key, in addition to queries against the primary key. DynamoDB doesn’t require that you use indexes, but they give your applications more flexibility when querying your data. After you create a secondary index on a table, you can read data from the index in much the same way as you do from the table.&lt;/li&gt;
      &lt;li&gt;Global secondary index – An index with a partition key and sort key that can be different from those on the table.&lt;/li&gt;
      &lt;li&gt;Local secondary index – An index that has the same partition key as the table, but a different sort key.&lt;/li&gt;
      &lt;li&gt;In the example Music table shown previously, you can query data items by Artist (partition key) or by Artist and SongTitle (partition key and sort key). What if you also wanted to query the data by Genre and AlbumTitle? To do this, you could create an index on Genre and AlbumTitle, and then query the index in much the same way as you’d query the Music table.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;storing-data-in-dynamodb&quot;&gt;Storing Data in DynamoDB&lt;/h1&gt;

&lt;p&gt;A key-value store holds for each key a single value. Arguably, if the value can be an entire document, you can call this database a “document store”. In this sense, DynamoDB is a document store. The DynamoDB API lets you conveniently store a JSON document as the value, and also read or writes part of this document directly instead of reading or writing the entire document (although, you actually pay for reading and writing the entire document).&lt;/p&gt;

&lt;p&gt;보통은 Key-value store로 쓴다. Document store로 사용하고 싶은 경우 MongoDB의 AWS 버전인 DocumentDB를 쓰는 것을 추천한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DynamoDB is a “wide column” style of NoSQL database. While the schema isn’t defined beyond the primary key at table construction time, the querying abilities are limited to primary keys or secondary indexes. Creating Global Secondary Indexes allows you to query against other attribute values. Local Secondary Indexes can be queried too, but they’re a bit of an odd duck. See here for a good comparison of the two secondary index types.&lt;/p&gt;

&lt;p&gt;If your needs do include querying inside the attributes, check out some of the “document-oriented” style of NoSQL databases, of which MongoDB is the one most people think of. If you’re already embedded in the AWS ecosystem and don’t want to break out of it, AWS offers DocumentDB as a MongoDB-compatible service managed by AWS.&lt;/p&gt;

&lt;p&gt;Wide-column and document-style data stores have different pro’s &amp;amp; cons. Generally-speaking, the wide-column approach is better for extreme scalability at consistent cost &amp;amp; speed, whereas the document-oriented approach gives more flexibility as your data access patterns evolve over time. Choose the one that suits your needs the best.&lt;/p&gt;

&lt;h1 id=&quot;querying-data-in-dynamodb&quot;&gt;Querying Data in DynamoDB&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;PartiQL (SQL like)&lt;/li&gt;
  &lt;li&gt;Primary Key 또는 Global Secondary Indexes(GSI)에 대해서만 쿼리 가능&lt;/li&gt;
  &lt;li&gt;Filter는 쿼리 이후 결과를 제한하는 용도&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;configuration-in-dynamodb&quot;&gt;Configuration in DynamoDB&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 설정은 우선 기본 설정으로 테이블을 만든뒤 이후 설정값으르 수정할 수 도 있다.&lt;/p&gt;

&lt;p&gt;그 밖에 테이블 생성 이후 설정할 수 있는 설정값은 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;pricing&quot;&gt;Pricing&lt;/h1&gt;
&lt;p&gt;DynamoDB can be extremely expensive to use. There are two pricing structures to choose from: provisioned capacity and on-demand capacity.&lt;/p&gt;

&lt;h2 id=&quot;dynamodb-provisioned-capacity&quot;&gt;DynamoDB Provisioned Capacity&lt;/h2&gt;
&lt;p&gt;In this Amazon DynamoDB Pricing Plan, you’re billed hourly per the use of operational capacity units (or read and write capacity units). You can control costs by specifying the maximum amount of resources needed by each database table being managed. The provisioned capacity provides autoscaling and dynamically adapts to an increase in traffic. However, it does not implement autoscaling for sudden changes in data traffic unless that’s enabled.&lt;/p&gt;

&lt;p&gt;You should use provisioned capacity when:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You have an idea of the maximum workload your application will have&lt;/li&gt;
  &lt;li&gt;Your application’s traffic is consistent and does not require scaling (unless you enable the autoscaling feature, which costs more)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dynamodb-on-demand-pricing&quot;&gt;DynamoDB On-demand Pricing&lt;/h2&gt;
&lt;p&gt;This plan is billed per request units (or read and write request units). You’re only charged for the requests you make, making this a truly serverless choice. This choice can become expensive when handling large production workloads, though. The on-demand capacity method is perfect for autoscaling if you’re not sure how much traffic to expect.&lt;/p&gt;

&lt;p&gt;Knowing which capacity best suits your requirements is the first step in optimizing your costs with DynamoDB. Here are some factors to consider before making your choice.&lt;/p&gt;

&lt;p&gt;You should use on-demand capacity when:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You’re not sure about the workload your application will have&lt;/li&gt;
  &lt;li&gt;You don’t know how consistent your application’s data traffic will be&lt;/li&gt;
  &lt;li&gt;You only want to pay for what you use&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.scylladb.com/learn/dynamodb/introduction-to-dynamodb/&quot; target=&quot;_blank&quot;&gt;scylladb, Introduction to DynamoDB [추천]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=2k2GINpO308&amp;amp;list=LL&amp;amp;index=14&quot; target=&quot;_blank&quot;&gt;Youtube, Be A Better Dev: AWS DynamoDB Tutorial For Beginners&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html&quot; target=&quot;_blank&quot;&gt;AWS docs, Core components of Amazon DynamoDB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/67646412/how-is-it-possible-for-dynamodb-to-support-both-key-value-and-document-database&quot; target=&quot;_blank&quot;&gt;stackoverflow: How is it possible for DynamoDB to support both Key-Value and Document database properties at the same time&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/47521164/aws-dynamodb-query-based-on-non-primary-keys&quot; target=&quot;_blank&quot;&gt;stackoverflow: AWS DynamoDB Query based on non-primary keys&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cloudforecast.io/blog/dynamodb-pricing/&quot; target=&quot;_blank&quot;&gt;cloudforecast: DynamoDB Pricing and Cost Optimization Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Thu, 11 Aug 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/aws-series7</link>
                <guid isPermaLink="true">http://localhost:4000/aws-series7</guid>
                
                <category>AWS</category>
                
                
                <category>Cloud</category>
                
            </item>
        
            <item>
                <title>AWS Series [Part10]: AWS Analytics Service: Glue, Athena</title>
                <description>&lt;hr /&gt;

&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introduction&quot; id=&quot;markdown-toc-introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#aws-glue&quot; id=&quot;markdown-toc-aws-glue&quot;&gt;AWS Glue&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#aws-athena&quot; id=&quot;markdown-toc-aws-athena&quot;&gt;AWS Athena&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#s3--glue-catalog--athena--glue-etl-환상의-조합&quot; id=&quot;markdown-toc-s3--glue-catalog--athena--glue-etl-환상의-조합&quot;&gt;S3 + Glue Catalog + Athena + Glue ETL: 환상의 조합&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#glue-catalog&quot; id=&quot;markdown-toc-glue-catalog&quot;&gt;Glue Catalog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#glue-etl&quot; id=&quot;markdown-toc-glue-etl&quot;&gt;Glue ETL&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;데이터와 관련된 업무를 하다보면 실제로 데이터를 분석하고, 머신러닝과 같은 분야에 활용하는 시간은 약 30%, 나머지 시간은 수집, 적재, 변환과 같은 ETL 작업에 대부분의 시간을 할애하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/glue_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫 번째 문제(낮은 데이터 품질)를 해결하도록 도와주는 AWS 서비스에는 대표적으로 다음과 같은 것들이 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/glue_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;aws-glue&quot;&gt;AWS Glue&lt;/h1&gt;

&lt;p&gt;AWS Glue is a fully managed ETL service that makes it simple and cost-effective to categorize your data, clean it, enrich it, and move it reliably between various data stores and data streams.&lt;/p&gt;

&lt;p&gt;AWS Glue consists of a central metadata repository known as the AWS Glue Data Catalog, an ETL engine that automatically generates Python or Scala code, and a flexible scheduler that handles dependency resolution, job monitoring, and retries. AWS Glue is serverless, so there’s no infrastructure to set up or manage.&lt;/p&gt;

&lt;p&gt;No schema is required initially. With dynamic frames, you get schema flexibility and a set of advanced transformations specifically designed for dynamic frames. You can convert between dynamic frames and Spark dataframes, so that you can take advantage of both AWS Glue and Spark transformations to do the kinds of analysis that you want&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/glue_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;aws-athena&quot;&gt;AWS Athena&lt;/h1&gt;

&lt;p&gt;Amazon Athena is an interactive query service that makes it easy to analyze data directly in Amazon Simple Storage Service (Amazon S3) using standard SQL. With a few actions in the AWS Management Console, you can point Athena at your data stored in Amazon S3 and begin using standard SQL to run ad-hoc queries and get results in seconds.&lt;/p&gt;

&lt;p&gt;Athena is serverless, so there is no infrastructure to set up or manage, and you pay only for the queries you run. Athena scales automatically—running queries in parallel—so results are fast, even with large datasets and complex queries.&lt;/p&gt;

&lt;h1 id=&quot;s3--glue-catalog--athena--glue-etl-환상의-조합&quot;&gt;S3 + Glue Catalog + Athena + Glue ETL: 환상의 조합&lt;/h1&gt;

&lt;p&gt;데이터 웨어하우스로 가기 전 단계에 활용하기 좋은 것 같다. 보통 S3와 같은 데이터 레이크에는 raw-data가 많기 때문에 이러한 데이터를 클렌징하고, 가공하는 과정이 수반되어야 하는데 이러한 작업들을 AWS Glue가 해준다.&lt;/p&gt;

&lt;p&gt;또한 S3의 데이터를 다른 곳으로 옮기기 전에 먼저 데이터를 분석하고 싶은 경우가 많다. 어떤 데이터가 있고, 스키마가 어떻고, 어떤 데이터를 옮기면 좋을지, 어떤 데이터가 가치가 있을지를 먼저 S3에서 충분히 탐색해야 한다. 이러한 기능을 하는 것이 바로 AWS Athena이다. Athena를 이용하면 쿼리를 통해 S3의 데이터를 탐색/분석할 수 있다. 근데 Athena는 반드시 Data Catalog에서 쿼리를 진행한다. (카탈로그(Catalog): 데이터에 대한 하나의 단일화된 뷰)&lt;/p&gt;

&lt;p&gt;따라서 S3를 다른 데이터 웨어하우스로 옮기기 전에 먼저 Glue를 통해 데이터를 카탈로그화 하고, 그 카탈로그를 Athena를 이용해 분석하고 다시 Glue의 ETL 작업을 통해 클렌징, 가공해 데이터 웨어하우스로 옮겨주는 것이 데이터 파이프라인의 좋은 예이다.&lt;/p&gt;

&lt;p&gt;참고로 크롤러를 통해 카탈로그화 시킬 수 있는 데이터 소스는 S3뿐만 아니라 DynamoDB, DocumentDB, DataLake 등이 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/glue_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;glue-catalog&quot;&gt;Glue Catalog&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;크롤러를 주기적으로 실행시킴으로써 스키마 변경을 감지하고 관리해줌&lt;/li&gt;
  &lt;li&gt;스키마의 버전을 관리하고 해당 스키마에 맞는 일관된 데이터 뷰 제공(대표적으로 Athena, EMR, Redshift에 제공)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/glue_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;glue-etl&quot;&gt;Glue ETL&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;ETL 작업을 그래프로 시각화하여 쉽게 파이프라인을 만들 수 있음&lt;/li&gt;
  &lt;li&gt;스케줄링 기능도 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/glue_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(이상하게 S3에 저장하는 부분에서 데이터가 사라짐.. 실제로 S3에 저장은 되지만 크기가 0Byte..)&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/glue/latest/dg/what-is-glue.html&quot; target=&quot;_blank&quot;&gt;AWS docs, What is AWS Glue?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=LkkgtNtuEoU&amp;amp;list=LL&amp;amp;index=24&quot; target=&quot;_blank&quot;&gt;Youtube, AWS Korea: AWS Glue를 통한 손쉬운 데이터 전처리 작업하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=dQnRP6X8QAU&amp;amp;list=LL&amp;amp;index=17&quot; target=&quot;_blank&quot;&gt;Youtube, Johny Chivers: AWS Glue Tutorial for Beginners&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Thu, 11 Aug 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/aws-series10</link>
                <guid isPermaLink="true">http://localhost:4000/aws-series10</guid>
                
                <category>AWS</category>
                
                
                <category>Cloud</category>
                
            </item>
        
            <item>
                <title>Data Engineering Series [Part27]: Redis</title>
                <description>&lt;hr /&gt;

&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;in this article i’m going to be covering everything you need to know about redis. starting with what redis is moving on to how to install it all of the commands you need to know and then finally ending up with a real world example of how you would implement redis yourself. this is a really important video to watch because redis can be included in every single production level application and it’s going to make your application more performant. so let’s get started now.&lt;/p&gt;

&lt;p&gt;redis is essentially a type of database and more specifically it is a nosql database. but it’s not very similar to any other nosql databases. it’s definitely not similar to mongodb and it’s obviously very different than sql databases like postgres and mysql and this is because redis doesn’t really have any idea of tables or documents and instead all of the data in redis is
stored inside of key value pairs. so think about a json object you have the key name and you have the value kyle. this is essentially a key value pair and redis is just like one giant json object that has key value pairs and that’s all that you have inside of redis. so it’s not very good at storing a bunch of structured data like you have in sql .but it’s really good for storing you know individual key value pairs that you need to access or get data from another.&lt;/p&gt;

&lt;p&gt;important thing to note about redis is that unlike a normal database that runs on your disk and stores all your information on disk. redis actually runs inside of your working memory your ram on your computer and this means that redis is incredibly fast because it’s all working inside of ram. but it’s much more unstable because if all of a sudden your system crashes you’re going to lose everything that’s in redis unless you’re backing it up consistently, which is why redis is generally not used as like an actual persistent database store like you have with mongodb and postgres and instead it’s used more &lt;strong&gt;for caching&lt;/strong&gt; where you take things that are really you know things that you access a lot or things that take a long time to compute and you store those values inside of redis that way when you need to access them in the future. it’s incredibly quick since redis is in the memory already loaded. it’s milliseconds to get data as opposed to hundreds of milliseconds or even seconds of time to get data from a traditional database.&lt;/p&gt;

&lt;p&gt;really the important thing to realize about redis is that it’s going to be built on top of a traditional database. almost always you’re going to have your mongodb or postgres database in the background and you’re going to have redis sitting in front of that database and any time that you have a really long or slow query to your database or you have data you access all the time but doesn’t change that much what you’re going to do is you’re going to store that data inside of redis as well as inside your database. and then when you go to get that information if it’s already in redis you can access that data in milliseconds as opposed to going all the way to the database. computing the data and then coming all the way back which is going to take you hundreds to even thousands of milliseconds depending on how complex your data is. so redis is going to take your app and make it hundreds to even thousands of times faster when it comes to querying these pieces of information.&lt;/p&gt;

&lt;p&gt;let’s actually talk about how we can install redis. installing redis on your computer is really simple if you have a mac or linux computer. if you use mac just use homebrew to do the install and if you’re on linux just use your package manager of choice to install it. it’s just called redis it’s that simple. but if you’re on windows it’s a bit more complex. because there is no way to install redis on windows. instead you need to go through the windows subsystem for linux which is pretty simple to install.
so as you can see i am currently inside
of a linux terminal using the windows
subsystem for linux on my computer and
then all you need to do in order to
install this if you’re using ubuntu
is just say sudo apt get
install and then just type in redis and
then you need to type in your password
that you set up for your account and
it’s going to go through and install the
redis for me for you it’ll take a little
bit longer to download but i already
have it downloaded so it’s pretty quick
and then once you get it installed just
type in redis dash server
this is going to start up your redis
server and as you can see it just prints
out a bunch of information
and it says running in standalone mode
on port 6379 and that’s just the default
port for redis
so now redis is running on port 6379 so
in order to access redis we just need to
open up a new terminal and if you’re on
windows make sure you open up a windows
sub linux terminal here and then we can
just type in redis dash
cli and now we can actually access redis
and run commands kind of like you could
do a node with a cli
so for example one thing that we could
do inside of here is just type quit and
that exists
out of the cli obviously we want to be
in the cli though so the very first
thing we can do is add things to our
database
because like i said this is a key value
paired database so the main thing that
you’re going to do is setting a value
for a key
and getting a value for a key so we can
type in set
and it can be all uppercase all
lowercase it doesn’t matter generally
the
idea though is to use all capitals then
we’re just going to type in our key our
key is just going to be name and we’ll
put in a value of kyle
and then we hit enter and you can see it
said okay to check to see if this worked
we can type in git
and the name of our key which is just
name and as you can see we get the value
of kyle being returned back to us
and you’ll notice something about redis
is that pretty much everything you store
inside of redis is going to be a type of
string
by default so if we set for example age
equal to
26 and then we come here and we get our
age you’re going to notice it comes back
as this kind of string type
technically redis is smart enough to
know this is an integer but it really
doesn’t matter because when you’re
accessing and dealing with these things
they’re pretty much always going to come
back to you as strings when you’re
dealing with redis now with redis we can
also do a delete so i could say you know
delete age
and now if i do git age you can see it
returns to me null here
because there is no age at all because i
deleted that key so we can set keys we
can get keys and we can delete keys and
finally we can also just have this
command called
exists and this is just you type in a
key for example name whoops if i spell
name correctly
and you can see it returns to us one
saying that this is true and when i
typed name incorrectly it returns 0
which means false so you can determine
whether or not this key exists or not
so that’s kind of like the most basic
things that you can do inside of redis
for setting
getting deleting and checking if they
exist also what you can do is check to
find all the keys that match a certain
pattern so if you just put star this is
going to get you all the keys right now
we only have one key which is name
so that’s why it’s returning to us name
this is a great way just to see what’s
inside of your database
you can also get rid of everything in
your database by just typing flush
all hit enter and now we check our keys
you’re going to notice we have no keys
at all
and this is a really great way to just
clear everything out if you’re having
problems with your caching you can just
clear the entire cache
and now there’s nothing at all inside of
it but i can go back and i can say set
name kyle
and then i can get name and as you can
see it’s returning to me that name also
if you want to just clear out the input
just type the word clear that’s going to
clear everything out for you
and then a few additional things that i
really want to talk about is the idea of
expiration so if we just type in ttl and
then the key name which our case is name
this stands for time to live and as you
can see this time to live is negative
one
that just means it has no expiration at
all it’s going to live forever
but you can actually make keys so that
they expire at some point
i could for example type in expire and
then name and i want it to expire in 10
seconds
and now when i check the ttl for name
you can see that this is constantly
counting down
and once it gets all the way down to
zero it’s going to completely delete
this key so as you can see one
now we’re essentially negative two
negative two means it is gone now if we
do get
name you can see there is no longer
anything for this name key because we’d
expired it after 10 minutes
and if you want to make sure a key
expires when you set it you can use the
command
set ex and that’s going to give you a
key in our case name
we can give it how long we want it to
last let’s say 10 seconds and then the
value of kyle so it works just like set
but you can actually put the expiration
right here
and now when i ttl that name you can see
it’s constantly counting down from 10
and once it gets all the way down to
zero it’s going to delete that key
now that covers most of what you’re
going to be doing inside of redis since
you’re mostly going to be dealing with
strings
but red is also a support for handling
arrays in the form of
list and they also have hashes for kind
of storing like json objects
so let’s talk a list first in red is if
you want to add an item to a list
you’re going to say l push and this is
going to add an item to the start of
your list that’s what the l
stands for it stands for left or start
so we can give our list a name which is
our key let’s just say
friends and then we’re going to give
this thing a value that we’re pushing on
so let’s just push on
john here and now we have a key friends
that has
john inside of the array of it so we
could say git
friends and you’re going to notice it’s
saying hey this is the wrong type we
can’t get this and that’s because git
only works for strings if we want to
print out a list
we need to do instead is say l range
then we say
friends which is the key that we want to
get and then we say we start at index 1
and stop at index negative 1. that means
get all the items in the list
as you can see we get john being printed
out because that’s the only thing in the
list
let’s push another item to the left or
the start of our list
so we can say l push inside of friends
because that’s the name of our array
and we can say we want to push in sally
here as well and now if we get all the
values you can see sally got pushed to
the front
and then john got added on also with
these list you can push on the end or
the right hand side by using r push
it works the same way as l push but it’s
going to add it to the end of the array
so let’s put in here you know mic and if
we check this you can now see that mike
got put onto the end of the array you
can also take
items on and off of the array by using
something called l
pop and r pop they are going to be the
left and the right hand pop
so l pop you just type in friends and
it’s going to take the first item on the
left or the start of our array
take it off and return it to us so it
took sally away from the array returned
it to us
and now if we look at our array you can
see sally is gone if we do
our pop of friends and we now print out
our array you can see it got rid of mike
which was the last item in our array so
it took out the thing on the right hand
side a list like this is really useful
for any type of queue or stack that you
want to have like let’s say you have a
messaging app and you want to cache
the five most recent messages from a
user well you can constantly just
push on to the array so you could do
like an l push to push onto the top of
the array
and then you could do an r pop to remove
the last item that way you always make
sure you have five things in there and
it’s going to be the most recent five
and once you get a newer item it’s gonna
push off the oldest one and put this
newest one right on top of it that’d be
a great use case for this list type
the next thing i want to talk about is
sets and sets are very similar to list
because they’re like an array structure
but it’s a unique array if you know
anything about sets inside a javascript
which i’ll link up a video i’ve done on
them up in the top right in the cards
a set is essentially just a list that is
completely unique every value in the
list is unique
and it’s not put in particular order
like an array is so if you want to
create a set
you have to prefix everything with s so
we can say like s add
and then we can give it a key unless
we’ll say here that we have hobbies
and inside of here we’re going to pass
in a value this is very similar to like
pushing to an array but we’re adding to
this set
so let’s just push in here the hobby of
weight lifting
and you’ll notice i wrap this in quotes
if i have more than one word so now if i
want to get all the things inside of
here
we can say s members oops s
members and this is just going to print
out everything inside of that thing so
hobbies is the thing we want to check
and as you can see we got all the values
inside of hobbies being printed out and
like i said with sets it’s essentially
completely unique so if i try to add
weightlifting back in here again you can
see we got 0 being returned saying that
it was a false it could not add this
because it’s already there
and if we check you can see it didn’t
add it we only have just that one thing
inside there weightlifting
also with this we can do a remove so we
can just say
sram that stands for remove from hobbies
and we want to remove that value of
weight
lifting and now if we check our members
you can see that it’s an empty list
there’s nothing at all inside of it
now finally i want to talk about hashes
and hashes are just another key value
pair
so you can think of it as like a key
value pair inside of a key value pair
but with hashes you can’t have hashes
inside of hashes so it’s like a json
object but you can’t have any nesting at
all inside of it it’s just one set of
key value pairs
so to do anything with hashes you’re
going to prefix every command with an h
so if we want to set a value we could
say h set and let’s just say that we
want to have a person
the field we want to set as their name
and we want to give it the value of kyle
so now what we can do is we can say h
get and we want to get person and we
want to get the name from that person
and you can see it returns to us kyle
and if we wanted to get everything about
that person we could just use get all
type in person now you can see we have
the key name and the value of kyle so it
prints out the key first
and then the value second and we can add
other things so if we go back to each
set
we can instead set an age so let’s say
that we want to do an h set for our
person we want to set the age and we’re
going to set it to a value of 26.
now we do a get all you can see we have
a name of kyle and we have an age of
26 and we can get individual properties
so for example i could say you know get
just the name
or i could say just the age for that
person or we could do that get all again
and get all the different key value
pairs
you can also do an hdel which is going
to be a delete so let’s say that i
wanted to delete the age property
and now i printed everything out you can
see there’s only the name right here
and also i could do an exist so i could
say h exists
and i could say person and name and you
can see that returns true with the
integer of one
and age returns false with the integer
of zero so hashes are essentially a
great way if you need to store like key
value pairs inside of an individual key
but like i mentioned at the beginning
almost everything you’re going to be
doing inside of redis is going to be
dealing specifically with
string so you’re going to be doing like
sets and gits and expirations and that’s
like 95
of what you need to do inside of redis
so speaking of that let me show you a
real world example of how you would take
redis and implement it inside of the
back end of an application to speed it
up by about 10 to 50 times
so here i have a really simple express
node.js application with two different
endpoints
one is for getting all of the photos and
one is for getting an individual folder
and in each one of these endpoints all
that we do is we call out this json
placeholder api to get a list of photos
or we call it to get an individual photo
and here we also have the option to pass
in an album id
to just limit the size of the list and
this code you can just imagine this
right here could be anything it could be
calling a database
calling some other api this is just like
your main code that runs inside of your
server
and this is pretty slow code because
there’s a lot of data to fetch and it’s
calling out to an api which is always
going to be pretty slow
on the right hand side here we have my
own version of postman that i created
if you’re interested in learning how i
created this i have a whole video on it
linked up in the description for you
but if we just query out to http local
host 3000 which if we scroll down here
that is what this server is running on
and we go to slash
photos and i click send here you can see
down here we get our response which has
a ton of information inside of as you
can see there’s
essentially 35 000 lines of code inside
of here being returned
and it took about 370 milliseconds and
if i do a few more sends you can see
it’s around that ballpark of about 300
to 400 milliseconds
every time i make this request and if i
get an individual photo for example
photo one click send
you can see it’s quite a bit faster
because there’s a lot less data but it’s
still taking you know
almost 100 milliseconds for this to run
and this photos one is taking quite a
while like i said you know 300 to 400
milliseconds
now this three to four hundred
milliseconds isn’t like the end of the
world but you can imagine a query that
takes much longer maybe one
two three seconds to run and if you have
to wait for that every time you load
your web page
obviously that’s a terrible user
experience so instead what we’re gonna
do is use redis to cache this
information
so that way whenever we make a request
after it’s been cached we’re going to
get it directly from redis which is
going to be way
way quicker so let me just come in here
and we’re going to install redis
so i’m just going to open up a new tab
here i’m going to say npm
i redis just like that it’s going to go
through it’s going to install redis for
us let’s go back to where we were before
now we have our application running and
we can import redis so we can say const
redis is equal to requiring of redis
and now that we have redis here this is
actually going to be essentially like a
class
that we can use so we can get an
instance of redis so we can say that we
want to get our client
which is just saying redis dot create
client and instead of here we can just
pass it nothing and it’s going to use
all the default parameters
or you can pass it specifically a url so
if you’re going to push this up to
production you’re going to want to pass
in the url for your production instance
of redis but for our case we’re just
using the local host version that’s
running on the default port
so we can just leave this completely
blank and we actually have access now to
redis
so to make sure that redis is running i
have a windows terminal open up over
here for linux
i can just type in redis server and
that’s going to start up redis and if we
just expand this a little bit
you can see that it’s saying it started
up redis and it’s saying that it’s
accessible so let’s just minimize that
back down a little bit let’s start up
our server we’ll say run
dev start here just like that so our
server is running everything’s working
we have this redis client i’ll even just
rename this to redis client
now in order to use this redis client
you’re going to use it just like you
would use normal redis so if we come
down here we can say like red is client
dot set that’s going to allow us to set
or we can say set ex and that’s going to
allow us to set with an expiration time
every command i just taught you in redis
is going to be used on this redis client
here
so let’s do just a simple set with an
expiration and we’re going to say
for this we want to set something for
all of our photos so we’re going to set
it with a key of
photos like this and we want to set an
expiration let’s just say that we’re
going to create a default expiration up
here so we’re going to say const
default expiration is just going to be
like 3 600 seconds that’s essentially
the same as one hour so there’s our
default expiration
and our value for this is going to be
the value we get from right here so let
me just bring this down a little bit
and we can say that we want to store the
value of data inside of here
except for this data right here is an
array of values and inside of redis we
can only really store strings so we need
to make sure we json.stringify this
to convert this into a string to store
it inside of redis
now if we save this and we just send on
our page here what’s going to happen is
nothing new is going to happen you can
see it’s still taking you know quite a
while to do this command
but now we’re storing our information
inside of redis with this expiration
here
and we’re storing this data so what we
can do is we can essentially go over
open up a new
terminal tab here we can say redis cli
and we can just say
keys star and as you can see we have
that photos key right here which has the
value of
you know this 35 000 lines of json now
that’s really great
but right now we’re not actually getting
that information because every time we
run this we’re just getting the data and
saving it to redis
what i want to do instead is check does
redis have this information and if so
skip essentially all of this code right
here so we can say
redis client.get and what we want to do
is we want to get to something with the
id
or with the key here of photos and then
this is going to take in a callback that
has an error
and it also has our data in our case our
data is just all of our different
photos but they’re going to be as a
string so what we need to do is if we
have an
error then i just want to essentially
console
dot air out the air now the next thing i
want to do is check to see if we have
some photos
so if our photos is not equal to null
well then that means that we had some
data returned to us
so we can actually use that data to
return down to our user so we can
essentially just say here return
res.json and we want to json.parse
these photos because remember this is
returned to us as a string so if we have
photos already saved just return them
down to the user
otherwise what we want to do is we want
to get that data and we want to set it
so we want to take all the code that we
were doing every single time
and now we’re only going to run that
code to query the api and actually set
the data inside of
redis if we don’t already have it inside
of there and then obviously we’re going
to make sure we just json that
information down
now all that we’ve done inside of here
is we’ve wrapped everything inside of
this redis client git and if we’re able
to get information we return it
immediately
otherwise we go through we query our you
know database or api whatever it is
and then send the data down so now
what’s going to happen is when i click
send over here
you’re going to notice something
interesting it looks like when i click
send nothing works so if we come over
here you can see we have an error if i
scroll up
it’s just saying that this await keyword
is not able to be used and we need to be
inside an async function so let’s just
make sure this is an async function
right here
now if i save you can see we no longer
get any errors we click send
and you can see the time is now 63
milliseconds so we went from 400
milliseconds down to 60. we click send
again now we’re down you know 37
milliseconds it’s super super quick
and that’s because we’re just pulling
this directly from our redis cache
if i just put a simple console log
inside of here that says
cache it and i’m going to put another
console log inside of here that says
cache
miss so if we hit the cache and we got
it immediately it’s going to print out
cache hit otherwise if we didn’t we’re
going to print out cache miss
as you can see we’re hitting the cache
every single time that’s where this
cache hit is coming from
now if we come over to here whoops to
here where we have our cli open we just
say flush all
that’s going to clear out our entire
database we now no longer have
that key as you can see so if we go back
here we should see that when we first
search it’s going to give us cache miss
and of course it’s giving us an error
let’s see what this is
just saying data is not defined we have
data here data here
data here we just need to move this
inside the else there we go that should
fix that error
so now if we just make sure we clear
that back out again let’s just
whoops clear everything go back over to
here and now we click send
you’re going to see said cache missed
and it took 400 milliseconds so pretty
slow
we click send again it’s a cache hit and
now it only took 36 milliseconds that is
way way faster that’s 10 times faster
immediately right there and we click
send every single time it’s going to be
a cache hit now one problem with this
initial setup though is it doesn’t work
with this album id if i add in a query
param for our album id and let’s just
say we do album id of
2 and i click send you can see i still
get all the albums with id1
the album’s id 87 and so on and that’s
because it’s still hitting this cache of
photos
we need to make sure that our cache key
takes into account everything that could
change so for example if the album id
changes
we want this key here to change so what
i would like to do here is essentially
just add in
our album id and we’re going to put the
value of that album
id onto the end of our key so now our
key is for any photo that has an album
id
or doesn’t have an album id the only
other thing we have left to do is make
sure we use the same key down here
where we’re actually setting our redis
key so now if we save this
and we test this if we have an album id
of two click send you can see we get
only the things that the album id of two
it took about 127 milliseconds
click send again now it took six
milliseconds i mean that’s way way way
faster that’s like 20 30 times faster
if we do an album id of three click send
it takes a long time the first time but
every other time is incredibly quick
and if we have no album id click send it
takes a while and then every other call
after that is pretty quick and we can
actually check that by coming over here
and just saying keys star you can see
that we have a key for just photos which
is just from before our database we
didn’t flush it properly
we have it for when the album ideas
three when the album id is two and then
we don’t have any album id at all
so this is essentially all the different
things being cached inside of our
database
this is really great now all we have to
do is add caching down here to this
section of our application
but you’ll notice when we do this that
logic is almost identical to what we’ve
done up inside of here
so i want to extract this out into a
function i can reuse everywhere that’s
going to do the caching for me so what i
want to do is just come down all the way
here and we’re going to create a
function
and we’re going to call this git or set
cache
and it’s going to take in a key and it’s
going to take in a callback
and the callback is what we’re going to
call to actually get the value for our
cache
so instead of here the first thing i
want to do is turn this into a promise
because it’s much easier to work with
promises
so we’re going to return a new promise
that has a resolve
whoops resolve and a reject insider here
and then we’re going to use that redis
client and we’re going to see if we can
get a key so we’re going to try to get
to that key
and if we can’t get that key we’re going
to have here an error
and our data and then what i want to do
inside of here is if we have an error
then i obviously just want to reject
that error and return so we don’t do
anything else at all
then i want to see if our data is not
equal to null that means we have some
data
so i want to resolve that data and i
want to make sure i convert it back
into json so we’re going to json parse
this data since we’re constantly
converting everything to a string to
store it inside of our database
now if neither of these are true then
that means that we don’t have data
essentially we missed our cache
and what i want to do is i want to get
fresh data this either means that we
haven’t queried this page yet or
it expired after this default expiration
here essentially it’s just not in our
cache
so we’re going to call that callback but
the important thing is this callback is
going to be asynchronous
so we’re going to make sure that we
await this callback and make sure that
this here is an async function
just like that now we’re going to have
our fresh data and what i want to do is
i want to take my redis client and i
want to set that fresh data so we can
use set exe
for our key we’re going to use that
default expiration and we’re going to
store in here our brand new fresh data
so now we’re saving that inside of our
cache
so next time we can take this shortcut
and not have to worry about calling this
long running callback
and then what i want to do is just
resolve that fresh
data and it’s important here that this
fresh data i convert this to a string
before i store it since redis can’t
really handle
something that’s not a string so now we
have this handy dandy function called
get or set cache it just takes in a key
and a callback that we call if for some
reason it doesn’t work so way up here
what we can do is we can say get or set
cache
this is going to return to us
essentially some photos
it’s going to be equal to that and this
is a promise so we need to make sure
that we await that
and in here we’re going to pass it our
key which we can just copy from right
here
and then we need to pass it our callback
and the callback is
really super straightforward it’s just
this callback down here where we’re
going to be getting our data
so we’re getting our data and then we
need to return that data our callback is
just
how do we get the information we want to
store in the cache and this is how we
get it and let’s just make sure we
return it down here
so now i can take all this code that we
wrote right here completely get rid of
it
and down here i can just say res.json
and send back our photos
since that’s what we called this
variable right up here so now if i save
this let’s see if this still works
obviously we have an error saying that a
weight is only valid in an async
function
let’s just make sure this is an async
function here now we have no more errors
i want to go over real quickly and just
flush everything from our database so we
have a completely fresh
redis to work with and let’s click send
here and you’re going to notice it takes
about 427 milliseconds
but the next time it only takes 39 it’s
storing that in the cache
if we add in the album id we add an
album id of two for example
click send you can see 80 milliseconds
the first time and five the second time
so quite a bit faster
we can try the same thing with three and
you can see again it down to four
milliseconds and if we check our keys
over here
you can see we have those three
different keys for undefined two and
three so now i want to essentially do
the exact same thing i want to take this
code and i’ll make it work down here
so let’s just copy what we have right
here we’re gonna paste it down inside of
here
and instead our data is going to be got
by this query right here where we’re
just querying the api with this
particular id so we’re just replacing
how we get our data with the data that
was right inside of here
and then we’re going to change our key
because our key is not going to be based
on an album id
it’s going to be based on an id so a lot
of times in redis when you’re working
with
namespaces or with data that has you
know multiple ids or multiple entries
you just have the namespace followed by
a colon and then you can put in for
example the id which in our case is
request.params.id
so what this is saying is hey we have
some photos namespace and we’re going to
get an id’d value from it
this is just a naming convention you can
use whatever you want you could put a
hyphen in here you could put an
underscore you could put nothing at all
it just is a nice thing to have here so
that we can easily say this is a photo
and the photo has you know an id of one
for example
this is going to return to us a single
photo which we’re going to return as our
data down here
so now with that done we should
hopefully build a query something like
photos
slash one click send the first time it
took 126 milliseconds
and the next time it took six
milliseconds let’s get photos three
you can see the first time it was slow
and the second time it’s much faster
every other time after that is going to
be very very fast
and if we check our keys you can see we
have a key for photos colon one
and photos colon three which are the two
different ids that we checked for and
that is everything you need to know to
get started with
redis if you enjoyed that video and want
to figure out how i made that postman
clone
just click over here for that and also
subscribe to the channel for more videos
just like this
thank you very much for watching and
have a good day&lt;/p&gt;
</description>
                <pubDate>Tue, 02 Aug 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/data-engineering-series27</link>
                <guid isPermaLink="true">http://localhost:4000/data-engineering-series27</guid>
                
                <category>Data_Engineering</category>
                
                
                <category>DE</category>
                
            </item>
        
            <item>
                <title>Data Engineering Series [Part26]: I 🤍 Logs(2) Data Integration</title>
                <description>&lt;hr /&gt;

&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introduction&quot; id=&quot;markdown-toc-introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#two-complications&quot; id=&quot;markdown-toc-two-complications&quot;&gt;Two Complications&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#data-is-more-diverse&quot; id=&quot;markdown-toc-data-is-more-diverse&quot;&gt;Data is More Diverse&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#the-explosion-of-specialized-data-systems&quot; id=&quot;markdown-toc-the-explosion-of-specialized-data-systems&quot;&gt;The Explosion of Specialized Data Systems&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#log-structured-data-flow&quot; id=&quot;markdown-toc-log-structured-data-flow&quot;&gt;Log-Structured Data Flow&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#experience-at-linkedin&quot; id=&quot;markdown-toc-experience-at-linkedin&quot;&gt;Experience at LinkedIn&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#relationship-to-etl-and-data-warehouse&quot; id=&quot;markdown-toc-relationship-to-etl-and-data-warehouse&quot;&gt;Relationship to ETL and Data Warehouse&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#etl-and-scalability&quot; id=&quot;markdown-toc-etl-and-scalability&quot;&gt;ETL and Scalability&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#where-should-we-put-the-data-transformations&quot; id=&quot;markdown-toc-where-should-we-put-the-data-transformations&quot;&gt;Where Should We Put the Data Transformations?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#decoupling-systems&quot; id=&quot;markdown-toc-decoupling-systems&quot;&gt;Decoupling Systems&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#scaling-a-log&quot; id=&quot;markdown-toc-scaling-a-log&quot;&gt;Scaling a Log&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Data Integration and Logs&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Data Integration means making available all the data (that an organization has) to all the services and systems that need it&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The more recognizable term ETL(populating a relational data warehouse) usually covers only a limited part of data integration.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Capturing all the relevant data and being able to put it together in an applicable processing environment&lt;/li&gt;
  &lt;li&gt;This data has to be modeled in a uniform way to make it easy to read and process&lt;/li&gt;
  &lt;li&gt;Process this data in various ways: MapReduce, real-time query systems, ans so on&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Focus on step-by-step&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Reliable and complete data flow&lt;/li&gt;
  &lt;li&gt;Refining data modeling and consistency&lt;/li&gt;
  &lt;li&gt;Better visualization, reporting, algorithmic processing and prediction&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;How can we build reliable data flow throughout all the data systems?&lt;/p&gt;

&lt;h1 id=&quot;two-complications&quot;&gt;Two Complications&lt;/h1&gt;

&lt;p&gt;Two things have made data integration an increasingly difficult proflem.&lt;/p&gt;

&lt;h2 id=&quot;data-is-more-diverse&quot;&gt;Data is More Diverse&lt;/h2&gt;

&lt;p&gt;Transactional data - things that &lt;strong&gt;are&lt;/strong&gt;,  Event data - things that &lt;strong&gt;happen&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Log = Data structure what event data is logged&lt;/p&gt;

&lt;p&gt;Event data is generated from Web service, Financial organization, IoT&lt;/p&gt;

&lt;p&gt;This type of event data shakes up traditional data integration approaches because it tends to be several orders of magnitude larger than transactional data.&lt;/p&gt;

&lt;h2 id=&quot;the-explosion-of-specialized-data-systems&quot;&gt;The Explosion of Specialized Data Systems&lt;/h2&gt;

&lt;p&gt;ex. OLAP, Search service, Batch processing, Graph analysis&lt;/p&gt;

&lt;h1 id=&quot;log-structured-data-flow&quot;&gt;Log-Structured Data Flow&lt;/h1&gt;

&lt;p&gt;Log is the natural problem data structure for handling data flow between systems.&lt;/p&gt;

&lt;h1 id=&quot;experience-at-linkedin&quot;&gt;Experience at LinkedIn&lt;/h1&gt;

&lt;h1 id=&quot;relationship-to-etl-and-data-warehouse&quot;&gt;Relationship to ETL and Data Warehouse&lt;/h1&gt;

&lt;h1 id=&quot;etl-and-scalability&quot;&gt;ETL and Scalability&lt;/h1&gt;

&lt;h1 id=&quot;where-should-we-put-the-data-transformations&quot;&gt;Where Should We Put the Data Transformations?&lt;/h1&gt;

&lt;h1 id=&quot;decoupling-systems&quot;&gt;Decoupling Systems&lt;/h1&gt;

&lt;h1 id=&quot;scaling-a-log&quot;&gt;Scaling a Log&lt;/h1&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewEng.laf?barcode=9781491909386&amp;amp;ejkGb=BNT&amp;amp;mallGb=ENG&quot; target=&quot;_blank&quot;&gt;책 I Heart Logs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/logika-io/try-kill-batch-processing-with-unified-log-stream-processing-d92709117f74&quot; target=&quot;_blank&quot;&gt;Try Kill batch processing with unified log stream processing…&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Mon, 01 Aug 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/data-engineering-series26</link>
                <guid isPermaLink="true">http://localhost:4000/data-engineering-series26</guid>
                
                <category>Data_Engineering</category>
                
                
                <category>DE</category>
                
            </item>
        
            <item>
                <title>Data Engineering Series [Part25]: I 🤍 Logs(1) Introduction</title>
                <description>&lt;hr /&gt;

&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#what-is-a-log&quot; id=&quot;markdown-toc-what-is-a-log&quot;&gt;What Is a Log?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#logs-in-database&quot; id=&quot;markdown-toc-logs-in-database&quot;&gt;Logs in Database&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#logs-in-distributed-system&quot; id=&quot;markdown-toc-logs-in-distributed-system&quot;&gt;Logs in Distributed System&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#log-centric-design-pattern&quot; id=&quot;markdown-toc-log-centric-design-pattern&quot;&gt;Log-Centric Design Pattern&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;what-is-a-log&quot;&gt;What Is a Log?&lt;/h1&gt;

&lt;p&gt;Yet other than perhaps occasionally tailing a log file, most engineers don’t think much about logs. To help remedy that, I’ll give an overview of how logs work in distributed systems, and then give some practical applications of these concepts to a variety of common uses: data integration, enterprise architecture, real-time data processing, and data system design.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[2022-07-02 05:30:44] method=POST user=crazyboy0510 path=/movies/comment-create/ movie_id=16
[2022-07-02 05:30:57] method=GET user=crazyboy0510 path=/movies/movie-play/7 movie_id=7
[2022-07-02 05:31:15] method=GET user=crazyboy0510 path=/movies/movie-play/16 movie_id=16
[2022-07-02 05:31:18] method=GET user=crazyboy0510 path=/movies/movie-play/7 movie_id=7
[2022-07-02 05:31:19] method=GET user=crazyboy0510 path=/movies/movie-play/7 movie_id=7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Every programmer is familiar with this kind of log - a series of loosely structured requests, errors, or other messages in a sequence of rotating text files.&lt;/p&gt;

&lt;p&gt;The purpose of logs quickly becomes an input to queries in order to understand behavior across many machines, something that English text in files is not nearly as appropriate for as the kind of structured log I’ll be talking about.&lt;/p&gt;

&lt;p&gt;The log I’ll be discussing is a little more general and closer to what in the database or systems called a ‘commit log’. It is append-only sequence of records ordered by time.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/logs_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Each rectangle represents a record that was appended to the log. Records are stored in the order they were appended. The contents and format of the records aren’t important for the purposes of this discussion. To be concrete, we can just imagine each record to be a JSON blob.&lt;/p&gt;

&lt;p&gt;The log entry number can be thought of as the ‘timestamp’ of the entry. this is convenient property of being decoupled from any particular physical clock. This property is essential as we get to distributed systems.&lt;/p&gt;

&lt;p&gt;A log is just kind of table or file where the records are sorted by time&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;table: array of records  
file: array of bytes  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However it is important that we thing about the log as an &lt;strong&gt;abstract data structure, not a text file&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Logs have a specific purpose: &lt;strong&gt;they record what happened and when&lt;/strong&gt;. For distributed data systems, this is the heart of the problem.&lt;/p&gt;

&lt;h1 id=&quot;logs-in-database&quot;&gt;Logs in Database&lt;/h1&gt;

&lt;p&gt;The usage in databases has to do with keeping in sync a variety of data structures and indexes in the presence of crashes. To make this atomic and durable, a database uses a log to write out information about the records it will be modifying before applying the changes to all the various data structures that it maintains.&lt;/p&gt;

&lt;p&gt;The log is the record of what happened, and each table or index is a projection of this history into some useful data structure or index.&lt;/p&gt;

&lt;p&gt;Over time, the usage of the log grew from &lt;strong&gt;an implementation detail of the ACID database properties&lt;/strong&gt; to a &lt;strong&gt;method for replicating data between databases&lt;/strong&gt;. It turns out that the sequence of changes that happened on the database is exactly what is needed to keep a remote replica database in sync. Oracle, MySQL, PostreSQL, and MongoDB include log shipping protocols to transmit portions of a log to replica databases that act as slaves. The slaves can then apply the changes recorded in the log to their own local data structures to stay in sync with the master.&lt;/p&gt;

&lt;p&gt;In fact, the use of logs is variations on the two uses in database internals:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The log is used as a publish/subscribe mechanism to transmit data to other replicas&lt;/li&gt;
  &lt;li&gt;The log is used as a consistency mechanism to order the updates that are applied to multiple replicas&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;logs-in-distributed-system&quot;&gt;Logs in Distributed System&lt;/h1&gt;

&lt;p&gt;The same problems that databases solve with logs (like distributing data to replicas and agreeing on update order) are among the most fundamental problems for all distributed systems.&lt;/p&gt;

&lt;p&gt;The log-centric approach to distributed systems arises from a simple observation&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If two identical, deterministic processes begin in the same state and get the same inputs in the same order, they will produce the same output and end in the same state&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(Desterministic means that the processing isn’t timing dependent)&lt;/p&gt;

&lt;p&gt;The application to distributed computing is pretty obvious. You can reduce the problem of making multiple machines all do the same thing to the problem of implementaing a consistent log to feed input to theses processes. The purpose of the log here is to squeeze all the nondeterminism out of the input stream to ensure that each replica stays in sync.&lt;/p&gt;

&lt;p&gt;Discrete log entry numbers act as a clock for the state of the replicas - you can describe the state of each replica by a single number: the timestamp for the maximum log entry that it has processed. Two replicas at the same time will be in the same state.&lt;/p&gt;

&lt;h2 id=&quot;log-centric-design-pattern&quot;&gt;Log-Centric Design Pattern&lt;/h2&gt;

&lt;p&gt;There are many variations on how this principle can be applied., depending on what is put in the log. For example, we can log the incoming requests to a service and have each replica process these independently. Or we can have one instance that processed requests and log the state changes that the service undergoes in response to a request.&lt;/p&gt;

&lt;p&gt;Database people generally differentiate between physical and logical logging. Physical or row-based logging means logging the contents of each row that is changed (로우별 실제 변경된 데이터를 저장하는 것). Logical or statement logging  means logging the SQL commands that lead to the row changes (insert, update, and delete statements).&lt;/p&gt;

&lt;p&gt;The distributed systems distinguished two broad approaches to processing and replication. The &lt;strong&gt;state machine model&lt;/strong&gt; keep a log of the incoming requests and &lt;strong&gt;each replica processes each request&lt;/strong&gt; in log order. &lt;strong&gt;primary backup&lt;/strong&gt; elect one replica as the leader. This leader processes requests in the order they arrive and logs the changes to its state that occur as a result of processing the requests.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/logs_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
                <pubDate>Mon, 01 Aug 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/data-engineering-series25</link>
                <guid isPermaLink="true">http://localhost:4000/data-engineering-series25</guid>
                
                <category>Data_Engineering</category>
                
                
                <category>DE</category>
                
            </item>
        
            <item>
                <title>Coding Test Series [Part22]: 행렬(Matrix) - 문제</title>
                <description>&lt;hr /&gt;

&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#matrix&quot; id=&quot;markdown-toc-matrix&quot;&gt;Matrix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;matrix&quot;&gt;Matrix&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/tag/matrix/&quot; target=&quot;_blank&quot;&gt;Leetcode: Two-Pointers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;💟 ✅ ❎&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;문제 리스트
---------------------------------------------EASY 3문제
- Richest Customer Wealth
- Flipping an Image
- Matrix Diagonal Sum
- The K Weakest Rows in a Matrix
- Toeplitz Matrix
- Shift 2D Grid
- Transpose Matrix

---------------------------------------------MEDIUM 5문제
- Sort the Matrix Diagonally
- Remove All Ones With Row and Column Flips
- Candy Crush
- Max Area of Island
- Rotate Image
- Sparse Matrix Multiplication
- Game of Life
- Construct Quad Tree
- Spiral Matrix II
- Walls and Gates
- Number of Islands
- Rotting Oranges
- Shortest Path in Binary Matrix
- Word Search
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
                <pubDate>Mon, 01 Aug 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/matrix</link>
                <guid isPermaLink="true">http://localhost:4000/matrix</guid>
                
                <category>Coding_Test</category>
                
                
                <category>CS</category>
                
            </item>
        
            <item>
                <title>MySQL Series [Part15] IntelliJ IDE를 이용한 데이터베이스 시각화</title>
                <description>&lt;hr /&gt;
&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jetbrains.com/help/idea/creating-diagrams.html&quot; target=&quot;_blank&quot;&gt;IntelliJ: Database diagrams&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Fri, 29 Jul 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/mysql-series15</link>
                <guid isPermaLink="true">http://localhost:4000/mysql-series15</guid>
                
                <category>MySQL</category>
                
                
                <category>DE</category>
                
            </item>
        
            <item>
                <title>MySQL Series [Part14] MySQL Optimizing SELECT Statements</title>
                <description>&lt;hr /&gt;
&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#optimization-overview&quot; id=&quot;markdown-toc-optimization-overview&quot;&gt;Optimization Overview&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#things-to-consider-for-optimization&quot; id=&quot;markdown-toc-things-to-consider-for-optimization&quot;&gt;Things to Consider for Optimization&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#select&quot; id=&quot;markdown-toc-select&quot;&gt;SELECT&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#where&quot; id=&quot;markdown-toc-where&quot;&gt;WHERE&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#group-by&quot; id=&quot;markdown-toc-group-by&quot;&gt;GROUP BY&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#join&quot; id=&quot;markdown-toc-join&quot;&gt;JOIN&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#subquery&quot; id=&quot;markdown-toc-subquery&quot;&gt;Subquery&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#temporary-table&quot; id=&quot;markdown-toc-temporary-table&quot;&gt;Temporary Table&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#order-by&quot; id=&quot;markdown-toc-order-by&quot;&gt;ORDER BY&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#정렬-처리-방법&quot; id=&quot;markdown-toc-정렬-처리-방법&quot;&gt;정렬 처리 방법&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;optimization-overview&quot;&gt;Optimization Overview&lt;/h1&gt;

&lt;p&gt;Database performance depends on several factors at the database level, such as tables, queries, and configuration settings. These software constructs result in CPU and I/O operations at the hardware level, which you must minimize and make as efficient as possible.&lt;/p&gt;

&lt;h1 id=&quot;things-to-consider-for-optimization&quot;&gt;Things to Consider for Optimization&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Are the tables structured properly? In particular, do the columns have the right data types, and does each table have the appropriate columns for the type of work? For example, applications that perform frequent updates often have many tables with few columns, while applications that analyze large amounts of data often have few tables with many columns.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are the right indexes in place to make queries efficient?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are you using the appropriate storage engine for each table, and taking advantage of the strengths and features of each storage engine you use? In particular, the choice of a transactional storage engine such as InnoDB or a nontransactional one such as MyISAM can be very important for performance and scalability.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Does each table use an appropriate row format? This choice also depends on the storage engine used for the table. In particular, compressed tables use less disk space and so require less disk I/O to read and write the data. Compression is available for all kinds of workloads with InnoDB tables, and for read-only MyISAM tables.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Does the application use an appropriate locking strategy? For example, by allowing shared access when possible so that database operations can run concurrently, and requesting exclusive access when appropriate so that critical operations get top priority. Again, the choice of storage engine is significant. The InnoDB storage engine handles most locking issues without involvement from you, allowing for better concurrency in the database and reducing the amount of experimentation and tuning for your code.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are all memory areas used for caching sized correctly? That is, large enough to hold frequently accessed data, but not so large that they overload physical memory and cause paging. The main memory areas to configure are the InnoDB buffer pool and the MyISAM key cache.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;select&quot;&gt;SELECT&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Avoid using *&lt;/li&gt;
  &lt;li&gt;Avoid using DISTINCT -&amp;gt; 중복 데이터 제거를 위해 테이블 풀 스캔 해야함&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;where&quot;&gt;WHERE&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Use Indexes Where Appropriate&lt;/li&gt;
  &lt;li&gt;Avoid % Wildcard in a Predicate&lt;/li&gt;
  &lt;li&gt;Avoid using a function in the predicate of a query&lt;/li&gt;
  &lt;li&gt;BETWEEN, IN, &amp;lt;, &amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;group-by&quot;&gt;GROUP BY&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;GROUP BY 작업은 크게 인덱스를 사용하는 경우와 사용할 수 없는 경우(임시 테이블을 사용)&lt;/li&gt;
  &lt;li&gt;인덱스를 사용할 수 없는 경우, 전체 테이블을 스캔하여 각 그룹의 모든 행이 연속되는 새 임시 테이블을 만든 다음 이 임시 테이블을 사용하여 그룹을 검색하고 집계 함수를 적용하는 것
    &lt;ul&gt;
      &lt;li&gt;이렇게 인덱스를 사용할 수 없을 때 할 수 있는 최선의 방법은 WHERE절을 이용해 GROUP BY 하기 전에 데이터량을 줄이는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인덱스를 잘 설정한다면 임시 테이블을 생성하지 않고 빠르게 데이터를 가져올 수 있다
    &lt;ul&gt;
      &lt;li&gt;인덱스를 최대로 활용하기 위해서는 GROUP BY 컬럼과, 인덱스되어 있는 컬럼간의 순서가 중요함&lt;/li&gt;
      &lt;li&gt;SELECT절에 사용되는 집계함수의 경우 MIN(), MAX()는 인덱스의 성능을 최대로 활용할 수 있도록 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;참고로 MySQL 8.0부터는 GROUP BY를 한다고 해서 암묵적으로 정렬이 이루어지지 않음 -&amp;gt; 정렬 필요하면 명시적으로 ORDER BY 써야함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;루스 인덱스 스캔을 사용할 수 있는 경우
    &lt;ul&gt;
      &lt;li&gt;루스 인덱스 스캔은 레코드를 건너뛰면서 필요한 부분만 가져오는 스캔 방식&lt;/li&gt;
      &lt;li&gt;EXPLAIN을 통헤 실행 계획을 확인해보면 Extra 컬럼에 ‘Using index for group-by’ 라고 표기됨&lt;/li&gt;
      &lt;li&gt;MIN(), MAX() 이외의 함수가 SELECT 절에 사용되면 루스 인덱스 스캔을 사용할 수 없음&lt;/li&gt;
      &lt;li&gt;인덱스가 (col1 col2, col3) 일 때 , GROUP BY col1, col2 과 같아야 함 (GROUP BY col2, col3은 안됨)&lt;/li&gt;
      &lt;li&gt;SELECT 절과 GROUP BY 절의 컬럼이 일치해야 함. SELECT col1, col2, MAX(col3) GROUP BY col1, col2 과 같아야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;타이트 인덱스 스캔을 사용하는 경우
    &lt;ul&gt;
      &lt;li&gt;SELECT 절과 GROUP BY 절의 컬럼이 일치하지 않지만, 조건절을 이용해 범위 스캔이 가능한 경우
        &lt;ul&gt;
          &lt;li&gt;SELECT c1, c2, c3 FROM t1 WHERE c2 = ‘a’ GROUP BY c1, c3;&lt;/li&gt;
          &lt;li&gt;SELECT c1, c2, c3 FROM t1 WHERE c1 = ‘a’ GROUP BY c2, c3;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;join&quot;&gt;JOIN&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;INNER joins, order doesn’t matter&lt;/li&gt;
  &lt;li&gt;OUTER joins, the order matters&lt;/li&gt;
  &lt;li&gt;여러 조인을 포함하는 LOOP JOIN 에서는 드라이빙 테이블(Driving Table)이 행들을 최소한으로 리턴하도록 해야됨&lt;/li&gt;
  &lt;li&gt;JOIN 되는 컬럼의 한쪽에만 INDEX가 있는 경우는 INDEX가 지정된 TABLE이 DRIVING TABLE이 된다&lt;/li&gt;
  &lt;li&gt;JOIN 시 자주 사용하는 칼럼은 인덱스로 등록한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인덱스 레인지 스캔은 인덱스를 탐색(Index Seek)하는 단계와 인덱스를 스캔(Index Scan)하는 과정으로 구분해 볼 수 있다. 일반적으로 인덱스를 이용해서 쿼리하는 작업에서는 가져오는 레코드의 건수가 소량(전체 데이터 크기의 20% 이내)이기 때문에 인덱스 스캔 작업은 부하가 작고, 특정 인덱스 키를 찾는 인덱스 탐색 작업이 부하가 높은 편이다.&lt;/p&gt;

&lt;p&gt;JOIN 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행하고, 그 이후부터는 스캔만 실행하면 된다.&lt;/p&gt;

&lt;p&gt;하지만 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복한다.&lt;/p&gt;

&lt;p&gt;드라이빙 테이블과 드리븐 테이블이 1:1 조인되더라도 &lt;strong&gt;드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;그래서 옵티마이저는 항상 드라이빙 테이블이 아니라 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;SELECT *
FROM employees e, dept_emp de
WHERE e.emp_no=de.emp_no
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 각 테이블의 emp_no 컬럼에 인덱스가 있을 때와 없을 때 조인 순서가 어떻게 달라지는 한 번 살펴보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;두 컬럼 모두 인덱스가 있는 경우
    &lt;ul&gt;
      &lt;li&gt;어느 테이블을 드라이빙으로 선택하든 인덱스를 이용해 드리븐 테이블의 검색 작업을 빠르게 처리할 수 있다&lt;/li&gt;
      &lt;li&gt;보통의 경우 어느 쪽 테이블이 드라이빙 테이블이 되든 옵티마이저가 선택하는 방법이 최적일 때가 많다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;employees 테이블에만 인덱스가 있는경우
    &lt;ul&gt;
      &lt;li&gt;이 때는 employees 테이블을 드리븐 테이블로 선택한다&lt;/li&gt;
      &lt;li&gt;드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지하기 때문에 드리븐 테이블에서 인덱스를 활용하는 것이 중요한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;INNER JOIN은 조인 대상 테이블 모두에 해당하는 레코드만 반환한다. 이같은 특성 때문에 OUTER JOIN으로만 조인을 실행하는 쿼리들도 자주 보인다. 하지만 대개의 경우 OUTER JOIN은 대상 테이블들의 데이터가 일관되지 않은 경우에만 필요하다.&lt;/p&gt;

&lt;p&gt;MySQL 옵티마이저는 OUTER JOIN시 조인 되는 테이블(FROM A LEFT JOIN B에서 B)을 드라이빙 테이블로 선택하지 못하기 때문에 무조건 앞에 등장하는 테이블을 드라이빙 테이블로 선택한다. 그 결과 인덱스 유무에 따라 조인 순서를 변경함으로써 얻게 되는 최적화의 이점을 얻지 못하기 때문에 쿼리 성능이 나빠질 수 있다. 그래서 꼭 필요한 경우가 아니라면 INNER JOIN을 사용하는 것이 쿼리의 성능에 도움이 된다.&lt;/p&gt;

&lt;p&gt;JOIN의 순서&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;INNER JOIN인 경우
    &lt;ul&gt;
      &lt;li&gt;어차피 A and B and C 이기 때문에 A JOIN B JOIN C이든 B JOIN A JOIN C이든 같다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;LEFT JOIN의 경우 결과도 성능도 달라진다.
    &lt;ul&gt;
      &lt;li&gt;일단 가장 먼저 등장하는 테이블이 드라이빙 테이블이 된다 -&amp;gt; 이 말은 뒤에 따라오는 테이블은 드리븐 테이블이 된다는 말이다 -&amp;gt; 드리븐 테이블은 인덱스가 없으면 성능이 떨어진다 -&amp;gt; 뒤에 조인되는 테이블의 인덱스 유무에 따라 쿼리 성능이 달라진다&lt;/li&gt;
      &lt;li&gt;결과 자체도 맨 앞에 등장하는 테이블의 모든 레코드가 기준이 되기 때문에 순서에 따라 달라진다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;INNER JOIN과 OUTER JOIN이 결합되는 경우
    &lt;ul&gt;
      &lt;li&gt;가능하다면 INNER JOIN이 앞에 오도록 하는 것이 좋다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;subquery&quot;&gt;Subquery&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Avoid correlated sub queries as it searches row by row, impacting the speed of SQL query processing&lt;/li&gt;
  &lt;li&gt;JOIN으로 해결되면 서브쿼리 대신 JOIN을 사용하자&lt;/li&gt;
  &lt;li&gt;서브쿼리 안에 where절과 group by를 통해 불러오는 데이터양을 감소시킬 수 있습니다&lt;/li&gt;
  &lt;li&gt;서브쿼리는 인덱스 또는 제약 정보를 가지지 않기 때문에 최적화되지 못한다&lt;/li&gt;
  &lt;li&gt;윈도우 함수를 고려해보자&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;temporary-table&quot;&gt;Temporary Table&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Use a temporary table to handle bulk data&lt;/li&gt;
  &lt;li&gt;Temporary table vs Using index access&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;order-by&quot;&gt;ORDER BY&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;대부분의 SELECT 쿼리에서 정렬은 필수적&lt;/li&gt;
  &lt;li&gt;정렬을 처리하는 방법은 &lt;strong&gt;인덱스를 이용하는 방법&lt;/strong&gt;과 &lt;strong&gt;Filesort&lt;/strong&gt;라는 별도의 처리를 이용하는 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;방법&lt;/td&gt;
      &lt;td&gt;장점&lt;/td&gt;
      &lt;td&gt;단점&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;인덱스 이용&lt;/td&gt;
      &lt;td&gt;SELECT 문을 실행할 때 이미 인덱스가 정렬돼 있어 순서대로 읽기만 하면 되므로 매우 빠르다&lt;/td&gt;
      &lt;td&gt;INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Filesort 이용&lt;/td&gt;
      &lt;td&gt;인덱스 이용과 반대로 INSERT, UPDATE, DELETE 작업이 빠르다&lt;/td&gt;
      &lt;td&gt;정렬 작업이 쿼리 실행 시 처리되어 쿼리의 응답 속도가 느려진다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Filesort를 사용해야 하는 경우&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정렬 기준이 너무 많아서 모든 인덱스를 생성하는 것이 불가능한 경우&lt;/li&gt;
  &lt;li&gt;어떤 처리의 결과를 정렬해야 하는 경우&lt;/li&gt;
  &lt;li&gt;랜덤하게 결과 레코드를 가져와야 하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;소트 버퍼&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데 이 메모리 공간을 소트 버퍼라고 한다&lt;/li&gt;
  &lt;li&gt;정렬해야 할 레코드의 건수가 소트 버퍼의 크기보다 크다면 어떻게 해야 할까?
    &lt;ul&gt;
      &lt;li&gt;정렬해야 할 레코드를 여러 조각으로 나눠서 처리하게 됨. 이 과정에서 임시 저장을 위해 디스크를 사용&lt;/li&gt;
      &lt;li&gt;일부를 처리하고 디스크에 저장하기를 반복 수행함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;정렬 알고리즘&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정렬 대상 컬럼과 프라이머리 키만 가져와서 정렬하는 방식
    &lt;ul&gt;
      &lt;li&gt;정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아 정렬을 수행&lt;/li&gt;
      &lt;li&gt;그리고 다시 정렬 순서대로 프라이머리 키로 테이블을 읽어서 SELECT할 컬럼을 가져옴&lt;/li&gt;
      &lt;li&gt;가져오는 컬럼이 두 개 뿐이라 소트 버퍼에 많은 레코드를 한 번에 읽어올 수 있음&lt;/li&gt;
      &lt;li&gt;단점은 테이블을 두 번 읽어야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정렬 대상 컬럼과 SELECT문으로 요청한 컬럼을 모두 가져와서 정렬하는 방식
    &lt;ul&gt;
      &lt;li&gt;최신 버전의 MySQL에서 일반적으로 사용하는 방식&lt;/li&gt;
      &lt;li&gt;SELECT 문에서 요청한 컬럼의 개수가 많아지면 계속 분할해서 소트 버퍼에 읽어와야함&lt;/li&gt;
      &lt;li&gt;레코드의 크기나 건수가 작은 경우 성능이 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정렬-처리-방법&quot;&gt;정렬 처리 방법&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;인덱스를 사용한 정렬
    &lt;ul&gt;
      &lt;li&gt;인덱스를 이용해 정렬을 하기 위해서는 반드시 ORDER BY의 순서대로 생성된 인덱스가 있어야 함&lt;/li&gt;
      &lt;li&gt;인덱스를 이용해 정렬이 가능한 이유는 B-Tree 인덱스가 키 값으로 정렬되어 있기 때문&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Filesort를 사용한 정렬
    &lt;ul&gt;
      &lt;li&gt;인덱스를 사용할 수 없는 경우, WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리(FIlesort)함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/select-optimization.html&quot; target=&quot;_blank&quot;&gt;MySQL 공식문서: Optimizing SELECT Statements&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://phoenixnap.com/kb/improve-mysql-performance-tuning-optimization&quot; target=&quot;_blank&quot;&gt;MySQL Performance Tuning and Optimization Tips&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://danbi-ncsoft.github.io/works/2021/11/05/etl-performace-tips.html&quot; target=&quot;_blank&quot;&gt;ETL 성능 향상을 위한 몇 가지 팁들&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://til.songyunseop.com/mysql/group-by-optimization.html&quot; target=&quot;_blank&quot;&gt;전지적 송윤섭시점 TIL, GROUP BY 최적화&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://otsteam.tistory.com/136&quot; target=&quot;_blank&quot;&gt;SQL 성능을 위한 25가지 규칙&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jojoldu.tistory.com/173?category=761883&quot; target=&quot;_blank&quot;&gt;패스트캠퍼스 SQL튜닝캠프 4일차 - 조인의 기본 원리와 활용&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://brightestbulb.tistory.com/147&quot; target=&quot;_blank&quot;&gt;취미는 공부 특기는 기록, Nested Loop Join, Driving Table&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/9614922/does-the-join-order-matter-in-sql&quot; target=&quot;_blank&quot;&gt;stackoverflow, Does the join order matter in SQL?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://coding-factory.tistory.com/756&quot; target=&quot;_blank&quot;&gt;코딩팩토리, [DB] 데이터베이스 NESTED LOOPS JOIN (중첩 루프 조인)에 대하여&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://schatz37.tistory.com/2&quot; target=&quot;_blank&quot;&gt;고동의 데이터 분석, [SQL] “성능 관점”에서 보는 결합(Join)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://schatz37.tistory.com/3?category=878798&quot; target=&quot;_blank&quot;&gt;고동의 데이터 분석, [SQL] 성능 관점에서의 서브쿼리(Subquery)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Fri, 29 Jul 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/mysql-series14</link>
                <guid isPermaLink="true">http://localhost:4000/mysql-series14</guid>
                
                <category>MySQL</category>
                
                
                <category>DE</category>
                
            </item>
        
    </channel>
</rss>