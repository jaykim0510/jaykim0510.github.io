<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Code Museum</title>
        <description>Jay Tech personal blogging theme for Jekyll</description>
        <link>http://localhost:4000/</link>
        <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Sun, 24 Jul 2022 05:13:32 +0900</pubDate>
        <lastBuildDate>Sun, 24 Jul 2022 05:13:32 +0900</lastBuildDate>
        <generator>Jekyll v4.2.1</generator>
        
            <item>
                <title>Data Engineering Series [Part12]: Database Internals 트랜잭션 처리와 복구</title>
                <description>&lt;hr /&gt;

&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#트랜잭션-처리와-복구&quot; id=&quot;markdown-toc-트랜잭션-처리와-복구&quot;&gt;트랜잭션 처리와 복구&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#버퍼-관리&quot; id=&quot;markdown-toc-버퍼-관리&quot;&gt;버퍼 관리&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#캐싱&quot; id=&quot;markdown-toc-캐싱&quot;&gt;캐싱&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#캐시-만료&quot; id=&quot;markdown-toc-캐시-만료&quot;&gt;캐시 만료&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#페이지-고정&quot; id=&quot;markdown-toc-페이지-고정&quot;&gt;페이지 고정&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#페이지-교체&quot; id=&quot;markdown-toc-페이지-교체&quot;&gt;페이지 교체&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#복구&quot; id=&quot;markdown-toc-복구&quot;&gt;복구&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#리두로그-언두로그&quot; id=&quot;markdown-toc-리두로그-언두로그&quot;&gt;리두로그 언두로그&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;트랜잭션-처리와-복구&quot;&gt;트랜잭션 처리와 복구&lt;/h1&gt;

&lt;p&gt;트랜잭션을 수행하기 위해서는 데이터를 디스크에 저장하고 유지하는 자료구조 외에도 여러 컴포넌트가 필요하다.&lt;/p&gt;

&lt;p&gt;트랜잭션 매니저는 트랜잭션의 세부 단계를 제어, 관리 및 스케줄링하는 컴포넌트다.&lt;/p&gt;

&lt;p&gt;잠금 매니저는 리소스에 대한 동시 접근을 제어하고 데이터 무결성을 보장한다. 잠금이 해제되거나 트랜잭션이 완료되면 잠금매니저는 대기 중인 트랜잭션에 이 사실을 알린다&lt;/p&gt;

&lt;p&gt;페이지 캐시는 디스크와 스토리지 엔진 사이에서 중개자 역할을 한다. 메인 메모리의 변경 사항을 저장하고 영구 저장소와 동기화되지 않은 페이지를 캐시한다. 모든 데이터베이스 상태에 대한 변경 사항은 우선 페이지 캐시에 저장된다&lt;/p&gt;

&lt;p&gt;로그 매니저는 영구 저장소와 동기화되지 않은 페이지 캐시의 내용이 손실되지 않도록 로그(작업 히스토리)를 저장한다.&lt;/p&gt;

&lt;h2 id=&quot;버퍼-관리&quot;&gt;버퍼 관리&lt;/h2&gt;

&lt;p&gt;대부분의 데이터베이스는 상대적으로 속도가 느린 디스크와 빠른 메인 메모리로 구성된 계층 구조이다. 따라서 영구 저장소 접근 횟수를 줄이기 위해 페이지를 메모리에 캐시하고 요청한 페이지가 캐시되어 있다면 디스크가 아닌 캐시에서 반환한다.&lt;/p&gt;

&lt;p&gt;다른 프로세스가 캐시된 페이지와 일치하는 디스크에 저장된 데이터를 변경하지 않았다면 메모리에 캐시된 페이지를 재사용할 수 있다. 이와 같은 방식을 페이지 캐시 또는 버퍼풀이라고 부른다. 이러한 방식은 요청된 페이지가 메모리에 없을 경우에만 물리적 저장소에 접근한다. 페이지 캐시는 디스크에서 읽은 페이지를 메모리에 캐시한다. 시스템 장애가 발생하거나 시스템이 비정상적으로 종료되면 캐시된 데이터는 사라진다.&lt;/p&gt;

&lt;p&gt;디스크에서 메모리로 복사하는 작업을 페이징이라고 한다. 그리고 디스크로 플러시되지 않은 변경된 페이지는 더티페이지라고 한다. 일반적으로 페이지 캐시의 메모리 영역은 전체 데이터셋보다 작기 때문에 결국 새로운 페이지를 추가하기 위해 기존 페이지를 만료시켜야 한다.&lt;/p&gt;

&lt;p&gt;페이지 캐시의 주요 기능은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 내용을 메모리에 캐시한다&lt;/li&gt;
  &lt;li&gt;디스크에 저장된 페이지에 대한 변경 사항을 버퍼링하고 캐시된 페이지에 반영한다&lt;/li&gt;
  &lt;li&gt;캐시되지 않은 데이터가 요청될 경우 추가할 공간이 있으면 페이징하고 캐시된 버전을 반환한다&lt;/li&gt;
  &lt;li&gt;추가할 공간이 없다면 일부 페이지를 만료시키고 디스크로 플러시한다&lt;/li&gt;
  &lt;li&gt;캐시된 데이터가 요청된 경우에는 그냥 메모리에서 반환하면 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;캐싱&quot;&gt;캐싱&lt;/h3&gt;

&lt;p&gt;버퍼에 대한 변경 사항은 디스크에 쓰기 전까지 메모리에 남겨둔다. 어떤 프로세스도 원본 파일을 수정할 수 없기 때문에 동기화는 메모리에서 디스크로 플러시하는 단방향 작업이다. 데이터베이스는 페이지 캐시를 사용해 메모리를 관리하고 디스크 접근을 제어한다.&lt;/p&gt;

&lt;p&gt;스토리지 엔진이 특정 페이지를 요청하면 우선 캐시된 버전이 있는지 확인하고 있을 경우 반환한다. 없다면 논리적 페이지 주소 또는 페이지 번호를 물리적 주소로 변환해 해당 페이지를 메모리로 복사하고 반환한다. 이 떄 해당 페이지가 저장된 버퍼는 참조 상태라고 한다.&lt;/p&gt;

&lt;p&gt;페이지가 변경된 경우에는 페이지에 더티 플래그를 설정한다. 더티 플르개는 해당 페이지가 디스크와 동기화되지 않았고, 지속성을 위해 디스크로 플러시돼야 한다는 것을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;캐시-만료&quot;&gt;캐시 만료&lt;/h3&gt;

&lt;p&gt;캐시된 데이터가 많을수록 더 많은 읽기 요청을 디스크에 접근하지 않고 처리할 수 있다. 또한 같은 페이지에 대한 변경사항을 더 많이 같이 버퍼할 수 있다. 하지만 페이지 캐시의 크기는 한정적이기 때문에, &lt;strong&gt;새로운 페이지를 저장하기 위해 오래된 페이지는 제거해야 한다.&lt;/strong&gt; 페이지가 동기화됐고 고정 또는 참조 상태가 아니라면 바로 제거 될 수 있다. 더티 페이지는 제거되기 전에 먼저 플러시해야 한다. 참조 상태의 페이지는 사용이 끝나기 전까지는 제거될 수 없다.&lt;/p&gt;

&lt;p&gt;페이지를 제거할 때마다 디스크로 플러시한다면 성능을 저하시킬 수 있다. 따라서 별도의 백그라운드 프로세스가 제거될 가능성이 높은 &lt;strong&gt;더티 페이지를 주기적으로 디스크로 플러시&lt;/strong&gt;한다. 또한 데이터베이스에 갑작스런 장애가 발생한 경우 플러시되지 않은 데이터는 사라질 수 있다. 이러한 데이터 손실을 방지하기 위해 체크포인트 프로세스가 플러시 시점을 제어한다. 체크포인트 프로세스는 선행 기록 로그(Write Ahead Log)와 페이지 캐시의 싱크가 맞도록 조정한다. (이 말은 선행 기록 로그가 디스크에 있는 데이터라는 말인가? 동기화는 메모리에서 디스크로 플러시하는 단방향 작업이라 했으니까 선행 기록 로그보다 페이지의 데이터가 더 최신? -&amp;gt; 그렇지. 캐시된 페이지에 제일 먼저 변화 생기고 -&amp;gt; 로그 버퍼에 리두 로그(WAL) 버퍼링 되고 버퍼된 리두 로그 디스크에 플러시 되고 -&amp;gt; 캐시된 페이지 플러시) 오직 플러시가 완료된 캐시된 페이지와 관련된 로그만 WAL에서 삭제될 수 있다. 이 과정이 완료될 때 끼지 더티 페이지는 제거될 수 없다.&lt;/p&gt;

&lt;h3 id=&quot;페이지-고정&quot;&gt;페이지 고정&lt;/h3&gt;

&lt;p&gt;B-트리의 상위 레벨 노드는 대부분의 읽기 작업에서 접근한다. 이러한 트리의 일부를 캐시하면 상당한 도움이 될 수 있다. 따라서 우선 상위 레벨 노드를 메모리에 고정시키고 나머지 노드는 요청 시 페이징해도 된다.&lt;/p&gt;

&lt;h3 id=&quot;페이지-교체&quot;&gt;페이지 교체&lt;/h3&gt;

&lt;p&gt;저장 공간이 부족한 캐시에 새로운 페이지를 추가하려면 일부 페이지를 만료시켜야 한다. 캐시된 페이지는 만료 정책(페이지 교체 알고리즘)에 따라 캐시에서 제거된다. 만료 정책은 다시 요청될 확률이 낮은 페이지를 만료시키고 해당 위치에 새로운 페이지를 페이징한다. 이렇게 페이지를 만료시키고 새로운 페이지로 교체하는 알고리즘은 대표적으로 FIFO, LRU 등이 있다.&lt;/p&gt;

&lt;p&gt;FIFO는 First In First Out의 약자로 가장 먼저 큐에 들어온 페이지 ID가 가리키는 페이지를 만료시킨다. 이 방식은 간단하지만 페이지 접근 순서를 전혀 고려하지 않기 때문에 실용적이지 않다.&lt;/p&gt;

&lt;p&gt;LRU는 FIFO를 확장한 방식이다. FIFO와 마찬가지로 요청 순서대로 큐에 추가되다가 재요청 되면 다시 큐의 끝에 추가한다.&lt;/p&gt;

&lt;h2 id=&quot;복구&quot;&gt;복구&lt;/h2&gt;

&lt;p&gt;데이터베이스 개발자는 여러 장애 시나리오를 고려하고 약속된 데이터가 실제로 저장되게 해야 한다. 선행 기록 로그(WAL 또는 커밋 로그)는 장애 및 트랜잭션 복구를 위해 디스크에 저장하는 추가 전용(Append-only) 보조 자료 구조다. 페이지 캐시는 페이지에 대한 변경 사항을 메모리에 버퍼링한다. &lt;strong&gt;캐시된 내용이 디스크로 플러시될 때 까지 관련 작업 이력의 유일한 디스크 복사본은 WAL&lt;/strong&gt;이다. MySQL, PostreSQL과 같은 많은 데이터베이스가 추가 전용 WAL을 사용한다.&lt;/p&gt;

&lt;p&gt;WAL의 주요 기능은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;캐시된 페이지가 디스크와 동기화 될 때 까지 작업 이력을 디스크에 저장한다. 데이터베이스의 상태를 변경하는 작업을 실제 페이지에 적용하기 전에 먼저 디스크에 로깅한다&lt;/li&gt;
  &lt;li&gt;장애 발생 시 로그를 기반으로 마지막 메모리 상태를 재구성한다&lt;/li&gt;
  &lt;li&gt;WAL은 데이터가 디스크에 저장되도록 보장하고, 장애 발생시 데이터 상태를 되돌리기 위해 필요한 로그를 저장한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WAL은 추가 전용 자료구조이며, 작성된 데이터는 불변하기 때문에 모든 쓰기 작업은 순차적이다.&lt;/p&gt;

&lt;p&gt;WAL은 여러 로그 레코드로 구성된다. 모든 레코드에는 단조 증가하는 고유 로그 시퀀스 번호(LSN, Log Sequence Number)가 있다. 로그 레코드의 크기는 디스크 블록의 크기보다 작을 수 있기 때문에, 로그 버퍼에 임시 저장하고 포스 작업시 디스크로 플러시한다. 포스 작업은 로그 버퍼가 가득 차면 수행되거나 트랜잭션 매니저 또는 페이지 캐시가 직접 요청할 수도 있다. 모든 로그 레코드는 LSN과 동일한 순서로 플러시돼야 한다.&lt;/p&gt;

&lt;p&gt;WAL는 작업 로그 레코드 외에도 트랜잭션 완료 여부를 나타내는 레코드를 저장한다. 트랜잭션의 커밋 레코드의 LSN까지 플러시되기 전까지는 해당 트랜잭션은 커밋된 것으로 간주 할 수 없다. 일부 시스템은 트랜잭션 롤백 또는 복구 중 장애가 발생해도 시스템이 계속해서 정상 작동할 수 있도록 보상 로그 레코드를 로그에 저장하고 언두 작업 시 사용한다.&lt;/p&gt;

&lt;p&gt;일반적으로 WAL은 체크포인트에 도달하면 이전 로그를 정리하는 인터페이스를 통해 기본 저장소와 동기화한다. 로깅은 데이터베이스의 정확성 측면에서 매우 중요한 작업이다. 로그 정리 작업과 데이터를 기본 스토리지에 저장하는 작업이 조금이라도 어긋나면 데이터는 손실될 수 있다.&lt;/p&gt;

&lt;p&gt;모든 데이터는 한 번에 디스크로 플러시하면 체크포인트 작업이 완료될 때 까지 다른 작업을 모두 중지해야 하기 떄문에 비효율적이다. 이 문제를 해결하기 위해 대부분의 데이터베이스 시스템은 퍼지(fuzzy) 체크포인트를 사용한다.&lt;/p&gt;

&lt;p&gt;마지막으로 성공한 체크포인트 작업에 대한 정보는 로그 헤더에 저장된 last_checkpoint 포인터에 저장한다. 퍼지 체크포인트는 begin_checkpoint라는 특별한 로그 레코드로 시작해 더티 페이지에 대한 정보와 트랜잭션 테이블의 내용을 저장한 end_checkpoint라는 로그 레코드로 끝난다. 이 로그 레코드에 명시된 모든 페이지가 플러시될 때 까지 해당 체크포인트는 미완료 상태다. 페이지는 비동기적으로 플러시되며, 이 작업이 끝나면 last_checkpoint 레코드를 begin_checkpoint의 LSN으로 업데이트 한다. 장애가 발생할 경우, 복구 프로세스는 해당 LSN에서부터 시작한다.&lt;/p&gt;

&lt;h3 id=&quot;리두로그-언두로그&quot;&gt;리두로그 언두로그&lt;/h3&gt;

&lt;p&gt;데이터베이스 시스템은 데이터의 지속성과 트랜잭션의 원자성을 보장하는 쓰기 시 복사(Copy-on-write) 방식의 섀도 페이징 기법을 사용한다. 새로운 데이터를 우선 내부 섀도 페이지에 쓴 다음, 이전 버전의 페이지를 가리키는 포인터를 섀도 페이지를 가리키도록 변경해 업데이트된 내용을 반영한다.&lt;/p&gt;

&lt;p&gt;모든 상태 변화는 이전 상태와 이후 상태의 조합으로 나타낼 수 있다. 또는 그에 대응되는 리두 작업과 언두 작업으로 나타낼 수 있다. 이전 상태에 리두 작업을 수행하면 이후 상태가 된다. 반대로 이후 상태에 언두 작업을 수행하면 이전 상태가 된다.&lt;/p&gt;

&lt;p&gt;장애 발생 후 데이터베이스 시스템을 재시작하면 복구는 다음 3단계로 진행된다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;분석 단계: 페이지 캐시에 저장된 더티 페이지와 장애 발생 당시 수행 중이던 트랜잭션을 파악한다. 더티 페이지에 대한 정보를 기반으로 리두 단계의 시작 지점을 결정한다. 트랜잭션 목록은 언두 단계에서 미완료된 트랜잭션을 롤백하는 데 사용한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리두 단계: 장애가 발생하기 전까지의 작업을 재수행하고 데이터베이스를 이전 상태로 복원한다. 불완전한 트랜잭션, 커밋됐지만 디스크로 플러시되지 않은 트랜잭션을 롤백하기 위한 준비 단계다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;언두 단계: 불완전한 트랜잭션을 롤백하고 데이터베이스를 마지막 일관된 상태로 복원한다. 모든 작업은 실제 수행 순어의 역순으로 롤백된다. 복구 중에도 장애가 발생할 수 있기 때문에 언두 작업도 로그에 기록해야 된다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
                <pubDate>Wed, 20 Jul 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/data-engineering-series14</link>
                <guid isPermaLink="true">http://localhost:4000/data-engineering-series14</guid>
                
                <category>Data_Engineering</category>
                
                
                <category>DE</category>
                
            </item>
        
            <item>
                <title>Data Engineering Series [Part12]: Database Internals 개요</title>
                <description>&lt;hr /&gt;

&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#스토리지-엔진&quot; id=&quot;markdown-toc-스토리지-엔진&quot;&gt;스토리지 엔진&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#소개-및-개요&quot; id=&quot;markdown-toc-소개-및-개요&quot;&gt;소개 및 개요&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#dbms-구조&quot; id=&quot;markdown-toc-dbms-구조&quot;&gt;DBMS 구조&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#인메모리-dbms-디스크-기반-dbms&quot; id=&quot;markdown-toc-인메모리-dbms-디스크-기반-dbms&quot;&gt;인메모리 DBMS, 디스크 기반 DBMS&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#로우형-dbms-컬럼형-dbms&quot; id=&quot;markdown-toc-로우형-dbms-컬럼형-dbms&quot;&gt;로우형 DBMS, 컬럼형 DBMS&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;데이터베이스에서 중요한 개념: B-트리 알고리즘, 캐시 정책, 상태 복구, 동시성 제어&lt;br /&gt;
(실용적인 측면에서는, 데이터베이스별 기능, 얼마나 빠른지, 어떤 유형의 어플리케이션에 이용되는지, SQL, 쿼리 플랜)&lt;/p&gt;

&lt;p&gt;분산 데이터베이스에서 중요한 개념: 장애 감지, 리더 선출, 분산 트랜잭션, 합의 알고리즘&lt;/p&gt;

&lt;h1 id=&quot;스토리지-엔진&quot;&gt;스토리지 엔진&lt;/h1&gt;

&lt;p&gt;데이터베이스 관리 시스템의 주 목적은 데이터를 안정적으로 저장하고 사용자에게 제공하는 것이다. 일반적으로 데이터베이스는 기본 데이터 스토어로 사용되며 애플리케이션의 여러 구성 요소가 공유한다.&lt;/p&gt;

&lt;p&gt;데이터베이스는 모듈식 시스템이다. 요청을 전달하는 전송 계층, 가장 효율적인 쿼리 실행 계획을 결정하는 쿼리 프로세서, 실제 작업을 수행하는 실행 엔진 그리고 스토리지 엔진으로 구성된다.&lt;/p&gt;

&lt;p&gt;스토리지 엔진은 DBMS에서 데이터를 메모리와 디스크에 저장하고 검색 및 관리하는 소프트웨어 컴포넌트로써 각 노드에 데이터를 영구 저장한다. 데이터베이스가 복잡한 쿼리를 수행할 수 있도록 스토리지 엔진은 데이터를 세밀하게 조작할 수 있는 간단한 API를 제공한다. 사용자는 이를 사용해 레코드를 CRUD할 수 있다. 따라서 데이터베이스는 &lt;strong&gt;스토리지 엔진 위에서 스키마와 쿼리 언어, 인덱싱, 트랜잭션 등의 유용한 기능을 제공하는 애플리케이션&lt;/strong&gt;이라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;스토리지 엔진은 DBMS와 독립적으로 개발됐다. 데이터베이스 개발자는 플러그형 스토리지 엔진을 사용해 데이터베이스 시스템을 구현할 수 있다. 예를 들어 DBMS 중 MySQL은 InnoDB, MyISAM, RocksDB라는 스토리지 엔진을 가질 수 있고, 몽고DB는 WiredTiger, In-Memory 스토리지 엔진이 있다.&lt;/p&gt;

&lt;h2 id=&quot;소개-및-개요&quot;&gt;소개 및 개요&lt;/h2&gt;

&lt;p&gt;데이터베이스 관리 시스템의 용도는 다양하다. 일시적인 핫 데이터를 주로 저장하는 데 쓰이기도 하고, 장기 보관용 콜드 데이터 스토리지로 쓰이기도 한다. 복잡한 쿼리 분석을 지원하는 시스템도 있는가 하면, 키로만 값을 액세스할 수 있는 스토어도 있다.&lt;/p&gt;

&lt;p&gt;저장 매체에 따라 인메모리 DBMS와 디스크 기반 DBMS로 구분할 수도 있다. 레이아웃에 따라 로우형, 컬럼형, 와이드 컬럼형 DBMS로 구분할 수도 있다.&lt;/p&gt;

&lt;p&gt;또 사용 용도에 따라 온라인 트랜잭션 처리(OLTP), 온라인 분석 처리(OLAP) 데이터베이스로 구분할 수도 있다.&lt;/p&gt;

&lt;p&gt;저장 형태에 따라 로우형 레코드, 키-값 쌍, 다큐멘트형 데이터베이스가 있다.&lt;/p&gt;

&lt;h3 id=&quot;dbms-구조&quot;&gt;DBMS 구조&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/db_internals_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트의 요청은 트랜스포트 서브시스템을 통해 전달된다. 요청은 쿼리 형태이고 주로 특정 쿼리 언어로 표현된다. 트랜스포트 서브시스템은 쿼리를 쿼리 프로세서에 전달한다. 쿼리 프로세서는 쿼리를 해석, 분석 및 검증한다. 분석된 쿼리는 쿼리 옵티마이저에 전달된다.&lt;/p&gt;

&lt;p&gt;쿼리는 일반적으로 실행 계획 형태로 표현한다. 실행 계획은 쿼리가 요구하는 결과를 도출하는 데 수행해야 하는 일련의 작업이다.&lt;/p&gt;

&lt;p&gt;스토리지 엔진은 다음과 같은 역할을 담당하는 컴포넌트로 구성된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;트랜잭션 매니저: 트랜잭션을 스케줄링하고 데이터베이스 상태의 논리적 일관성을 보장한다&lt;/li&gt;
  &lt;li&gt;잠금 매니저: 트랜잭셔넹서 접근하는 데이터베이스 객체에 대한 잠금을 제어한다. 동시 수행 작업이 데이터 무결성을 침해하지 않도록 제어한다.&lt;/li&gt;
  &lt;li&gt;버퍼 매니저: 데이터 페이지를 메모리에 캐시한다&lt;/li&gt;
  &lt;li&gt;복구 매니저: 로그를 유지 관리하고 장애 발생 시 시스템을 복구한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스토리지 엔진은 버퍼링, 가변성, 순서화와 같은 요소에 따라 구분된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;버퍼링
    &lt;ul&gt;
      &lt;li&gt;데이터를 디스크에 쓰기 전에 일부를 메모리에 저장할지 여부&lt;/li&gt;
      &lt;li&gt;물론 모든 디스크 기반도 어느 정도 버퍼를 사용한다
(디스크의 가장 작은 전송 단위가 블록이므로 블록을 채워서 쓰기 위해 버퍼링 사용)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가변성
    &lt;ul&gt;
      &lt;li&gt;데이터를 갱신할 때 in-place vs (append-only, copy-on-write)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;순서화
    &lt;ul&gt;
      &lt;li&gt;디스크 페이지에 레코드를 키 순서로 저장할지에 대한 여부&lt;/li&gt;
      &lt;li&gt;순서화 -&amp;gt; 빠른 읽기, 비순서화 -&amp;gt; 빠른 쓰기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인메모리-dbms-디스크-기반-dbms&quot;&gt;인메모리 DBMS, 디스크 기반 DBMS&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;인메모리
    &lt;ul&gt;
      &lt;li&gt;메모리에 데이터 저장&lt;/li&gt;
      &lt;li&gt;디스크는 복구와 로그 저장 용도&lt;/li&gt;
      &lt;li&gt;단점: RAM의 휘발성(디스크로 보완, 배터리 장착된 RAM 사용), 가격&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디스크 기반
    &lt;ul&gt;
      &lt;li&gt;디스크에 데이터 저장&lt;/li&gt;
      &lt;li&gt;메모리는 캐시 또는 임시 저장 용도&lt;/li&gt;
      &lt;li&gt;단점: 랜덤 디스크 접근 속도 « 랜덤 메모리 접근 속도&lt;/li&gt;
      &lt;li&gt;디스크 기반은 아무리 큰 페이지를 캐시해도 직렬화와 데이터 레이아웃을 유지하는 오버헤드 때문에 인메모리 보다 느리다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인메모리 데이터베이스의 지속성&lt;/p&gt;

&lt;p&gt;인메모리 DBMS는 데이터의 지속성을 보장하고 데잍어 손실을 방지하기 위해 데이터를 디스크에 백업한다. 모든 작업은 로그 파일에 작업 내용을 순차적으로 기록해야 완료된다. 시스템 시작과 복구 시 모든 로그를 재수행하지 않기 위해 디스크에 백업본을 유지한다. 그렇게 함으로써 복구시에는 백업본과 로그를 기반으로 데이터를 재구성한다. (백업본만 있으면 이전 로그는 삭제해도 된다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/db_internals_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;로우형-dbms-컬럼형-dbms&quot;&gt;로우형 DBMS, 컬럼형 DBMS&lt;/h3&gt;

&lt;p&gt;대부분의 데이터베이스는 열과 행으로 구성된 테이블에 레코드를 저장한다. 데이터를 디스크에 저장하는 방식에 따라 데이터베이스를 분류할 수 있다. 컬럼 저장 방식은 테이블을 수직 분할하고, 로우 저장 방식은 수평 분할한다.&lt;/p&gt;

&lt;p&gt;MySQL, PostreSQL 등 대부분의 전통적인 관계형 데이터베이스는 로우형 DBMS이다. MonetDB, C-Store는 컬럼형 오픈소스 데이터베이스이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로우형 데이터 레이아웃
    &lt;ul&gt;
      &lt;li&gt;이 방식은 여러 필드의 값을 고유 식별 키로 구분할 수 있는 레코드 형식에 적합하다&lt;/li&gt;
      &lt;li&gt;일반적으로 특정 사용자의 필드는 여러 개가 함꼐 요청되는 경우가 많다&lt;/li&gt;
      &lt;li&gt;로우형 DBMS는 한 개의 로우씩 접근하는 경우 적합하다&lt;/li&gt;
      &lt;li&gt;한 블록에 모든 컬럼의 값이 들어가게 된다&lt;/li&gt;
      &lt;li&gt;특정 사용자의 모든 정보를 읽어올 때는 효율적, 모든 사용자의 특정 필드를 읽어올 때는 비효율적이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컬럼형 데이터 레이아웃
    &lt;ul&gt;
      &lt;li&gt;컬럼끼리 디스크에 연속해 저장하는 방식이다&lt;/li&gt;
      &lt;li&gt;컬럼형 DBMS는 데이터의 추세와 평균 등을 계산하는 집계 분석 작업에 적합하다&lt;/li&gt;
      &lt;li&gt;다시 레코드 형태로 재구성하기 위해 컬럼 사이의 관계를 정의하는 메타데이터가 필요하다 (각 값마다 키값을 중복저장해야 한다)&lt;/li&gt;
      &lt;li&gt;최근 몇 년 동안 대용량 데이터에 대한 복잡한 분석 쿼리 사용이 늘어나고 있다&lt;/li&gt;
      &lt;li&gt;결과적으로 파케이(Parquet), ORC와 같은 컬럼 기반 파일 포맷과 쿠두(Kude)와 같은 컬럼형 DBMS가 각광받고 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;같은 컬럼의 여러 값을 한 번에 읽으면 캐시 활용도와 처리 효율성이 높아진다. 같은 자료형끼리 저장하게 되면 압축률도 증가한다. 컬럼형과 로우형 DBMS 중 어떤 것을 사용할지 선택하려면 액세스 패턴을 파악해야 한다. 데이터를 레코드 단위로 접근하고 일반 쿼리와 범위 스캔 요청이 많다면 로우형 DBMS, 여러 로우를 스캔하거나 일부 컬럼에 대한 집계 작업이 많다면 컬럼형 DBMS가 더 적합할 수 있다.&lt;/p&gt;

&lt;p&gt;HBase와 같은 와이드 컬럼 스토어는 같은 자료형을 가지는 컬럼을 단위로 로우 형식으로 저장한다. 이 방식은 키 단위 액세스 패턴에 적합하다.&lt;/p&gt;
</description>
                <pubDate>Tue, 19 Jul 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/data-engineering-series13</link>
                <guid isPermaLink="true">http://localhost:4000/data-engineering-series13</guid>
                
                <category>Data_Engineering</category>
                
                
                <category>DE</category>
                
            </item>
        
            <item>
                <title>Network Series [Part12]: 네트워크 활용편(6) 도커 네트워크와 AWS 네트워크</title>
                <description>&lt;hr /&gt;
&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;
</description>
                <pubDate>Sun, 17 Jul 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/network-series12</link>
                <guid isPermaLink="true">http://localhost:4000/network-series12</guid>
                
                <category>Network</category>
                
                
                <category>CS</category>
                
            </item>
        
            <item>
                <title>Network Series [Part11]: 네트워크 활용편(5) 분산 시스템(Distributed System)</title>
                <description>&lt;hr /&gt;
&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9791161754963&amp;amp;orderClick=LEa&amp;amp;Kc=&quot; target=&quot;_blank&quot;&gt;책, Database Internals&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/rubentan/basic-distributed-systems-principles&quot; target=&quot;_blank&quot;&gt;slideshare: Basic distributed systems principles&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://vowi.fsinf.at/images/b/bc/TU_Wien-Verteilte_Systeme_VO_%28G%C3%B6schka%29_-_Tannenbaum-distributed_systems_principles_and_paradigms_2nd_edition.pdf&quot; target=&quot;_blank&quot;&gt;pdf: Distributed Systems: Principles and Paradigms&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Sat, 16 Jul 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/network-series11</link>
                <guid isPermaLink="true">http://localhost:4000/network-series11</guid>
                
                <category>Network</category>
                
                
                <category>CS</category>
                
            </item>
        
            <item>
                <title>Network Series [Part10]: 네트워크 활용편(4) 로드 밸런서(Load Balancer)</title>
                <description>&lt;hr /&gt;
&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://avinetworks.com/what-is-load-balancing/&quot; target=&quot;_blank&quot;&gt;AVI Networks: What Is Load Balancing?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kemptechnologies.com/what-is-load-balancing&quot; target=&quot;_blank&quot;&gt;Progress Kemp: What is load balancing?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jaehoney.tistory.com/73&quot; target=&quot;_blank&quot;&gt;Jae Honey, L4 / L7 로드밸런서 차이 (Load balancer)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Sat, 16 Jul 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/network-series10</link>
                <guid isPermaLink="true">http://localhost:4000/network-series10</guid>
                
                <category>Network</category>
                
                
                <category>CS</category>
                
            </item>
        
            <item>
                <title>Network Series [Part9]: 네트워크 활용편(3) Linux Network 관련 명령어</title>
                <description>&lt;hr /&gt;
&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;ifconfig, ip, netstat, ss, iptables, ufw, ping, route, curl, wget&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;
</description>
                <pubDate>Fri, 15 Jul 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/network-series9</link>
                <guid isPermaLink="true">http://localhost:4000/network-series9</guid>
                
                <category>Network</category>
                
                
                <category>CS</category>
                
            </item>
        
            <item>
                <title>Network Series [Part8]: 네트워크 활용편(2) REST API</title>
                <description>&lt;hr /&gt;
&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;REpresentational State Transfer&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTTP API와 REST API는 사실 거의 같은 의미로 사용됩니다.&lt;/p&gt;

&lt;p&gt;그런데 디테일하게 들어가면 차이가 있습니다.&lt;/p&gt;

&lt;p&gt;HTTP API는 HTTP를 사용해서 서로 정해둔 스펙으로 데이터를 주고 받으며 통신하는 것으로 이해하시면 됩니다.&lt;/p&gt;

&lt;p&gt;그래서 상당히 넓은 의미로 사용됩니다.&lt;/p&gt;

&lt;p&gt;반면에 REST API는 HTTP API에 여러가지 제약 조건이 추가됩니다.&lt;/p&gt;

&lt;p&gt;REST는 다음 4가지 제약조건을 만족해야 합니다.&lt;/p&gt;

&lt;p&gt;(https://ko.wikipedia.org/wiki/REST)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;자원의 식별&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메시지를 통한 리소스 조작&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자기서술적 메서지&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션의 상태에 대한 엔진으로서 하이퍼미디어&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여러가지가 있지만 대표적으로 구현하기 어려운 부분이 마지막에 있는 부분인데요. 이것은 HTML처럼 하이퍼링크가 추가되어서 다음에 어떤 API를 호출해야 하는지를 해당 링크를 통해서 받을 수 있어야 합니다.&lt;/p&gt;

&lt;p&gt;그리고 이런 부분을 완벽하게 지키면서 개발하는 것을 RESTful API라고 하는데요. 실무에서 이런 방법으로 개발하는 것은 현실적으로 어렵고, 또 추가 개발 비용대비 효과가 있는 것도 아닙니다.&lt;/p&gt;

&lt;p&gt;그런데 이미 많은 사람들이 해당 조건을 지키지 않아도 REST API라고 하기 때문에, HTTP API나 REST API를 거의 같은 의미로 사용하고 있습니다. 하지만 앞서 말씀드린 것 처럼 엄격하게 위의 내용들을 모두 지켜야 REST API라고 할 수 있습니다.(하지만 다들 HTTP API를 REST API라고 이미 하고 있기 때문에, 누군가 REST API라고 하면 그냥 아~ HTTP API를 이야기 하는구나 라고 생각하고 들으시면 됩니다. 물론 엄격하게는 다릅니다.)&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/RP_f5dMoHFc&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.inflearn.com/questions/126743&quot; target=&quot;_blank&quot;&gt;이영한님의 HTTP API와 REST API의 차이에 관한 질문에 대한 답변&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://restfulapi.net/&quot; target=&quot;_blank&quot;&gt;REST 논문을 정리한 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pronist.dev/146&quot; target=&quot;_blank&quot;&gt;정상우, REST를 보다 RESTful 하게 API 만들기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Thu, 14 Jul 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/network-series8</link>
                <guid isPermaLink="true">http://localhost:4000/network-series8</guid>
                
                <category>Network</category>
                
                
                <category>CS</category>
                
            </item>
        
            <item>
                <title>Network Series [Part7]: 네트워크 활용편(1) 웹 브라우저</title>
                <description>&lt;hr /&gt;
&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#웹-브라우저-렌더링-과정&quot; id=&quot;markdown-toc-웹-브라우저-렌더링-과정&quot;&gt;웹 브라우저 렌더링 과정&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#캐시와-쿠키&quot; id=&quot;markdown-toc-캐시와-쿠키&quot;&gt;캐시와 쿠키&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#캐시&quot; id=&quot;markdown-toc-캐시&quot;&gt;캐시&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#웹-브라우저-캐시와-cpu-캐시&quot; id=&quot;markdown-toc-웹-브라우저-캐시와-cpu-캐시&quot;&gt;웹 브라우저 캐시와 CPU 캐시&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#웹-브라우저-캐시의-종류&quot; id=&quot;markdown-toc-웹-브라우저-캐시의-종류&quot;&gt;웹 브라우저 캐시의 종류&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#프록시-캐시&quot; id=&quot;markdown-toc-프록시-캐시&quot;&gt;프록시 캐시&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#쿠키&quot; id=&quot;markdown-toc-쿠키&quot;&gt;쿠키&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#세션&quot; id=&quot;markdown-toc-세션&quot;&gt;세션&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;웹-브라우저-렌더링-과정&quot;&gt;웹 브라우저 렌더링 과정&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;대기열: 브라우저는 주소창을 통해 입력한 요청을 대기열에 넣는다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;캐싱: 요청에 대한 응답값을 프록시 서버 캐시 또는 웹 브라우저 캐시에 저장하고 재요청시 캐싱된 값을 리턴

브라우저 캐시: 쿠키, 로컬 스토리지, 세션 스토리지 등을 포함한 캐시

공유 프록시 캐시: 서버 앞 단에 클라이언트와 가깝게 프록시 서버를 배치한다. 프록시 서버에 저장된 응답값이 프록시 캐시
(Node.js 앞에 있는 nginx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DNS: URL의 도메인명을 IP주소로 변환한다. 이 과정 또한 바로 DNS로 요청을 보내지 않고, 호스트 파일과 같이 캐시된 데이터가 있는지 먼저 확인한다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;라우팅: DNS가 resolve한 IP주소와 ARP 과정을 통해 얻은 MAC 주소를 이용해 목적지 IP 주소로 라우팅 한다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;초기연결: 라우팅할 때 처음부터 데이터를 요청하는 것이 아니라 먼저 TCP 3 way handshake를 이용해 연결을 한다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;다운로드: 이제 요청에 대한 응답값과, 그외에 필요한 HTML, CSS, 이미지 등을 서버로부터 받는다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;렌더링: 웹 브라우저가 서버로부터 받아온 데이터를 이용해 렌더링하여 사용자에게 제공한다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/network_33.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;캐시와-쿠키&quot;&gt;캐시와 쿠키&lt;/h1&gt;

&lt;h2 id=&quot;캐시&quot;&gt;캐시&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;The goal of a caching is to store some resource “closer” to the access point than it was before&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;웹-브라우저-캐시와-cpu-캐시&quot;&gt;웹 브라우저 캐시와 CPU 캐시&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;The CPU cache consists of special circuits within the CPU that are designed to cache memory, i.e. the cache is implemented in hardware as part of the physical CPU. This special cache hardware has absolutely nothing to do with the browser cache&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;웹 브라우저 캐시&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;We all have cache stored in our internet browser. It’s essentially a folder which contains small pieces of information taken from our browsing experience and the sites we visit. The aim is to make pages we revisit load faster.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;CPU 캐시&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;The purpose of the cache memory component is to increase speed. It’s located physically closer to the processor than the RAM component making it 10 to 100 times faster than RAM. However, its function is very different. The cache memory stores instructions and data that are used repeatedly by programs, enhancing the overall performance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;웹-브라우저-캐시의-종류&quot;&gt;웹 브라우저 캐시의 종류&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;로컬 스토리지
    &lt;ul&gt;
      &lt;li&gt;키/값 쌍의 형태로 클라이언트 브라우저에서 데이터를 저장하는 방법&lt;/li&gt;
      &lt;li&gt;수동으로 삭제하지 않는 한 영구적으로 저장소에 남아 있습니다.
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mac의 경우
~/Library/Application Support/Google/Chrome/Default/Local Storage/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;세션 스토리지
    &lt;ul&gt;
      &lt;li&gt;로컬 스토리지와 유사하지만 탭을 닫을 때 삭제됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쿠키&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/network_35.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프록시-캐시&quot;&gt;프록시 캐시&lt;/h3&gt;

&lt;p&gt;공유 프록시 캐시: 서버 앞 단에 클라이언트와 가깝게 프록시 서버를 배치한다. 프록시 서버에 저장된 응답값이 프록시 캐시&lt;br /&gt;
(Node.js 앞에 있는 nginx, AWS의 CloudFront)&lt;/p&gt;

&lt;h2 id=&quot;쿠키&quot;&gt;쿠키&lt;/h2&gt;

&lt;p&gt;쿠키는 웹 서버가 생성하여 웹 브라우저로 보내는 정보의 작은 파일입니다. 웹 브라우저는 미리 정해진 시간 동안 또는 웹 사이트에서 사용자의 세션 기간 동안 받은 쿠키를 저장합니다. 사용자가 웹 서버에 대해 향후 요청할 경우 관련 쿠키를 첨부합니다.&lt;/p&gt;

&lt;p&gt;쿠키는 웹 사이트가 사용자 경험을 개인화할 수 있도록 사용자에 대한 정보를 웹 사이트에 제공하는 데 도움이 됩니다. 예를 들어, 전자 상거래 웹사이트는 사용자들이 쇼핑 카트에 어떤 상품을 넣었는지 알기 위해 쿠키를 사용한다. 또한 일부 쿠키는 인증 쿠키와 같은 보안 목적으로 필요합니다(아래 참조).&lt;/p&gt;

&lt;p&gt;인터넷에서 사용되는 쿠키는 “HTTP 쿠키”라고도 불립니다. 대부분의 웹과 마찬가지로 쿠키는 HTTP 프로토콜을 사용하여 전송됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat ~/Library/Application Support/Google/Chrome/Default/Cookies
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/network_37.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;세션&quot;&gt;세션&lt;/h2&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cloudflare.com/ko-kr/learning/privacy/what-are-cookies/&quot; target=&quot;_blank&quot;&gt;CLOUD FLARE: What are cookies?, Cookies definition&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Wed, 13 Jul 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/network-series7</link>
                <guid isPermaLink="true">http://localhost:4000/network-series7</guid>
                
                <category>Network</category>
                
                
                <category>CS</category>
                
            </item>
        
            <item>
                <title>Coding Test Series [Part20]: 투 포인터(Two-Pointers)) - 문제</title>
                <description>&lt;hr /&gt;

&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#stack&quot; id=&quot;markdown-toc-stack&quot;&gt;Stack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;stack&quot;&gt;Stack&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/tag/two-pointers/&quot; target=&quot;_blank&quot;&gt;Leetcode: Two-Pointers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;✅ ❎&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;문제 리스트
---------------------------------------------EASY 3문제
- Remove Palindromic Subsequences
- Reverse String
- Count Binary Substrings
- 
---------------------------------------------MEDIUM 5문제
- Interval List Intersections
- Longest String Chain
- String Compression
- 3Sum With Multiplicity
- Next Permutation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
                <pubDate>Mon, 11 Jul 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/two-pointer</link>
                <guid isPermaLink="true">http://localhost:4000/two-pointer</guid>
                
                <category>Coding_Test</category>
                
                
                <category>CS</category>
                
            </item>
        
            <item>
                <title>Coding Test Series [Part19]: 스택(Stack) - 문제</title>
                <description>&lt;hr /&gt;

&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#stack&quot; id=&quot;markdown-toc-stack&quot;&gt;Stack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;stack&quot;&gt;Stack&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/tag/stack/&quot; target=&quot;_blank&quot;&gt;Leetcode: Stack&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;문제 리스트
---------------------------------------------EASY 3문제
- Increasing Order Search Tree
- Remove All Adjacent Duplicates In String
- Valid Parentheses
---------------------------------------------MEDIUM 7문제
- Minimum Remove to Make Valid Parentheses
- Exclusive Time of Functions
- Sum of Subarray Ranges
- Decode String
- Remove All Adjacent Duplicates in String II
- Asteroid Collision
- Simplify Path
--------------------------------------------- HARD 4문제
- Maximum Frequency Stack
- Trapping Rain Water
- Largest Rectangle in Histogram
- Longest Valid Parentheses
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
                <pubDate>Mon, 11 Jul 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/stack</link>
                <guid isPermaLink="true">http://localhost:4000/stack</guid>
                
                <category>Coding_Test</category>
                
                
                <category>CS</category>
                
            </item>
        
    </channel>
</rss>