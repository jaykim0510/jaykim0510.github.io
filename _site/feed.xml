<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Jay Tech</title>
        <description>Jay Tech personal blogging theme for Jekyll</description>
        <link>http://localhost:4000/</link>
        <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Wed, 02 Feb 2022 09:19:10 +0900</pubDate>
        <lastBuildDate>Wed, 02 Feb 2022 09:19:10 +0900</lastBuildDate>
        <generator>Jekyll v4.2.1</generator>
        
            <item>
                <title>Kafka Series [Part5]: Kafka Listeners – Explained[번역]</title>
                <description>&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#kafka-listeners&quot; id=&quot;markdown-toc-kafka-listeners&quot;&gt;Kafka Listeners&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#why-can-i-connect-to-the-broker-but-the-client-still-fails&quot; id=&quot;markdown-toc-why-can-i-connect-to-the-broker-but-the-client-still-fails&quot;&gt;Why can I connect to the broker, but the client still fails?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#how-to-connecting-to-kafka-on-docker&quot; id=&quot;markdown-toc-how-to-connecting-to-kafka-on-docker&quot;&gt;HOW TO: Connecting to Kafka on Docker&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#how-to-connecting-to-kafka-on-iaascloud&quot; id=&quot;markdown-toc-how-to-connecting-to-kafka-on-iaascloud&quot;&gt;HOW TO: Connecting to Kafka on IaaS/Cloud&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#option-1-external-address-is-resolvable-locally&quot; id=&quot;markdown-toc-option-1-external-address-is-resolvable-locally&quot;&gt;Option 1: External address is resolvable locally&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#option-2-external-address-is-not-resolvable-locally&quot; id=&quot;markdown-toc-option-2-external-address-is-not-resolvable-locally&quot;&gt;Option 2: External address is NOT resolvable locally&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#exploring-listeners-with-docker&quot; id=&quot;markdown-toc-exploring-listeners-with-docker&quot;&gt;Exploring listeners with Docker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://www.confluent.io/blog/kafka-listeners-explained/&quot; target=&quot;_blank&quot;&gt;원문: Confluent블로그&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.confluent.io/blog/kafka-client-cannot-connect-to-broker-on-aws-on-docker-etc/?utm_source=github&amp;amp;utm_medium=rmoff&amp;amp;utm_campaign=ty.community.con.rmoff-listeners&amp;amp;utm_term=rmoff-devx&quot; target=&quot;_blank&quot;&gt;읽어보면 좋은 포스트&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;kafka-listeners&quot;&gt;Kafka Listeners&lt;/h1&gt;

&lt;p&gt;카프카 클라이언트가 카프카에 연결되기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;advertised.listeners&lt;/code&gt;(또는 도커 이미지를 사용할 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KAFKA_ADVERTISED_LISTENERS&lt;/code&gt;)를 &lt;strong&gt;external IP 주소&lt;/strong&gt;로 설정해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/kafka_36.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아파치 카프카는 분산 시스템입니다. 데이터는 리더 파티션으로부터 쓰고 읽어지며 리더 파티션은 어떤 브로커에도 있을 수 있습니다. 그래서 클라이언트가 카프카에 연결되기 위해서는 해당 리더 파티션을 가지고 있는 브로커가 누구인지에 대한 메타데이터를 요청합니다. 이 메타데이터에는 리더 파티션을 가지는 브로커의 엔드포인트 정보를 포함하고 있으며 클라이언트는 이 정보를 이용해 카프카와 연결될 것입니다.&lt;/p&gt;

&lt;p&gt;만약 카프카가 도커와 같은 가상머신이 아닌 bare metal 위에서 동작한다면 이 엔드포인트는 그저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hostname&lt;/code&gt;이나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localhost&lt;/code&gt; 정도가 될 것입니다. 하지만 조금 더 복잡한 네트워크 환경 또는 멀티 노드 환경으로 오게 되면 조금 더 주의가 필요하게 됩니다.&lt;/p&gt;

&lt;p&gt;초기에 브로커가 연결되면 실제로 리더 파티션을 가지는 브로커의 host와 IP의 정보를 돌려줍니다. 이러한 과정은 단일 노드 환경에서도 마찬가지입니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KAFKA_LISTENERS: LISTENER_BOB://kafka0:29092,LISTENER_FRED://localhost:9092
KAFKA_ADVERTISED_LISTENERS: LISTENER_BOB://kafka0:29092,LISTENER_FRED://localhost:9092
KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: LISTENER_BOB:PLAINTEXT,LISTENER_FRED:PLAINTEXT
KAFKA_INTER_BROKER_LISTENER_NAME: LISTENER_BOB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;server.properties&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;KAFKA_LISTENERS&lt;/strong&gt;: 카프카가 리스닝하기 위해 노출하는 host/IP와 port&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;KAFKA_ADVERTISED_LISTENERS&lt;/strong&gt;: 클라이언트에게 알려주는 리스너의 host/IP와 port 리스트&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;KAFKA_LISTENER_SECURITY_PROTOCOL_MAP&lt;/strong&gt;: 각 리스너들이 사용하는 security protocol&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;KAFKA_INTER_BROKER_LISTENER_NAME&lt;/strong&gt;: 브로커들 간의 통신을 위해 사용하는 리스너&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;브로커에 연결되면 연결된 리스너가 반환됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kafkacat&lt;/code&gt;은 이러한 정보를 알아보는 유용한 툴입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-L&lt;/code&gt;을 이용하면 연결된 리스너에 관한 메타데이터를 얻을 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 9092포트로 연결시, localhost:9092 리스너가 반환&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kafkacat &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; kafka0:9092 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
           &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt;
Metadata &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;all topics &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;from broker &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt;: kafka0:9092/bootstrap&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
1 brokers:
  broker 0 at localhost:9092
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 29092포트로 연결시, kafka0:29092 리스너가 반환&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kafkacat &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; kafka0:29092 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
           &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt;
Metadata &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;all topics &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;from broker 0: kafka0:29092/0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
1 brokers:
  broker 0 at kafka0:29092
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;why-can-i-connect-to-the-broker-but-the-client-still-fails&quot;&gt;Why can I connect to the broker, but the client still fails?&lt;/h1&gt;

&lt;p&gt;초기 브로커 연결에 성공했다고 하더라도, 브로커가 반환하는 메타데이터 안에 있는 주소로 여전히 클라이언트가 접근하지 못하는 경우가 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;AWS EC2 인스턴스에 브로커를 만들어 로컬 머신에서 EC2에 있는 브로커로 메세지를 보내보려고 합니다. external hostname은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ec2-54-191-84-122.us-west-2.compute.amazonaws.com&lt;/code&gt;입니다. 로컬 머신과 EC2가 포트포워딩을 통해 연결되었는지 확인해보겠습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;우리의 로컬 머신은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ec2-54-191-84-122.us-west-2.compute.amazonaws.com&lt;/code&gt;을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;54.191.84.122&lt;/code&gt;으로 성공적으로 리졸브(resolve) 합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kafkacat -b ec2-54-191-84-122.us-west-2.compute.amazonaws.com:9092 -L
Metadata for all topics (from broker -1: ec2-54-191-84-122.us-west-2.compute.amazonaws.com:9092/bootstrap):
1 brokers:
  broker 0 at ip-172-31-18-160.us-west-2.compute.internal:9092
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;hostname이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip-172-31-18-160.us-west-2.compute.internal&lt;/code&gt;인 리스너를 반환합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하지만 인터넷을 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip-172-31-18-160.us-west-2.compute.internal&lt;/code&gt;은 not resolvable해서 클라이언트는 브로커에 메세지 전송을 실패합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo &quot;test&quot;|kafka-console-producer --broker-list ec2-54-191-84-122.us-west-2.compute.amazonaws.com:9092 --topic test
&amp;gt;&amp;gt;[2018-07-30 15:08:41,932] ERROR Error when sending message to topic test with key: null, value: 4 bytes with error: (org.apache.kafka.clients.producer.internals.ErrorLoggingCallback)
org.apache.kafka.common.errors.TimeoutException: Expiring 1 record(s) for test-0: 1547 ms has passed since batch creation plus linger time
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;브로커가 설치된 서버의 클라이언트로는 문제없이 동작한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo &quot;foo&quot;|kafka-console-producer --broker-list ec2-54-191-84-122.us-west-2.compute.amazonaws.com:9092 --topic test
&amp;gt;&amp;gt;
$ kafka-console-consumer --bootstrap-server ec2-54-191-84-122.us-west-2.compute.amazonaws.com:9092 --topic test --from-beginning
foo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이러한 일이 발생하는 이유는 9092포트로 연결하는 리스너가 내부 리스너이기 때문이라고 한다. 그래서 브로커가 설치된 서버의 내부에서만 resolvable한 hostname인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip-172-31-18-160.us-west-2.compute.internal&lt;/code&gt;을 리턴한다.&lt;/p&gt;

&lt;h1 id=&quot;how-to-connecting-to-kafka-on-docker&quot;&gt;HOW TO: Connecting to Kafka on Docker&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/kafka_36.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커에서 동작하기 위해서는 카프카의 두 개의 listener를 지정해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;도커 네트워크 내에서의 통신&lt;/strong&gt;: 이것은 브로커간의 통신 또는 도커 안의 다른 컴포넌트와의 통신을 의미한다. 이를 위해서는 도커 네트워크 안에 있는 컨테이너의 호스트네임을 사용해야 한다. 각각의 브로커는 컨테이너의 호스트네임을 통해 서로 통신하게 될 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;도커가 아닌 네트워크로부터의 트래픽&lt;/strong&gt;: 이것은 도커를 실행하는 서버에서 로컬로 동작하는 클라이언트가 될 수 있다. 이러한 경우 도커를 실행하는 서버(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localhost&lt;/code&gt;)에서 컨테이너의 포트에 연결할 수 있다. 아래의 도커 컴포즈 스니펫을 한 번 보자.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;…&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;kafka0&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;confluentinc/cp-enterprise-kafka:5.2.1&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;9092:9092'&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;29094:29094'&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;depends_on&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zookeeper&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;…&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;# For more details see See https://rmoff.net/2018/08/02/kafka-listeners-explained/&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;KAFKA_LISTENERS&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LISTENER_BOB://kafka0:29092,LISTENER_FRED://kafka0:9092,LISTENER_ALICE://kafka0:29094&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;KAFKA_ADVERTISED_LISTENERS&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LISTENER_BOB://kafka0:29092,LISTENER_FRED://localhost:9092,LISTENER_ALICE://never-gonna-give-you-up:29094&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;KAFKA_LISTENER_SECURITY_PROTOCOL_MAP&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LISTENER_BOB:PLAINTEXT,LISTENER_FRED:PLAINTEXT,LISTENER_ALICE:PLAINTEXT&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;KAFKA_INTER_BROKER_LISTENER_NAME&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LISTENER_BOB&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;…&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;도커 네트워크 내에 클라이언트가 있다면 클라이언트는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;호스트네임 kafka0&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;29092 포트&lt;/code&gt;를 이용한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BOB&lt;/code&gt; 리스너를 통해 브로커와 통신할 것입니다. 각각의 컨테이너(클라이언트, 브로커)는 kafka0를 도커 내부 네트워크를 통해 resolve합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;도커를 실행하는 호스트 머신(VM)에 있는 외부 클라이언트의 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;호스트 네임 localhost&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;9092 포트&lt;/code&gt;를 이용한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FRED&lt;/code&gt; 리스너를 통해 브로커와 통신한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;도커를 실행하는 호스트 머신(VM) 밖에 있는 외부 클라이언트는 위의 리스너를 통해 통신할 수 없다. 왜냐하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kafka0&lt;/code&gt;도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localhost&lt;/code&gt;도 모두 resolvable하지 않기 때문이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;how-to-connecting-to-kafka-on-iaascloud&quot;&gt;HOW TO: Connecting to Kafka on IaaS/Cloud&lt;/h1&gt;

&lt;p&gt;도커와의 차이점은, 도커에서 외부의 연결은 단순히 localhost에서 이루어진 반면, 클라우드 호스트 기반의 카프카는 클라이언트가 localhost에 존재하지 않는다는 것이다.&lt;/p&gt;

&lt;p&gt;더 복잡한 것은 도커 네트워크가 호스트의 네트워크와는 크게 분리되어 있지만 IaaS에서는 외부 호스트 이름이 내부적으로 확인 가능한 경우가 많기 때문에 이러한 문제가 실제로 발생할 경우 호스트 이름이 잘못될 수 있다.&lt;/p&gt;

&lt;p&gt;브로커에 연결할 외부 주소가 브로커에게 로컬로 확인할 수 있는지 여부에 따라 두 가지 방법이 있다.&lt;/p&gt;

&lt;h2 id=&quot;option-1-external-address-is-resolvable-locally&quot;&gt;Option 1: External address is resolvable locally&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/kafka_37.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;EC2 인스턴스의 IP 주소는 기본적으로 External IP. 만약 local에서 resolvable하다면, 로컬 내의 클라이언트, 외부 클라이언트 모두 이를 통해 통신 가능. 다만 외부 클라이언트는 밑의 설정만 추가해주면 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;advertised.listeners=PLAINTEXT://ec2-54-191-84-122.us-west-2.compute.amazonaws.com:9092
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;option-2-external-address-is-not-resolvable-locally&quot;&gt;Option 2: External address is NOT resolvable locally&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/kafka_38.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 로컬 내에서 resolvable하지 않다면, 두 가지 리스너가 필요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;VPC 내에서의 통신을 위해 local에서 resolvable한 Internal IP를 통해 내부에서 리슨한다&lt;/li&gt;
  &lt;li&gt;VPC 밖, 예를 들어 나의 노트북에서 접속하려는 경우 인스턴스의 External IP가 필요하다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;listeners=INTERNAL://0.0.0.0:19092,EXTERNAL://0.0.0.0:9092
listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT
advertised.listeners=INTERNAL://ip-172-31-18-160.us-west-2.compute.internal:19092,EXTERNAL://ec2-54-191-84-122.us-west-2.compute.amazonaws.com:9092
inter.broker.listener.name=INTERNAL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;exploring-listeners-with-docker&quot;&gt;Exploring listeners with Docker&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Listener BOB (port 29092) for &lt;strong&gt;internal traffic on the Docker network&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Listener FRED (port 9092) for &lt;strong&gt;traffic from the Docker host machine (localhost)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Listener ALICE (port 29094) for &lt;strong&gt;traffic from outside&lt;/strong&gt;, reaching the Docker host on the DNS name never-gonna-give-you-up&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nn&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;2'&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;zookeeper&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;confluentinc/cp-zookeeper:5.2.1&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;ZOOKEEPER_CLIENT_PORT&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2181&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;ZOOKEEPER_TICK_TIME&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2000&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;kafka0&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;confluentinc/cp-enterprise-kafka:5.2.1&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;9092:9092'&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;29094:29094'&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;depends_on&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zookeeper&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;KAFKA_BROKER_ID&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;KAFKA_ZOOKEEPER_CONNECT&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zookeeper:2181&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;KAFKA_LISTENERS&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LISTENER_BOB://kafka0:29092,LISTENER_FRED://kafka0:9092,LISTENER_ALICE://kafka0:29094&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;KAFKA_ADVERTISED_LISTENERS&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LISTENER_BOB://kafka0:29092,LISTENER_FRED://localhost:9092,LISTENER_ALICE://never-gonna-give-you-up:29094&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;KAFKA_LISTENER_SECURITY_PROTOCOL_MAP&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LISTENER_BOB:PLAINTEXT,LISTENER_FRED:PLAINTEXT,LISTENER_ALICE:PLAINTEXT&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;KAFKA_INTER_BROKER_LISTENER_NAME&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LISTENER_BOB&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;KAFKA_AUTO_CREATE_TOPICS_ENABLE&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;false&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;

  &lt;span class=&quot;na&quot;&gt;kafkacat&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;confluentinc/cp-kafkacat&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;sleep infinity&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
                <pubDate>Sun, 30 Jan 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/kafka-series5</link>
                <guid isPermaLink="true">http://localhost:4000/kafka-series5</guid>
                
                <category>Kafka</category>
                
                
                <category>DE</category>
                
            </item>
        
            <item>
                <title>Kubernetes Series [Part7]: StatefulSet</title>
                <description>&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#kubernetes-basics&quot; id=&quot;markdown-toc-kubernetes-basics&quot;&gt;Kubernetes Basics&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#localhost-ip-address-127001&quot; id=&quot;markdown-toc-localhost-ip-address-127001&quot;&gt;Localhost (IP address 127.0.0.1)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pod-network&quot; id=&quot;markdown-toc-pod-network&quot;&gt;Pod network&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#service-network&quot; id=&quot;markdown-toc-service-network&quot;&gt;Service network&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.ibm.com/articles/kubernetes-networking-what-you-need-to-know/&quot; target=&quot;_blank&quot;&gt;원문: Kubernetes networking for developers - IBM developers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;불과 몇 년 전까지만 하더라도 개발자들이 네트워크에 대해 알아야 할 지식은 그렇게 많지 않았습니다. 그들은 그들의 코드를 작성하고 로컬에서 동작하는지 확인한 후 테스트나 서비스를 위한 서버에 배포할 수 있었으면 됐었습니다.&lt;/p&gt;

&lt;p&gt;그러나 시간이 지나면서 컨테이너 기술이 점점 발전되어가며 이런 추세가 약간 변하기 시작했습니다. 이번 글을 통해 컨테이너 기반의 배포환경에서 개발자들이 알아두면 좋은 네트워크 지식에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;kubernetes-basics&quot;&gt;Kubernetes Basics&lt;/h1&gt;

&lt;p&gt;컨테이너는 한 개의 어플리케이션 또는 프로세스로 이들을 실행시키기 위해 필요한 모든 것들이 포함되어 있습니다. 어플리케이션 관점에서 컨테이너는 마치 서버위에 동작중인 하나의 운영체제처럼 보입니다. 컨테이너는 컨테이너만의 네트워크 인터페이스, 파일 시스템 등 필요한 모든 것들을 갖추고 있습니다.&lt;/p&gt;

&lt;p&gt;쿠버네티스는 이러한 컨테이너의 집합으로 컨테이너는 쿠버네티스의 워커 노드 안에서 돌아갑니다. 만약 항상 함께 설치되어야 하는 두 개의 어플리케이션이 있다면 이 두 개의 어플리케이션을 가진 컨테이너 두 개를 하나의 &lt;strong&gt;파드(Pod)&lt;/strong&gt;로 정의할 수 있습니다. (파드는 확장가능한 단위로 보통 특정 노드에 장애가 발생할 경우 파드에 문제가 생기는 경우를 대비해, 여러 워커 노드에 파드를 분산 배포합니다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_31.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;localhost-ip-address-127001&quot;&gt;Localhost (IP address 127.0.0.1)&lt;/h1&gt;
&lt;p&gt;같은 파드내에 있는 컨테이너들은 같은 노드 안에서 실행됩니다. 쿠버네티스는 이러한 구조의 장점을 이용해 파드에 &lt;strong&gt;공유되는 네트워크 네임스페이스&lt;/strong&gt;를 각각 제공합니다. 네트워크 네임스페이스는 리눅스 커널의 특징 중 하나로 네트워크 자원들을 그룹으로 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 그룹내에서 실행되는 프로세스들은 그룹 안에 정의된 네트워크 리소스만 볼 수 있습니다. 예를 들어, 파드 A는 네트워크 네임스페이스가 A인 네트워크 리소스만 볼 수 있습니다. 이것이 바로 쿠버네티스가 파드들을 각각 독립시킬 수 있는 방법입니다. 예를 들어, 파드 A가 포트 80번으로 리스닝하는 것과 파드 B가 포트 80번으로 리스닝하는 것은 서로 독립되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파드 안의 컨테이너들은 같은 네트워크 네임스페이스를 공유하기 때문에 localhost를 통해 서로 통신할 수 있습니다. 그러므로 컨테이너들이 같은 포트 번호로 리스닝하면 트래픽이 컨테이너들에 모두 전송됩니다. 따라서 같은 트래픽을 받기를 원치 않는 다른 역할의 컨테이너들이라면 포트 번호를 서로 다르게 지정해야 합니다.&lt;/p&gt;

&lt;h1 id=&quot;pod-network&quot;&gt;Pod network&lt;/h1&gt;
&lt;p&gt;파드안의 컨테이너들은 파드 IP를 통해 묶여지고 포트를 통해 구분됩니다. 이러한 점에서 파드는 마치 하나의 가상 서버와 같다고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;사용되는 IP 주소는 &lt;strong&gt;파드 네트워크&lt;/strong&gt;라고 알려진 주소 블록에서 가져온 것입니다. 파드가 새로 기동될 때 마다 쿠버네티스는 파드 네트워크에서 사용 가능한 IP 주소를 가져와 파드에 할당한 후 실행합니다. 파드는 모두 동일한 네트워크에 있으며 이 네트워크를 통해 서로 통신할 수 있습니다. 파드가 통신할 수 있는 대상을 제한할 수 있는 네트워크 정책이 있지만 기본적으로 서로 자유롭게 통신할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_35.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파드는 새로 기동될 때마다 파드 네트워크에서 IP주소를 새로 할당받습니다. 반면에 파드안의 컨테이너는 컨테이너가 파드 안에서 다시 기동되더라도 같은 IP주소를 갖게 됩니다.&lt;/p&gt;

&lt;p&gt;만약 특정 노드에 장애가 발생해 노드 안에 있던 파드들이 다른 노드 안에서 다시 기동되었다면 파드는 모두 새로운 IP주소를 받게 될겁니다. 만약 우리가 개발하는 상황이 IP 주소에 의존적이라면 이러한 쿠버네티스의 특징은 큰 단점이 될 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;service-network&quot;&gt;Service network&lt;/h1&gt;
&lt;p&gt;쿠버네티스에서는 이러한 단점을 해결해주는 리소스를 제공합니다. 쿠버네티스의 &lt;strong&gt;Service 리소스는 파드의 IP주소에 상관 없이 도메인 네임을 통해&lt;/strong&gt; 트래픽을 전송하도록 해줍니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;web&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;my-app&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;web-server&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;web&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;targetPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 서비스 리소스는 서비스 네트워크의 IP 주소로 확인되는 web.my-app.svc.cluster.local DNS 항목을 생성합니다. 할당된 서비스 IP는 서비스 spec.selector와 일치하는 모든 파드에 대한 트래픽 로드 밸런싱을 수행합니다. 위의 리소스 서비스는 metadata.labels.app가 web-server인 모든 파드가 포트 80으로 트래픽을 전송받도록 해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_33.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Service 리소스의 기본 타입은 ClusterIP이며 다음과 같은 종류의 타입들을 제공합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ClusterIP&lt;/li&gt;
  &lt;li&gt;NodePort&lt;/li&gt;
  &lt;li&gt;LoadBalancer&lt;/li&gt;
  &lt;li&gt;ExternalName&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_34.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
                <pubDate>Sat, 29 Jan 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/kubernetes-series7</link>
                <guid isPermaLink="true">http://localhost:4000/kubernetes-series7</guid>
                
                <category>Kubernetes</category>
                
                
                <category>devops</category>
                
            </item>
        
            <item>
                <title>Network Series [Part2]: IP주소와 DNS 서버</title>
                <description>&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ipinternet-protocol-주소&quot; id=&quot;markdown-toc-ipinternet-protocol-주소&quot;&gt;IP(Internet Protocol) 주소&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-주소&quot; id=&quot;markdown-toc-ip-주소&quot;&gt;IP 주소&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#서브넷-마스크subnet-mask&quot; id=&quot;markdown-toc-서브넷-마스크subnet-mask&quot;&gt;서브넷 마스크(Subnet Mask)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dnsdomain-name-system-서버&quot; id=&quot;markdown-toc-dnsdomain-name-system-서버&quot;&gt;DNS(Domain Name System) 서버&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;ipinternet-protocol-주소&quot;&gt;IP(Internet Protocol) 주소&lt;/h1&gt;

&lt;h2 id=&quot;ip-주소&quot;&gt;IP 주소&lt;/h2&gt;
&lt;p&gt;IP 주소는 인터넷에 연결하고자 하는 &lt;strong&gt;디바이스가 가지고 있는 NIC(Network Interface Controller)의 고유한 주소&lt;/strong&gt;를 뜻합니다. 편지를 주고 받기 위해서는 서로의 주소가 필요한 것처럼 디바이스간 통신을 위해서는 IP주소가 필요합니다. IP주소는 &lt;strong&gt;네트워크 번호와 호스트 번호로 이루어진 32비트 숫자&lt;/strong&gt;입니다.(IPv4 기준)&lt;/p&gt;
&lt;h2 id=&quot;서브넷-마스크subnet-mask&quot;&gt;서브넷 마스크(Subnet Mask)&lt;/h2&gt;

&lt;h1 id=&quot;dnsdomain-name-system-서버&quot;&gt;DNS(Domain Name System) 서버&lt;/h1&gt;
&lt;p&gt;DNS 서버는 도메인 네임을 IP주소로 매핑하여 보관하고 있는 서버입니다. 하지만 모든 도메인 정보를 저장할 수는 없고 저장한다고 해도 IP주소를 가지고 오는데 많은 시간이 소요됩니다. 이를 해결하기 위해 DNS 서버를 계층적으로 구성해 IP 주소를 가져오도록 했으며 한 번 가져온 정보는 캐시에 저장해둡니다. 하지만 캐시에 저장된 후 정보가 변경될 수 있기 때문에 캐시에 저장된 정보는 유효기간이 지나면 캐시에서 삭제됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/network_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
                <pubDate>Fri, 28 Jan 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/network-series2</link>
                <guid isPermaLink="true">http://localhost:4000/network-series2</guid>
                
                <category>Network</category>
                
                
                <category>CS</category>
                
            </item>
        
            <item>
                <title>Kubernetes Series [Part6]: ConfigMap과 Secret</title>
                <description>&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#kubernetes-basics&quot; id=&quot;markdown-toc-kubernetes-basics&quot;&gt;Kubernetes Basics&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#localhost-ip-address-127001&quot; id=&quot;markdown-toc-localhost-ip-address-127001&quot;&gt;Localhost (IP address 127.0.0.1)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pod-network&quot; id=&quot;markdown-toc-pod-network&quot;&gt;Pod network&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#service-network&quot; id=&quot;markdown-toc-service-network&quot;&gt;Service network&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.ibm.com/articles/kubernetes-networking-what-you-need-to-know/&quot; target=&quot;_blank&quot;&gt;원문: Kubernetes networking for developers - IBM developers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;불과 몇 년 전까지만 하더라도 개발자들이 네트워크에 대해 알아야 할 지식은 그렇게 많지 않았습니다. 그들은 그들의 코드를 작성하고 로컬에서 동작하는지 확인한 후 테스트나 서비스를 위한 서버에 배포할 수 있었으면 됐었습니다.&lt;/p&gt;

&lt;p&gt;그러나 시간이 지나면서 컨테이너 기술이 점점 발전되어가며 이런 추세가 약간 변하기 시작했습니다. 이번 글을 통해 컨테이너 기반의 배포환경에서 개발자들이 알아두면 좋은 네트워크 지식에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;kubernetes-basics&quot;&gt;Kubernetes Basics&lt;/h1&gt;

&lt;p&gt;컨테이너는 한 개의 어플리케이션 또는 프로세스로 이들을 실행시키기 위해 필요한 모든 것들이 포함되어 있습니다. 어플리케이션 관점에서 컨테이너는 마치 서버위에 동작중인 하나의 운영체제처럼 보입니다. 컨테이너는 컨테이너만의 네트워크 인터페이스, 파일 시스템 등 필요한 모든 것들을 갖추고 있습니다.&lt;/p&gt;

&lt;p&gt;쿠버네티스는 이러한 컨테이너의 집합으로 컨테이너는 쿠버네티스의 워커 노드 안에서 돌아갑니다. 만약 항상 함께 설치되어야 하는 두 개의 어플리케이션이 있다면 이 두 개의 어플리케이션을 가진 컨테이너 두 개를 하나의 &lt;strong&gt;파드(Pod)&lt;/strong&gt;로 정의할 수 있습니다. (파드는 확장가능한 단위로 보통 특정 노드에 장애가 발생할 경우 파드에 문제가 생기는 경우를 대비해, 여러 워커 노드에 파드를 분산 배포합니다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_31.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;localhost-ip-address-127001&quot;&gt;Localhost (IP address 127.0.0.1)&lt;/h1&gt;
&lt;p&gt;같은 파드내에 있는 컨테이너들은 같은 노드 안에서 실행됩니다. 쿠버네티스는 이러한 구조의 장점을 이용해 파드에 &lt;strong&gt;공유되는 네트워크 네임스페이스&lt;/strong&gt;를 각각 제공합니다. 네트워크 네임스페이스는 리눅스 커널의 특징 중 하나로 네트워크 자원들을 그룹으로 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 그룹내에서 실행되는 프로세스들은 그룹 안에 정의된 네트워크 리소스만 볼 수 있습니다. 예를 들어, 파드 A는 네트워크 네임스페이스가 A인 네트워크 리소스만 볼 수 있습니다. 이것이 바로 쿠버네티스가 파드들을 각각 독립시킬 수 있는 방법입니다. 예를 들어, 파드 A가 포트 80번으로 리스닝하는 것과 파드 B가 포트 80번으로 리스닝하는 것은 서로 독립되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파드 안의 컨테이너들은 같은 네트워크 네임스페이스를 공유하기 때문에 localhost를 통해 서로 통신할 수 있습니다. 그러므로 컨테이너들이 같은 포트 번호로 리스닝하면 트래픽이 컨테이너들에 모두 전송됩니다. 따라서 같은 트래픽을 받기를 원치 않는 다른 역할의 컨테이너들이라면 포트 번호를 서로 다르게 지정해야 합니다.&lt;/p&gt;

&lt;h1 id=&quot;pod-network&quot;&gt;Pod network&lt;/h1&gt;
&lt;p&gt;파드안의 컨테이너들은 파드 IP를 통해 묶여지고 포트를 통해 구분됩니다. 이러한 점에서 파드는 마치 하나의 가상 서버와 같다고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;사용되는 IP 주소는 &lt;strong&gt;파드 네트워크&lt;/strong&gt;라고 알려진 주소 블록에서 가져온 것입니다. 파드가 새로 기동될 때 마다 쿠버네티스는 파드 네트워크에서 사용 가능한 IP 주소를 가져와 파드에 할당한 후 실행합니다. 파드는 모두 동일한 네트워크에 있으며 이 네트워크를 통해 서로 통신할 수 있습니다. 파드가 통신할 수 있는 대상을 제한할 수 있는 네트워크 정책이 있지만 기본적으로 서로 자유롭게 통신할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_35.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파드는 새로 기동될 때마다 파드 네트워크에서 IP주소를 새로 할당받습니다. 반면에 파드안의 컨테이너는 컨테이너가 파드 안에서 다시 기동되더라도 같은 IP주소를 갖게 됩니다.&lt;/p&gt;

&lt;p&gt;만약 특정 노드에 장애가 발생해 노드 안에 있던 파드들이 다른 노드 안에서 다시 기동되었다면 파드는 모두 새로운 IP주소를 받게 될겁니다. 만약 우리가 개발하는 상황이 IP 주소에 의존적이라면 이러한 쿠버네티스의 특징은 큰 단점이 될 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;service-network&quot;&gt;Service network&lt;/h1&gt;
&lt;p&gt;쿠버네티스에서는 이러한 단점을 해결해주는 리소스를 제공합니다. 쿠버네티스의 &lt;strong&gt;Service 리소스는 파드의 IP주소에 상관 없이 도메인 네임을 통해&lt;/strong&gt; 트래픽을 전송하도록 해줍니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;web&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;my-app&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;web-server&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;web&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;targetPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 서비스 리소스는 서비스 네트워크의 IP 주소로 확인되는 web.my-app.svc.cluster.local DNS 항목을 생성합니다. 할당된 서비스 IP는 서비스 spec.selector와 일치하는 모든 파드에 대한 트래픽 로드 밸런싱을 수행합니다. 위의 리소스 서비스는 metadata.labels.app가 web-server인 모든 파드가 포트 80으로 트래픽을 전송받도록 해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_33.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Service 리소스의 기본 타입은 ClusterIP이며 다음과 같은 종류의 타입들을 제공합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ClusterIP&lt;/li&gt;
  &lt;li&gt;NodePort&lt;/li&gt;
  &lt;li&gt;LoadBalancer&lt;/li&gt;
  &lt;li&gt;ExternalName&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_34.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
                <pubDate>Fri, 28 Jan 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/kubernetes-series6</link>
                <guid isPermaLink="true">http://localhost:4000/kubernetes-series6</guid>
                
                <category>Kubernetes</category>
                
                
                <category>devops</category>
                
            </item>
        
            <item>
                <title>OS Series [Part1]: 운영체제와 컴퓨터의 구조</title>
                <description>&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#운영체제-소개&quot; id=&quot;markdown-toc-운영체제-소개&quot;&gt;운영체제 소개&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#운영체제의-구조&quot; id=&quot;markdown-toc-운영체제의-구조&quot;&gt;운영체제의 구조&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#커널과-인터페이스&quot; id=&quot;markdown-toc-커널과-인터페이스&quot;&gt;커널과 인터페이스&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#컴퓨터의-기본-구성&quot; id=&quot;markdown-toc-컴퓨터의-기본-구성&quot;&gt;컴퓨터의 기본 구성&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cpu와-메모리&quot; id=&quot;markdown-toc-cpu와-메모리&quot;&gt;CPU와 메모리&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#컴퓨터-성능-향상-기술&quot; id=&quot;markdown-toc-컴퓨터-성능-향상-기술&quot;&gt;컴퓨터 성능 향상 기술&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#병렬-처리&quot; id=&quot;markdown-toc-병렬-처리&quot;&gt;병렬 처리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;운영체제-소개&quot;&gt;운영체제 소개&lt;/h1&gt;
&lt;p&gt;운영체제는 컴퓨터 전원을 켜면 가장 먼저 만나게 되는 소프트웨어로, 대표적인 예로 컴퓨터의 윈도우와 맥, 리눅스, 모바일의 iOS, 안드로이드가 있습니다. 이뿐만 아니라 스마트 워치, 스마트 TV에도 성능은 낮지만 임베디드 운영체제가 있습니다.&lt;/p&gt;

&lt;p&gt;운영체제가 하는 역할은 크게 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스 관리&lt;/li&gt;
  &lt;li&gt;자원(CPU, 메모리) 관리 및 분배&lt;/li&gt;
  &lt;li&gt;파일시스템 관리&lt;/li&gt;
  &lt;li&gt;사용자 인터페이스 제공 (CLI, GUI)&lt;/li&gt;
  &lt;li&gt;하드웨어 인터페이스 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;🦊 &lt;strong&gt;인터페이스&lt;/strong&gt;&lt;br /&gt;
응용 프로그램이나 하드웨어는 굉장히 다양하고 어려운 분야이기에 사용자가 직접 접근하는 것은 어렵게 느껴집니다. 이러한 문제를 해결하고자 컴퓨터 분야에서는 인터페이스라는 것을 제공하고 있으며 운영체제라는 소프트웨어에도 인터페이스가 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;운영체제의-구조&quot;&gt;운영체제의 구조&lt;/h1&gt;
&lt;h2 id=&quot;커널과-인터페이스&quot;&gt;커널과 인터페이스&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../../images/os_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;컴퓨터의-기본-구성&quot;&gt;컴퓨터의 기본 구성&lt;/h1&gt;

&lt;h1 id=&quot;cpu와-메모리&quot;&gt;CPU와 메모리&lt;/h1&gt;

&lt;h1 id=&quot;컴퓨터-성능-향상-기술&quot;&gt;컴퓨터 성능 향상 기술&lt;/h1&gt;

&lt;h1 id=&quot;병렬-처리&quot;&gt;병렬 처리&lt;/h1&gt;
</description>
                <pubDate>Thu, 27 Jan 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/os-series1</link>
                <guid isPermaLink="true">http://localhost:4000/os-series1</guid>
                
                <category>OS</category>
                
                
                <category>CS</category>
                
            </item>
        
            <item>
                <title>Network Series [Part1]: 웹브라우저의 동작(Application Layer)</title>
                <description>&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#어플리케이션-계층application-layer&quot; id=&quot;markdown-toc-어플리케이션-계층application-layer&quot;&gt;어플리케이션 계층(Application Layer)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#웹-브라우저의-동작원리&quot; id=&quot;markdown-toc-웹-브라우저의-동작원리&quot;&gt;웹 브라우저의 동작원리&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#http-리퀘스트-작성&quot; id=&quot;markdown-toc-http-리퀘스트-작성&quot;&gt;HTTP 리퀘스트 작성&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#url-입력&quot; id=&quot;markdown-toc-url-입력&quot;&gt;URL 입력&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#url에-관한-문법&quot; id=&quot;markdown-toc-url에-관한-문법&quot;&gt;URL에 관한 문법&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#http-리퀘스트-작성-1&quot; id=&quot;markdown-toc-http-리퀘스트-작성-1&quot;&gt;HTTP 리퀘스트 작성&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#dns-서버에-웹-서버의-ip주소-조회&quot; id=&quot;markdown-toc-dns-서버에-웹-서버의-ip주소-조회&quot;&gt;DNS 서버에 웹 서버의 IP주소 조회&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#dns-resolver를-이용해-dns-서버-조회&quot; id=&quot;markdown-toc-dns-resolver를-이용해-dns-서버-조회&quot;&gt;DNS Resolver를 이용해 DNS 서버 조회&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#프로토콜-스택에-메시지-송신-요청&quot; id=&quot;markdown-toc-프로토콜-스택에-메시지-송신-요청&quot;&gt;프로토콜 스택에 메시지 송신 요청&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;어플리케이션-계층application-layer&quot;&gt;어플리케이션 계층(Application Layer)&lt;/h1&gt;

&lt;p&gt;어플리케이션 계층은 인터넷으로 연결 가능한 두 디바이스의 OSI layer 가장 끝단에 있는 계층으로, &lt;strong&gt;웹 브라우저, 게임, 메일&lt;/strong&gt;과 같은 것들이 있습니다. 그 중에서도 웹 브라우저(사파리, 크롬 등)는 웹 서버로의 접근, 파일 업로드/다운로드, 메일 전송과 같은 다양한 클라이언트 기능을 겸비한 복합적인 클라이언트 소프트웨어입니다. 그래서 저는 이번 포스트에서 웹 브라우저의 동작원리에 대해 집중적으로 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;디바이스간 연결을 위해서는 계층별로 지켜야 규약들이 있습니다. 만약 이러한 규약들이 없다면 세상에 존재하는 다양한 디바이스들을 연결시키기 어렵습니다. 어플리케이션에서도 이러한 규약들이 있는데 대표적으로 다음과 같은 것들이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Application Layer Protocols&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;HTTP&lt;/strong&gt;: HyperText Transfer Protocol의 약자. 하이퍼링크로 연결된 html 문서(사실상 거의 모든 데이터)를 전송할 때의 규약&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FTP&lt;/strong&gt;: File Transfer Protocol의 약자. 파일을 업로드/다운로드 할 때 사용되는 규약&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SMTP&lt;/strong&gt;: Simple Mail Transfer Protocol의 약자. 메일을 전송할 때 사용되는 규약&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;웹-브라우저의-동작원리&quot;&gt;웹 브라우저의 동작원리&lt;/h1&gt;
&lt;p&gt;우리가 웹 브라우저(크롬, 사파리 등)에서 뉴스 보기를 클릭하거나 유튜브 비디오를 시청할 때 내부적으로 어떤 일들이 일어나는지 한 번 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;http-리퀘스트-작성&quot;&gt;HTTP 리퀘스트 작성&lt;/h2&gt;
&lt;p&gt;우리는 보통 웹 브라우저에서 URL을 입력하거나 어떤 버튼을 클릭하는 식으로 웹 서버와 상호작용 하게 되는데 이 때 &lt;strong&gt;웹 브라우저는 내부에서 HTTP 리퀘스트라는 것을 웹 서버에 전송&lt;/strong&gt;합니다.&lt;/p&gt;

&lt;h3 id=&quot;url-입력&quot;&gt;URL 입력&lt;/h3&gt;

&lt;h3 id=&quot;url에-관한-문법&quot;&gt;URL에 관한 문법&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# URL 문법&lt;/span&gt;
scheme://[userinfo@]host[:port][/path][?query][#fragment]

예: https://www.google.com/search?q&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hello&amp;amp;hl&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ko


&lt;span class=&quot;c&quot;&gt;# scheme&lt;/span&gt;
예: https
- 주로 프로토콜이 사용됩니다.
- 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;https, http, ftp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
- 포트가 생략되어 있을 때 https가 사용되면 443포트, http가 사용되면 80포트가 디폴트
- https는 http에 보안 추가 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;HTTP Secure&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# host&lt;/span&gt;
예: www.google.com
- 도메인명 또는 IP주소

&lt;span class=&quot;c&quot;&gt;# port&lt;/span&gt;
예: 8888
- 접속 포트

&lt;span class=&quot;c&quot;&gt;# path&lt;/span&gt;
예: /search
- 리소스 경로 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;계층적 구조&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
- 디렉토리명/파일명

&lt;span class=&quot;c&quot;&gt;# query&lt;/span&gt;
예: ?q&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hello&amp;amp;hl&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ko
- &lt;span class=&quot;nv&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;value 형태
- ?로 시작, &amp;amp;로 추가 가능
- query parameter 또는 query string으로 보통 불림

&lt;span class=&quot;c&quot;&gt;# fragment&lt;/span&gt;
예: &lt;span class=&quot;c&quot;&gt;#getting-started-introducing-spring-boot&lt;/span&gt;
- html 내부 북마크 등에 사용
- 서버에 전송하는 정보는 아님
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;http-리퀘스트-작성-1&quot;&gt;HTTP 리퀘스트 작성&lt;/h3&gt;
&lt;p&gt;URL을 입력하고 나면 웹 브라우저는 URL을 바탕으로 HTTP 리퀘스트 메시지를 만듭니다.&lt;br /&gt;
HTTP 리퀘스트 메시지의 형태는 다음과 같습니다.&lt;br /&gt;
&lt;img src=&quot;../../images/network_1.jpeg&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
&lt;a href=&quot;https://joie-kim.github.io/HTTP/&quot; target=&quot;_blank&quot;&gt;(joie-kim님 블로그 참고)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;dns-서버에-웹-서버의-ip주소-조회&quot;&gt;DNS 서버에 웹 서버의 IP주소 조회&lt;/h2&gt;
&lt;p&gt;HTTP 리퀘스트를 작성하고 나면 이제 OS에게 이것을 웹 서버로 전송해달라고 요청합니다. (웹 브라우저가 직접 전송하지 않는 이유는 메시지를 송신하는 기능은 하나의 애플리케이션에만 종속되는 기능이 아니므로 OS에서 전송 기능을 담당하는 것이 더 좋다고 합니다.)&lt;/p&gt;

&lt;p&gt;OS에서는 리퀘스트 메시지를 전송하기 전에 먼저 &lt;strong&gt;도메인 네임을 IP 주소로 변환&lt;/strong&gt;하는 과정을 거칩니다. 이를 &lt;strong&gt;네임 레졸루션(name resolution)&lt;/strong&gt;이라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;dns-resolver를-이용해-dns-서버-조회&quot;&gt;DNS Resolver를 이용해 DNS 서버 조회&lt;/h3&gt;
&lt;p&gt;네임 레졸루션을 시행하는 것이 &lt;strong&gt;DNS 리졸버(DNS Resolver)&lt;/strong&gt;입니다. 리졸버는 Socket 라이브러리에 들어있는 부품화된 프로그램입니다. Socket 라이브러리는 네트워크 관련 기능을 하는 프로그램을 모아놓은 라이브러리입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/network_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로토콜-스택에-메시지-송신-요청&quot;&gt;프로토콜 스택에 메시지 송신 요청&lt;/h2&gt;
&lt;p&gt;DNS Resolver가 IP주소를 찾아오면 이제 진짜 웹 서버로 보낼 준비가 완료되었습니다. 이렇게 준비된 HTTP Request 메시지는 OS의 내부에 포함된 프로토콜 스택을 호출하여 실행을 요청합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/network_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;amp;ejkGb=KOR&amp;amp;barcode=9788931556742&quot; target=&quot;_blank&quot;&gt;성공과 실패를 결정하는 1%의 네트워크 원리 책&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.imperva.com/learn/application-security/osi-model/&quot; target=&quot;_blank&quot;&gt;imperva 블로그&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Thu, 27 Jan 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/network-series1</link>
                <guid isPermaLink="true">http://localhost:4000/network-series1</guid>
                
                <category>Network</category>
                
                
                <category>CS</category>
                
            </item>
        
            <item>
                <title>Kafka Series [Part4]: Kafka on Kubernetes</title>
                <description>&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#kafka-on-kubernetes&quot; id=&quot;markdown-toc-kafka-on-kubernetes&quot;&gt;Kafka on Kubernetes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#쿠버네티스-클러스터-구축&quot; id=&quot;markdown-toc-쿠버네티스-클러스터-구축&quot;&gt;쿠버네티스 클러스터 구축&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#단일-노드-클러스터&quot; id=&quot;markdown-toc-단일-노드-클러스터&quot;&gt;단일 노드 클러스터&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#minikube&quot; id=&quot;markdown-toc-minikube&quot;&gt;minikube&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#docker-desktop&quot; id=&quot;markdown-toc-docker-desktop&quot;&gt;Docker Desktop&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#멀티-노드-클러스터&quot; id=&quot;markdown-toc-멀티-노드-클러스터&quot;&gt;멀티 노드 클러스터&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#kind&quot; id=&quot;markdown-toc-kind&quot;&gt;kind&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#클라우드-환경gke-eks&quot; id=&quot;markdown-toc-클라우드-환경gke-eks&quot;&gt;클라우드 환경(GKE, EKS)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#쿠버네티스-gui-도구-lens&quot; id=&quot;markdown-toc-쿠버네티스-gui-도구-lens&quot;&gt;쿠버네티스 GUI 도구: Lens&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#카프카-메니페스트-작성&quot; id=&quot;markdown-toc-카프카-메니페스트-작성&quot;&gt;카프카 메니페스트 작성&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#loadbalancer-생성&quot; id=&quot;markdown-toc-loadbalancer-생성&quot;&gt;LoadBalancer 생성&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#zookeeper-설치&quot; id=&quot;markdown-toc-zookeeper-설치&quot;&gt;Zookeeper 설치&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#kafka-broker-설치&quot; id=&quot;markdown-toc-kafka-broker-설치&quot;&gt;Kafka Broker 설치&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#카프카-클라이언트&quot; id=&quot;markdown-toc-카프카-클라이언트&quot;&gt;카프카 클라이언트&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#카프카-모니터링&quot; id=&quot;markdown-toc-카프카-모니터링&quot;&gt;카프카 모니터링&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고자료&quot; id=&quot;markdown-toc-참고자료&quot;&gt;참고자료&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;kafka-on-kubernetes&quot;&gt;Kafka on Kubernetes&lt;/h1&gt;

&lt;h1 id=&quot;쿠버네티스-클러스터-구축&quot;&gt;쿠버네티스 클러스터 구축&lt;/h1&gt;
&lt;p&gt;쿠버네티스 클러스터를 구축하는 방법에 대해서는 &lt;a href=&quot;http://jaykim0510.github.io/kubernetes-series4&quot;&gt;Kubernetes Series [Part4]: Kubernetes 실습환경 구축하기&lt;/a&gt;를 참고하시면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;단일-노드-클러스터&quot;&gt;단일 노드 클러스터&lt;/h2&gt;
&lt;h3 id=&quot;minikube&quot;&gt;minikube&lt;/h3&gt;
&lt;p&gt;미니큐브는 물리 머신에 로컬 쿠버네티스를 쉽게 구축하고 실행할 수 있는 도구입니다. 실행되는 쿠버네티스는 &lt;strong&gt;단일 노드 구성&lt;/strong&gt;이기 때문에 여러 대의 구성이 필요한 쿠버네티스 기능은 사용할 수 없습니다. 또한 미니큐브는 로컬 가상 머신 위에 쿠버네티스를 설치하기 때문에 &lt;strong&gt;하이퍼바이저(Docer, Hyperkit, VirtualBox, ..)가 필요&lt;/strong&gt;합니다. 제가 현재 사용하고 있는 맥 환경에서는 기본적으로 하이퍼킷이 설치되어 있습니다. 하지만 m1칩의 경우에는 아직 하이퍼킷을 지원하지 않기 때문에 먼저 도커를 설치, 실행한 후 미니큐브를 실행하셔야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;minikube

minikube version
&lt;span class=&quot;c&quot;&gt;# minikube version: v1.25.1&lt;/span&gt;

minikube start &lt;span class=&quot;nt&quot;&gt;--driver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;docker &lt;span class=&quot;c&quot;&gt;# --kubernetes-version 옵션으로 버전 선택 가능&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--------------------------------------------------------------------------------&lt;/span&gt;
😄  Darwin 12.1 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;arm64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 의 minikube v1.25.1
✨  유저 환경 설정 정보에 기반하여 docker 드라이버를 사용하는 중
👍  minikube 클러스터의 minikube 컨트롤 플레인 노드를 시작하는 중
🚜  베이스 이미지를 다운받는 중 ...
💾  쿠버네티스 v1.23.1 을 다운로드 중 ...
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; preloaded-images-k8s-v16-v1...: 417.88 MiB / 417.88 MiB  100.00% 9.58 MiB
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; gcr.io/k8s-minikube/kicbase: 343.02 MiB / 343.02 MiB  100.00% 3.90 MiB p/
🔥  Creating docker container &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CPUs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2, &lt;span class=&quot;nv&quot;&gt;Memory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;7903MB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; ...
🐳  쿠버네티스 v1.23.1 을 Docker 20.10.12 런타임으로 설치하는 중
    ▪ kubelet.housekeeping-interval&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;5m
    ▪ 인증서 및 키를 생성하는 중 ...
    ▪ 컨트롤 플레인이 부팅...
    ▪ RBAC 규칙을 구성하는 중 ...
🔎  Kubernetes 구성 요소를 확인...
    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
🌟  애드온 활성화 : storage-provisioner, default-storageclass
🏄  끝났습니다! kubectl이 &lt;span class=&quot;s2&quot;&gt;&quot;minikube&quot;&lt;/span&gt; 클러스터와 &lt;span class=&quot;s2&quot;&gt;&quot;default&quot;&lt;/span&gt; 네임스페이스를 기본적으로 사용하도록 구성되었습니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 도커로 띄운 가상머신 위에서 쿠버네티스가 돌아가고 있습니다. 한 번 확인해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;minikube status
&lt;span class=&quot;nt&quot;&gt;--------------------&lt;/span&gt;
minikube
&lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

minikube ip
&lt;span class=&quot;c&quot;&gt;# 192.168.49.2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;정지하고 삭제하는 명령어도 간단합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;minikube stop

minikube delete
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;docker-desktop&quot;&gt;Docker Desktop&lt;/h3&gt;
&lt;p&gt;Docker Desktop은 도커를 맥/윈도우에서 사용하기 위한 목적으로 만들어졌습니다. 그리고 Docker Desktop 버전 18.06.0부터는 쿠버네티스도 사용할 수 있도록 지원하고 있습니다. 사용 방법은 간단합니다. Docker Desktop을 설치, 실행한 뒤 Enable Kubernetes 목록을 클릭해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/../../images/kube_24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(쿠버네티스를 Docker Desktop으로 실행할 때는 도커에서 제공하는 가상 머신위에 쿠버네티스 클러스터를 구성하는 것 같다. 그래서 클러스터 외부에서 쿠버네티스에 접속하려 할 때, 먼저 도커의 가상 머신 안으로 엔드포인트로 접근해야 하는데 이를 도커에서 localhost로 접근하도록 해준다. 그래서 별도로 도커 가상머신의 IP주소를 알려고 할 필요가 없다. 뇌피셜)&lt;/p&gt;

&lt;h2 id=&quot;멀티-노드-클러스터&quot;&gt;멀티 노드 클러스터&lt;/h2&gt;

&lt;h3 id=&quot;kind&quot;&gt;kind&lt;/h3&gt;
&lt;p&gt;kind는 도커 컨테이너를 여러 개 띄워서 컨테이너 각각을 노드로 사용함으로써 &lt;strong&gt;멀티 노드 클러스터&lt;/strong&gt;를 구축할 수 있습니다.&lt;br /&gt;
&lt;a href=&quot;https://kind.sigs.k8s.io&quot; target=&quot;_blank&quot;&gt;(kind 공식문서 참고)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: kind.x-k8s.io/v1alpha4
kind: Cluster
nodes:
- role: control-plane
  image: kindest/node:v1.23.1
- role: worker
  image: kindest/node:v1.23.1
- role: worker
  image: kindest/node:v1.23.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kind create cluster &lt;span class=&quot;nt&quot;&gt;--config&lt;/span&gt; kind.yaml &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; kindcluster
&lt;span class=&quot;nt&quot;&gt;----------------------------------------------------------------------&lt;/span&gt;
Creating cluster &lt;span class=&quot;s2&quot;&gt;&quot;kindcluster&quot;&lt;/span&gt; ...
 ✓ Ensuring node image &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;kindest/node:v1.23.1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 🖼
 ✓ Preparing nodes 📦 📦 📦
 ✓ Writing configuration 📜
 ✓ Starting control-plane 🕹️
 ✓ Installing CNI 🔌
 ✓ Installing StorageClass 💾
 ✓ Joining worker nodes 🚜
Set kubectl context to &lt;span class=&quot;s2&quot;&gt;&quot;kind-kindcluster&quot;&lt;/span&gt;
You can now use your cluster with:

kubectl cluster-info &lt;span class=&quot;nt&quot;&gt;--context&lt;/span&gt; kind-kindcluster

Have a &lt;span class=&quot;nb&quot;&gt;nice &lt;/span&gt;day! 👋
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;클러스터가 성공적으로 구축되었습니다.&lt;br /&gt;
쿠버네티스에서 실행중인 노드를 확인해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get nodes
----------------------------------------------------------------------------
NAME                        STATUS   ROLES                  AGE   VERSION
kindcluster-control-plane   Ready    control-plane,master   58s   v1.23.1
kindcluster-worker          Ready    &amp;lt;none&amp;gt;                 25s   v1.23.1
kindcluster-worker2         Ready    &amp;lt;none&amp;gt;                 25s   v1.23.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;클러스터는 다음 명령어로 삭제하시면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kind delete cluster &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; kindcluster
&lt;span class=&quot;nt&quot;&gt;------------------------------------------&lt;/span&gt;
Deleting cluster &lt;span class=&quot;s2&quot;&gt;&quot;kindcluster&quot;&lt;/span&gt; ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;클라우드-환경gke-eks&quot;&gt;클라우드 환경(GKE, EKS)&lt;/h3&gt;

&lt;h2 id=&quot;쿠버네티스-gui-도구-lens&quot;&gt;쿠버네티스 GUI 도구: Lens&lt;/h2&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;lens
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;카프카-메니페스트-작성&quot;&gt;카프카 메니페스트 작성&lt;/h1&gt;

&lt;h2 id=&quot;loadbalancer-생성&quot;&gt;LoadBalancer 생성&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.9.3/manifests/namespace.yaml

kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.9.3/manifests/metallb.yaml

kubectl create -f ./metallb/configmap.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# configmap.yaml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ConfigMap&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;metallb-system&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;config&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;|&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;address-pools:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;- name: default&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;protocol: layer2&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;addresses:&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;- 192.168.72.102&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;zookeeper-설치&quot;&gt;Zookeeper 설치&lt;/h2&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# deployment.yaml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zookeeper-deploy&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zookeeper-1&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zookeeper-1&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zoo1&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zookeeper:latest&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2181&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ZOOKEEPER_ID&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;1&quot;&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# zooservice.yaml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zookeeper-service&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zookeeper-1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;client&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2181&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;follower&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2888&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;leader&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3888&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zookeeper-1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;kafka-broker-설치&quot;&gt;Kafka Broker 설치&lt;/h2&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# kafkaservice.yaml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kafka-service&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metallb.universe.tf/address-pool&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;default&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metallb.universe.tf/allow-shared-ip&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;shared&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kafka&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LoadBalancer&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kafka-port&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;9092&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;targetPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;9092&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kafka&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;0&quot;&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# deployment.yaml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kafka-broker0&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kafka&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;0&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kafka&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;0&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;hostname&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kafka-host0&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kafka&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;wurstmeister/kafka&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;9092&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;KAFKA_LISTENERS&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;INTERNAL_LISTENER://kafka-host0:19092, EXTERNAL_LISTENER://localhost:9092&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;KAFKA_ADVERTISED_LISTENERS&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;INTERNAL_LISTENER://kafka-host0:19092, EXTERNAL_LISTENER://localhost:9092&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;KAFKA_INTER_BROKER_LISTENER_NAME&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;INTERNAL_LISTENER&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;KAFKA_LISTENER_SECURITY_PROTOCOL_MAP&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;INTERNAL_LISTENER:PLAINTEXT, EXTERNAL_LISTENER:PLAINTEXT&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;KAFKA_ZOOKEEPER_CONNECT&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zookeeper-service:2181&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;KAFKA_BROKER_ID&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;0&quot;&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;KAFKA_CREATE_TOPICS&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;admintome-test:1:1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 위치: opt/kafka_버전&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 주키퍼 실행&lt;/span&gt;
bin/zookeeper-server-start.sh ./config/zookeeper.properties

&lt;span class=&quot;c&quot;&gt;# 카프카 실행&lt;/span&gt;
bin/kafka-server-start.sh ./config/server.properties

&lt;span class=&quot;c&quot;&gt;# 토픽 생성&lt;/span&gt;
bin/kafka-topics.sh &lt;span class=&quot;nt&quot;&gt;--create&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--zookeeper&lt;/span&gt; zookeeper-service:2181 &lt;span class=&quot;nt&quot;&gt;--replication-factors&lt;/span&gt; 1 &lt;span class=&quot;nt&quot;&gt;--partitions&lt;/span&gt; 1 &lt;span class=&quot;nt&quot;&gt;--topic&lt;/span&gt; test-topic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;카프카-클라이언트&quot;&gt;카프카 클라이언트&lt;/h1&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 카프카 클라이언트 파이썬 버전 설치&lt;/span&gt;
pip &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;kafka-python
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# producer.py
&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;kafka&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KafkaProducer&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KafkaProducer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;security_protocol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PLAINTEXT&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bootstrap_servers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'192.168.111.2:9092'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;api_version&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'test'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'finally working kafka'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 현재 이부분에서 안넘어감 (bootstrap_servers의 host에 어떤거 넣어야 할지 모르겠음)
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;카프카-모니터링&quot;&gt;카프카 모니터링&lt;/h1&gt;

&lt;h1 id=&quot;참고자료&quot;&gt;참고자료&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://js94.tistory.com/entry/kafka-에러-해결&quot; target=&quot;_blank&quot;&gt;옥탑방의 일상로그 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://towardsdatascience.com/how-to-install-apache-kafka-using-docker-the-easy-way-4ceb00817d8b&quot; target=&quot;_blank&quot;&gt;Towards Data Science 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/pcjayasinghe/d1319f0135d197a42d770480e0a5701b#file-zookeeper-kafka-cluster-yml&quot; target=&quot;_blank&quot;&gt;pcjayasinghe 깃허브&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/PharosProduction/tutorial-apache-kafka-cluster&quot; target=&quot;_blank&quot;&gt;PharosProduction 깃허브&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@pcjayasinghe/deploy-apache-kafka-and-zookeeper-cluster-on-kubernetes-df9f0757b608&quot; target=&quot;_blank&quot;&gt;Deploy Apache Kafka and Zookeeper Cluster on Kubernetes 블로그 글&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Thu, 27 Jan 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/kafka-series4</link>
                <guid isPermaLink="true">http://localhost:4000/kafka-series4</guid>
                
                <category>Kafka</category>
                
                
                <category>DE</category>
                
            </item>
        
            <item>
                <title>Kafka Series [Part3]: Fault tolerance in Kafka</title>
                <description>&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#fault-tolerance-in-kafka&quot; id=&quot;markdown-toc-fault-tolerance-in-kafka&quot;&gt;Fault tolerance in Kafka&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#카프카-리플리케이션replication&quot; id=&quot;markdown-toc-카프카-리플리케이션replication&quot;&gt;카프카 리플리케이션(Replication)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#리더leader와-팔로워follower&quot; id=&quot;markdown-toc-리더leader와-팔로워follower&quot;&gt;리더(Leader)와 팔로워(Follower)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#컨트롤러controller&quot; id=&quot;markdown-toc-컨트롤러controller&quot;&gt;컨트롤러(Controller)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#리플리케이션-과정&quot; id=&quot;markdown-toc-리플리케이션-과정&quot;&gt;리플리케이션 과정&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고자료&quot; id=&quot;markdown-toc-참고자료&quot;&gt;참고자료&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;fault-tolerance-in-kafka&quot;&gt;Fault tolerance in Kafka&lt;/h1&gt;
&lt;p&gt;카프카는 데이터 파이프라인의 중앙에 위치하는 메인 허브 역할을 합니다. 그래서 만약 하드웨어의 문제나 네트워크의 장애로 인해 정상적으로 동작하지 못한다면, 카프카에 연결된 모든 파이프라인에 심각한 영향을 미치게 됩니다. 이러한 이유로 카프카는 초기 설계 단계에서부터 장애가 발생하더라도 안정적인 서비스를 제공할 수 있도록 구상됐습니다.&lt;/p&gt;

&lt;h2 id=&quot;카프카-리플리케이션replication&quot;&gt;카프카 리플리케이션(Replication)&lt;/h2&gt;
&lt;p&gt;카프카는 데이터를 저장할 때 하나의 브로커에만 저장하지 않고, &lt;strong&gt;다른 브로커에 파티션을 복제&lt;/strong&gt;해놓음으로써 임의의 브로커 장애에 대비할 수 있습니다. 만약 N개의 리플리케이션이 있을 경우, N-1개의 브로커에 장애가 발생하더라도 손실되지 않고 데이터를 주고 받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;그런데 만약 같은 데이터를 여러 브로커에서 읽게되면 어떻게 될까요? 아마 불필요한 데이터 전송으로 처리량이 낮아지고, 중복 처리를 해야하는 불필요한 오버헤드가 생길 것입니다. 이런 문제를 해결하고자 카프카에는 &lt;strong&gt;리더와 팔로워&lt;/strong&gt;가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/kafka_14.png&quot; alt=&quot;&quot; /&gt;
&lt;a href=&quot;https://medium.com/@anchan.ashwithabg95/fault-tolerance-in-apache-kafka-d1f0444260cf&quot; target=&quot;_blank&quot;&gt;(shwitha B G 블로그 참고)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;리더leader와-팔로워follower&quot;&gt;리더(Leader)와 팔로워(Follower)&lt;/h2&gt;
&lt;p&gt;카프카는 내부적으로 리플리케이션들을 리더와 팔로워로 구분하고, 파티션에 대한 쓰기와 읽기는 모두 리더 파티션을 통해서만 가능합니다. 다시 말해, 프로듀서는 리더 파티션에만 메시지를 전송하고, 컨슈머도 리더를 통해서만 메시지를 가져옵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/kafka_15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 팔로워는 어떤 역할을 할까요? 팔로워는 리더에 문제가 발생할 경우를 대비해 언제든지 새로운 리더가 될 수 있도록 준비를 하고 있어야합니다. 그러기 위해 팔로워들은 리더에게 새로운 메시지가 있는지 요청하고 있다면 메시지를 리더로부터 복제합니다.&lt;/p&gt;

&lt;h2 id=&quot;컨트롤러controller&quot;&gt;컨트롤러(Controller)&lt;/h2&gt;
&lt;p&gt;리더를 뽑기 위해서는 리더 선정을 담당하는 무엇인가가 카프카 클러스터에 있어야 합니다. 여기서 &lt;strong&gt;컨트롤러&lt;/strong&gt;라는 개념이 등장합니다. 컨트롤러는 카프카 클러스터 중 하나의 브로커가 컨트롤러 역할을 하게됩니다. 그래서 이러한 역할을 하는 브로커를 컨트롤러 브로커라고도 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/kafka_16.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/@anchan.ashwithabg95/fault-tolerance-in-apache-kafka-d1f0444260cf&quot; target=&quot;_blank&quot;&gt;(shwitha B G 블로그 참고)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;컨트롤러가 새로운 리더를 임명하는 과정을 살펴보겠습니다. &lt;strong&gt;주키퍼(Zookeeper)&lt;/strong&gt; 개념이 잠깐 등장합니다.&lt;br /&gt;
(&lt;strong&gt;Zookeeper&lt;/strong&gt; is the centralized service for storing metadata of topic, partition, and broker)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;주키퍼는 카프카의 모든 브로커들과 하트비트(Heartbeat)를 주고 받으며 브로커가 살아있는지 체크합니다.&lt;/li&gt;
  &lt;li&gt;브로커와 관련하여 어떤 이벤트가 발생하면 주키퍼는 이를 감지하고 자신을 subscribe하고 있는 브로커들에게 알립니다&lt;/li&gt;
  &lt;li&gt;컨트롤러는 알림을 받고 어떤 파티션을 새로운 리더로 임명할지 결정합니다.&lt;/li&gt;
  &lt;li&gt;컨트롤러는 어떤 브로커가 새로운 리더를 할당받을지 결정하고, 파티션을 리밸런싱합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;리플리케이션-과정&quot;&gt;리플리케이션 과정&lt;/h2&gt;
&lt;p&gt;마지막으로 리더와 팔로워간의 리플리케이션 과정을 살펴보고 포스트를 마치도록 하겠습니다.&lt;br /&gt;
먼저 리더와 팔로워에 대해 조금 더 알아보겠습니다. 리더와 몇몇의 팔로워는 &lt;strong&gt;ISR(InSyncReplica)&lt;/strong&gt;이라는 논리적 그룹으로 묶여 있습니다. 이렇게 ISR 그룹안에 속하는 팔로워만이 리더가 될 수 있는 후보입니다.&lt;br /&gt;
ISR 내의 팔로워들은 리더와의 데이터를 일치시키기 위해 지속적으로 리더의 데이터를 따라가게 되고, 리더는 ISR내의 팔로워가 모두 메세지를 받을 때까지 기다립니다.&lt;/p&gt;

&lt;p&gt;그러나 만약 팔로워를 가지는 브로커가 장애로 데이터를 리플리케이션하지 못하게 되면 더이상 리더와의 데이터가 일치하지 않게되므로 해당 파티션은 ISR 그룹에서 제외되게 됩니다. (리더 파티션을 가지는 브로커에 장애가 발생하면 리더 재선출 및 파티션 재할당, 팔로워의 경우 ISR그룹에서 제외)&lt;/p&gt;

&lt;p&gt;ISR 내에서 모든 팔로워의 복제가 완료되면, 리더는 내부적으로 커밋되었다는 표시를 하게됩니다. 이 때 마지막 커밋의 오프셋 위치를 &lt;strong&gt;하이워터마크(high water mark)&lt;/strong&gt;라고 부릅니다. 즉 커밋되었다는 것은 모든 팔로워가 리더의 데이터를 저장했음을 의미합니다. 그리고 이렇게 커밋된 메시지만 컨슈머가 읽어갈 수 있도록 함으로써 메시지의 일관성을 유지하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/kafka_17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 커밋되지 않은 메시지를 컨슈머가 읽어갈 수 있게 되면 어떻게 될까요? 위의 그림으로 설명을 해보겠습니다. 어떤 컨슈머가 Leader가 가지고 있던 아직 커밋되지 않은 Message 3을 읽어갔습니다. 그런데 갑자기 Leader 파티션을 가지고 있던 브로커에 장애가 발생해 Follower가 새로운 Leader가 되었습니다. 이렇게 되면 아까 컨슈머는 message 3을 읽어갔지만, 이제는 더이상 message 3을 읽어갈 수 없게 됩니다. 이러한 메세지 불일치 현상을 막고자 카프카는 커밋된 메세지만 읽어갈 수 있도록 한 것입니다.&lt;/p&gt;
&lt;h1 id=&quot;참고자료&quot;&gt;참고자료&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://hackernoon.com/apache-kafkas-distributed-system-firefighter-the-controller-broker-1afca1eae302&quot; target=&quot;_blank&quot;&gt;Hackernoon 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@anchan.ashwithabg95/fault-tolerance-in-apache-kafka-d1f0444260cf&quot; target=&quot;_blank&quot;&gt;Ashwitha B G 블로그&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Mon, 24 Jan 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/kafka-series3</link>
                <guid isPermaLink="true">http://localhost:4000/kafka-series3</guid>
                
                <category>Kafka</category>
                
                
                <category>DE</category>
                
            </item>
        
            <item>
                <title>Kubernetes Series [Part5]: Kubernetes networking for developers [번역]</title>
                <description>&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#kubernetes-basics&quot; id=&quot;markdown-toc-kubernetes-basics&quot;&gt;Kubernetes Basics&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#localhost-ip-address-127001&quot; id=&quot;markdown-toc-localhost-ip-address-127001&quot;&gt;Localhost (IP address 127.0.0.1)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pod-network&quot; id=&quot;markdown-toc-pod-network&quot;&gt;Pod network&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#service-network&quot; id=&quot;markdown-toc-service-network&quot;&gt;Service network&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.ibm.com/articles/kubernetes-networking-what-you-need-to-know/&quot; target=&quot;_blank&quot;&gt;원문: Kubernetes networking for developers - IBM developers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;불과 몇 년 전까지만 하더라도 개발자들이 네트워크에 대해 알아야 할 지식은 그렇게 많지 않았습니다. 그들은 그들의 코드를 작성하고 로컬에서 동작하는지 확인한 후 테스트나 서비스를 위한 서버에 배포할 수 있었으면 됐었습니다.&lt;/p&gt;

&lt;p&gt;그러나 시간이 지나면서 컨테이너 기술이 점점 발전되어가며 이런 추세가 약간 변하기 시작했습니다. 이번 글을 통해 컨테이너 기반의 배포환경에서 개발자들이 알아두면 좋은 네트워크 지식에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;kubernetes-basics&quot;&gt;Kubernetes Basics&lt;/h1&gt;

&lt;p&gt;컨테이너는 한 개의 어플리케이션 또는 프로세스로 이들을 실행시키기 위해 필요한 모든 것들이 포함되어 있습니다. 어플리케이션 관점에서 컨테이너는 마치 서버위에 동작중인 하나의 운영체제처럼 보입니다. 컨테이너는 컨테이너만의 네트워크 인터페이스, 파일 시스템 등 필요한 모든 것들을 갖추고 있습니다.&lt;/p&gt;

&lt;p&gt;쿠버네티스는 이러한 컨테이너의 집합으로 컨테이너는 쿠버네티스의 워커 노드 안에서 돌아갑니다. 만약 항상 함께 설치되어야 하는 두 개의 어플리케이션이 있다면 이 두 개의 어플리케이션을 가진 컨테이너 두 개를 하나의 &lt;strong&gt;파드(Pod)&lt;/strong&gt;로 정의할 수 있습니다. (파드는 확장가능한 단위로 보통 특정 노드에 장애가 발생할 경우 파드에 문제가 생기는 경우를 대비해, 여러 워커 노드에 파드를 분산 배포합니다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_31.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;localhost-ip-address-127001&quot;&gt;Localhost (IP address 127.0.0.1)&lt;/h1&gt;
&lt;p&gt;같은 파드내에 있는 컨테이너들은 같은 노드 안에서 실행됩니다. 쿠버네티스는 이러한 구조의 장점을 이용해 파드에 &lt;strong&gt;공유되는 네트워크 네임스페이스&lt;/strong&gt;를 각각 제공합니다. 네트워크 네임스페이스는 리눅스 커널의 특징 중 하나로 네트워크 자원들을 그룹으로 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 그룹내에서 실행되는 프로세스들은 그룹 안에 정의된 네트워크 리소스만 볼 수 있습니다. 예를 들어, 파드 A는 네트워크 네임스페이스가 A인 네트워크 리소스만 볼 수 있습니다. 이것이 바로 쿠버네티스가 파드들을 각각 독립시킬 수 있는 방법입니다. 예를 들어, 파드 A가 포트 80번으로 리스닝하는 것과 파드 B가 포트 80번으로 리스닝하는 것은 서로 독립되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파드 안의 컨테이너들은 같은 네트워크 네임스페이스를 공유하기 때문에 localhost를 통해 서로 통신할 수 있습니다. 그러므로 컨테이너들이 같은 포트 번호로 리스닝하면 트래픽이 컨테이너들에 모두 전송됩니다. 따라서 같은 트래픽을 받기를 원치 않는 다른 역할의 컨테이너들이라면 포트 번호를 서로 다르게 지정해야 합니다.&lt;/p&gt;

&lt;h1 id=&quot;pod-network&quot;&gt;Pod network&lt;/h1&gt;
&lt;p&gt;파드안의 컨테이너들은 파드 IP를 통해 묶여지고 포트를 통해 구분됩니다. 이러한 점에서 파드는 마치 하나의 가상 서버와 같다고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;사용되는 IP 주소는 &lt;strong&gt;파드 네트워크&lt;/strong&gt;라고 알려진 주소 블록에서 가져온 것입니다. 파드가 새로 기동될 때 마다 쿠버네티스는 파드 네트워크에서 사용 가능한 IP 주소를 가져와 파드에 할당한 후 실행합니다. 파드는 모두 동일한 네트워크에 있으며 이 네트워크를 통해 서로 통신할 수 있습니다. 파드가 통신할 수 있는 대상을 제한할 수 있는 네트워크 정책이 있지만 기본적으로 서로 자유롭게 통신할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_35.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파드는 새로 기동될 때마다 파드 네트워크에서 IP주소를 새로 할당받습니다. 반면에 파드안의 컨테이너는 컨테이너가 파드 안에서 다시 기동되더라도 같은 IP주소를 갖게 됩니다.&lt;/p&gt;

&lt;p&gt;만약 특정 노드에 장애가 발생해 노드 안에 있던 파드들이 다른 노드 안에서 다시 기동되었다면 파드는 모두 새로운 IP주소를 받게 될겁니다. 만약 우리가 개발하는 상황이 IP 주소에 의존적이라면 이러한 쿠버네티스의 특징은 큰 단점이 될 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;service-network&quot;&gt;Service network&lt;/h1&gt;
&lt;p&gt;쿠버네티스에서는 이러한 단점을 해결해주는 리소스를 제공합니다. 쿠버네티스의 &lt;strong&gt;Service 리소스는 파드의 IP주소에 상관 없이 도메인 네임을 통해&lt;/strong&gt; 트래픽을 전송하도록 해줍니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;web&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;my-app&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;web-server&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;web&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;targetPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 서비스 리소스는 서비스 네트워크의 IP 주소로 확인되는 web.my-app.svc.cluster.local DNS 항목을 생성합니다. 할당된 서비스 IP는 서비스 spec.selector와 일치하는 모든 파드에 대한 트래픽 로드 밸런싱을 수행합니다. 위의 리소스 서비스는 metadata.labels.app가 web-server인 모든 파드가 포트 80으로 트래픽을 전송받도록 해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_33.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Service 리소스의 기본 타입은 ClusterIP이며 다음과 같은 종류의 타입들을 제공합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ClusterIP&lt;/li&gt;
  &lt;li&gt;NodePort&lt;/li&gt;
  &lt;li&gt;LoadBalancer&lt;/li&gt;
  &lt;li&gt;ExternalName&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../images/kube_34.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
                <pubDate>Sun, 23 Jan 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/kubernetes-series5</link>
                <guid isPermaLink="true">http://localhost:4000/kubernetes-series5</guid>
                
                <category>Kubernetes</category>
                
                
                <category>devops</category>
                
            </item>
        
            <item>
                <title>Kubernetes Series [Part4]: Kubernetes 실습환경 구축하기</title>
                <description>&lt;p id=&quot;toc&quot;&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#로컬환경&quot; id=&quot;markdown-toc-로컬환경&quot;&gt;로컬환경&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#미니큐브minikube&quot; id=&quot;markdown-toc-미니큐브minikube&quot;&gt;미니큐브(minikube)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#docker-desktop&quot; id=&quot;markdown-toc-docker-desktop&quot;&gt;Docker Desktop&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#kindkubernetes-in-docker&quot; id=&quot;markdown-toc-kindkubernetes-in-docker&quot;&gt;kind(Kubernetes in Docker)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#클라우드환경&quot; id=&quot;markdown-toc-클라우드환경&quot;&gt;클라우드환경&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#gkegoogle-kubernetes-engine&quot; id=&quot;markdown-toc-gkegoogle-kubernetes-engine&quot;&gt;GKE(Google Kubernetes Engine)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ekselastic-kubernetes-service&quot; id=&quot;markdown-toc-ekselastic-kubernetes-service&quot;&gt;EKS(Elastic Kubernetes Service)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고자료&quot; id=&quot;markdown-toc-참고자료&quot;&gt;참고자료&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;로컬환경&quot;&gt;로컬환경&lt;/h1&gt;
&lt;p&gt;쿠버네티스는 여러 플랫폼 환경에서 클러스터를 구성하여 사용할 수 있습니다. 로컬 쿠버네티스는 별다른 비용 발생 없이 간단하게 클러스터를 구축해 테스트해 볼 수 있어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;테스트, 개발 환경에 적합&lt;/code&gt;합니다.&lt;/p&gt;

&lt;h2 id=&quot;미니큐브minikube&quot;&gt;미니큐브(minikube)&lt;/h2&gt;
&lt;p&gt;미니큐브는 물리 머신에 로컬 쿠버네티스를 쉽게 구축하고 실행할 수 있는 도구입니다. 실행되는 쿠버네티스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단일 노드 구성&lt;/code&gt;이기 때문에 여러 대의 구성이 필요한 쿠버네티스 기능은 사용할 수 없습니다. 또한 미니큐브는 로컬 가상 머신 위에 쿠버네티스를 설치하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하이퍼바이저(Docer, Hyperkit, VirtualBox, ..)가 필요&lt;/code&gt;합니다. 제가 현재 사용하고 있는 맥 환경에서는 기본적으로 하이퍼킷이 설치되어 있습니다. 하지만 m1칩의 경우에는 아직 하이퍼킷을 지원하지 않기 때문에 먼저 도커를 설치, 실행한 후 미니큐브를 실행하셔야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;minikube

minikube version
&lt;span class=&quot;c&quot;&gt;# minikube version: v1.25.1&lt;/span&gt;

minikube start &lt;span class=&quot;nt&quot;&gt;--driver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;docker &lt;span class=&quot;c&quot;&gt;# --kubernetes-version 옵션으로 버전 선택 가능&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--------------------------------------------------------------------------------&lt;/span&gt;
😄  Darwin 12.1 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;arm64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 의 minikube v1.25.1
✨  유저 환경 설정 정보에 기반하여 docker 드라이버를 사용하는 중
👍  minikube 클러스터의 minikube 컨트롤 플레인 노드를 시작하는 중
🚜  베이스 이미지를 다운받는 중 ...
💾  쿠버네티스 v1.23.1 을 다운로드 중 ...
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; preloaded-images-k8s-v16-v1...: 417.88 MiB / 417.88 MiB  100.00% 9.58 MiB
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; gcr.io/k8s-minikube/kicbase: 343.02 MiB / 343.02 MiB  100.00% 3.90 MiB p/
🔥  Creating docker container &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CPUs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2, &lt;span class=&quot;nv&quot;&gt;Memory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;7903MB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; ...
🐳  쿠버네티스 v1.23.1 을 Docker 20.10.12 런타임으로 설치하는 중
    ▪ kubelet.housekeeping-interval&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;5m
    ▪ 인증서 및 키를 생성하는 중 ...
    ▪ 컨트롤 플레인이 부팅...
    ▪ RBAC 규칙을 구성하는 중 ...
🔎  Kubernetes 구성 요소를 확인...
    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
🌟  애드온 활성화 : storage-provisioner, default-storageclass
🏄  끝났습니다! kubectl이 &lt;span class=&quot;s2&quot;&gt;&quot;minikube&quot;&lt;/span&gt; 클러스터와 &lt;span class=&quot;s2&quot;&gt;&quot;default&quot;&lt;/span&gt; 네임스페이스를 기본적으로 사용하도록 구성되었습니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 도커로 띄운 가상머신 위에서 쿠버네티스가 돌아가고 있습니다. 한 번 확인해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;minikube status
&lt;span class=&quot;nt&quot;&gt;--------------------&lt;/span&gt;
minikube
&lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

minikube ip
&lt;span class=&quot;c&quot;&gt;# 192.168.49.2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;정지하고 삭제하는 명령어도 간단합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;minikube stop

minikube delete
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;docker-desktop&quot;&gt;Docker Desktop&lt;/h2&gt;
&lt;p&gt;Docker Desktop은 도커를 맥/윈도우에서 사용하기 위한 목적으로 만들어졌습니다. 그리고 Docker Desktop 버전 18.06.0부터는 쿠버네티스도 사용할 수 있도록 지원하고 있습니다. 사용 방법은 간단합니다. Docker Desktop을 설치, 실행한 뒤 Enable Kubernetes 목록을 클릭해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/../../images/kube_24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(쿠버네티스를 Docker Desktop으로 실행할 때는 도커에서 제공하는 가상 머신위에 쿠버네티스 클러스터를 구성하는 것 같다. 그래서 클러스터 외부에서 쿠버네티스에 접속하려 할 때, 먼저 도커의 가상 머신 안으로 엔드포인트로 접근해야 하는데 이를 도커에서 localhost로 접근하도록 해준다. 그래서 별도로 도커 가상머신의 IP주소를 알려고 할 필요가 없다. 뇌피셜)&lt;/p&gt;

&lt;h2 id=&quot;kindkubernetes-in-docker&quot;&gt;kind(Kubernetes in Docker)&lt;/h2&gt;
&lt;p&gt;minikube와 Docker Desktop은 단일 노드로 구성된 쿠버네티스였다면, kind는 도커 컨테이너를 여러 개 띄워서 컨테이너 각각을 노드로 사용함으로써 &lt;strong&gt;멀티 노드 클러스터&lt;/strong&gt;를 구축할 수 있습니다.&lt;br /&gt;
&lt;a href=&quot;https://kind.sigs.k8s.io&quot; target=&quot;_blank&quot;&gt;(kind 공식문서 참고)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;kind

kind version
&lt;span class=&quot;nt&quot;&gt;--------------------&lt;/span&gt;
kind v0.11.1 go1.17.2 darwin/arm64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잘 설치가 되었습니다. 이제 kind를 이용해 쿠버네티스에서 마스터와 워커 노드 역할을 하는 노드를 각각 3개씩 띄워 다음과 같이 멀티 노드 클러스터를 구축해보겠습니다.&lt;/p&gt;

&lt;p&gt;(실행 결과 리소스 부족으로 kindcluster-worker2를 만들다가 오류가)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/kube_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# kind로 클러스터 구축을 위한 kind.yaml&lt;/span&gt;
apiVersion: kind.x-k8s.io/v1alpha4
kind: Cluster
nodes:
- role: control-plane
  image: kindest/node:v1.23.1
- role: control-plane
  image: kindest/node:v1.23.1
- role: control-plane
  image: kindest/node:v1.23.1
- role: worker
  image: kindest/node:v1.23.1
- role: worker
  image: kindest/node:v1.23.1
- role: worker
  image: kindest/node:v1.23.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kind create cluster &lt;span class=&quot;nt&quot;&gt;--config&lt;/span&gt; kind.yaml &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; kindcluster
&lt;span class=&quot;nt&quot;&gt;----------------------------------------------------------------------&lt;/span&gt;
Creating cluster &lt;span class=&quot;s2&quot;&gt;&quot;kindcluster&quot;&lt;/span&gt; ...
 ✓ Ensuring node image &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;kindest/node:v1.23.1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 🖼
 ✓ Preparing nodes 📦 📦 📦 📦 📦 📦
 ✓ Configuring the external load balancer ⚖️
 ✓ Writing configuration 📜
 ✓ Starting control-plane 🕹️
 ✓ Installing CNI 🔌
 ✓ Installing StorageClass 💾
 ✗ Joining worker nodes 🚜 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행 결과 리소스 부족으로 kindcluster-worker2를 만들다가 오류가 발생하여 마스터의 서버는 1개, 워커는 2개로 다시 구성해 실행해 보았습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: kind.x-k8s.io/v1alpha4
kind: Cluster
nodes:
- role: control-plane
  image: kindest/node:v1.23.1
- role: worker
  image: kindest/node:v1.23.1
- role: worker
  image: kindest/node:v1.23.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kind create cluster &lt;span class=&quot;nt&quot;&gt;--config&lt;/span&gt; kind.yaml &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; kindcluster
&lt;span class=&quot;nt&quot;&gt;----------------------------------------------------------------------&lt;/span&gt;
Creating cluster &lt;span class=&quot;s2&quot;&gt;&quot;kindcluster&quot;&lt;/span&gt; ...
 ✓ Ensuring node image &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;kindest/node:v1.23.1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 🖼
 ✓ Preparing nodes 📦 📦 📦
 ✓ Writing configuration 📜
 ✓ Starting control-plane 🕹️
 ✓ Installing CNI 🔌
 ✓ Installing StorageClass 💾
 ✓ Joining worker nodes 🚜
Set kubectl context to &lt;span class=&quot;s2&quot;&gt;&quot;kind-kindcluster&quot;&lt;/span&gt;
You can now use your cluster with:

kubectl cluster-info &lt;span class=&quot;nt&quot;&gt;--context&lt;/span&gt; kind-kindcluster

Have a &lt;span class=&quot;nb&quot;&gt;nice &lt;/span&gt;day! 👋
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;클러스터가 성공적으로 구축되었습니다.&lt;br /&gt;
쿠버네티스에서 실행중인 노드를 확인해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get nodes
----------------------------------------------------------------------------
NAME                        STATUS   ROLES                  AGE   VERSION
kindcluster-control-plane   Ready    control-plane,master   58s   v1.23.1
kindcluster-worker          Ready    &amp;lt;none&amp;gt;                 25s   v1.23.1
kindcluster-worker2         Ready    &amp;lt;none&amp;gt;                 25s   v1.23.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;클러스터는 다음 명령어로 삭제하시면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kind delete cluster &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; kindcluster
&lt;span class=&quot;nt&quot;&gt;------------------------------------------&lt;/span&gt;
Deleting cluster &lt;span class=&quot;s2&quot;&gt;&quot;kindcluster&quot;&lt;/span&gt; ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;클라우드환경&quot;&gt;클라우드환경&lt;/h1&gt;

&lt;h2 id=&quot;gkegoogle-kubernetes-engine&quot;&gt;GKE(Google Kubernetes Engine)&lt;/h2&gt;

&lt;h2 id=&quot;ekselastic-kubernetes-service&quot;&gt;EKS(Elastic Kubernetes Service)&lt;/h2&gt;

&lt;h1 id=&quot;참고자료&quot;&gt;참고자료&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9791165216283&quot; target=&quot;_blank&quot;&gt;쿠버네티스 완벽 가이드 책&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://subicura.com/k8s/guide/&quot; target=&quot;_blank&quot;&gt;subicura님의 kubenetes안내서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Sun, 23 Jan 2022 21:01:35 +0900</pubDate>
                <link>http://localhost:4000/kubernetes-series4</link>
                <guid isPermaLink="true">http://localhost:4000/kubernetes-series4</guid>
                
                <category>Kubernetes</category>
                
                
                <category>devops</category>
                
            </item>
        
    </channel>
</rss>